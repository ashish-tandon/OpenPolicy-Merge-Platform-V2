{
  "summary": {
    "total_api_routes": 235,
    "total_ui_components": 339,
    "total_mappings": 32,
    "analyzed_at": "/workspace"
  },
  "routes": {
    "GET:/": {
      "method": "GET",
      "path": "/",
      "file": "services/api-gateway/app/api/v1/endpoints/health.py",
      "line": 11,
      "dependencies": [
        "import:fastapi.APIRouter\nimport time\nfrom app.database import check_db_connection\n\nrouter = APIRouter()"
      ]
    },
    "GET:/healthz": {
      "method": "GET",
      "path": "/healthz",
      "file": "services/api-gateway/app/main.py",
      "line": 104,
      "dependencies": [
        "import:datetime.wrapper_class=structlog.stdlib.BoundLogger",
        "import:datetime.structlog.processors.JSONRenderer()\n    ]",
        "import:datetime.)\n\napp.add_middleware(TrustedHostMiddleware",
        "import:datetime.)\n\nlogger = structlog.get_logger()\n\n# Initialize FastAPI app\napp = FastAPI(\n    title=\"Merge V2 API Gateway\"",
        "import:datetime.allow_methods=[\"*\"]",
        "import:datetime.structlog.stdlib.add_log_level",
        "import:datetime.structlog.processors.UnicodeDecoder()",
        "import:datetime.\"docs\": \"/docs\"",
        "function:root",
        "import:datetime.check_db_connection\n\n# Configure structured logging\nstructlog.configure(\n    processors=[\n        structlog.stdlib.filter_by_level",
        "import:datetime.structlog.processors.format_exc_info",
        "import:datetime.logger_factory=structlog.stdlib.LoggerFactory()",
        "import:datetime.structlog.processors.StackInfoRenderer()",
        "import:datetime.structlog.stdlib.PositionalArgumentsFormatter()",
        "import:datetime.RedisRateLimitMiddleware\nfrom app.core.metrics import setup_metrics\nfrom app.database import init_db",
        "import:datetime.version=\"1.0.0\"",
        "import:datetime.Response\nimport structlog\n\nfrom app.config import settings\nfrom app.api.v1.api import api_router\nfrom app.core.middleware import RequestLoggingMiddleware",
        "import:datetime.)\n\n# Add middleware\napp.add_middleware(\n    CORSMiddleware",
        "import:datetime.prefix=\"/api/v1\")\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Initialize database on startup.\"\"\"\n    try:\n        if check_db_connection():\n            init_db()\n            print(\"\u2705 Database initialized successfully\")\n        else:\n            print(\"\u26a0\ufe0f  Database connection failed - running in mock mode\")\n    except Exception as e:\n        print(f\"\u26a0\ufe0f  Database initialization warning: {e}\")\n        print(\"   This is normal if the database schema already exists\")\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint with API information.\"\"\"\n    return {\n        \"message\": \"Welcome to OpenPolicy API\"",
        "import:datetime.datetime\nfrom fastapi import FastAPI",
        "import:datetime.structlog.processors.TimeStamper(fmt=\"iso\")",
        "import:datetime.\"version\": \"0.1.0\"",
        "import:datetime.cache_logger_on_first_use=True",
        "import:datetime.docs_url=\"/docs\" if settings.DEBUG else None",
        "import:datetime.context_class=dict",
        "import:datetime.allow_headers=[\"*\"]",
        "import:datetime.allow_origins=settings.BACKEND_CORS_ORIGINS",
        "import:datetime.redoc_url=\"/redoc\" if settings.DEBUG else None",
        "import:datetime.allowed_hosts=[\"*\"])\napp.add_middleware(RequestLoggingMiddleware)\n\n# Add rate limiting middleware based on configuration\nif settings.RATE_LIMIT_ENABLED:\n    if settings.RATE_LIMIT_BACKEND == \"redis\":\n        app.add_middleware(RedisRateLimitMiddleware)\n        logger.info(\"Redis-based rate limiting enabled\")\n    else:\n        app.add_middleware(RateLimitMiddleware)\n        logger.info(\"In-memory rate limiting enabled\")\nelse:\n    logger.info(\"Rate limiting disabled\")\n\n# Setup metrics\nsetup_metrics(app)\n\n# Include API router\napp.include_router(api_router",
        "import:datetime.structlog.stdlib.add_logger_name",
        "import:datetime.description=\"Unified API for parliamentary and municipal data\"",
        "import:datetime.allow_credentials=True",
        "import:datetime.\"health\": \"/healthz\"\n    }",
        "import:datetime.RateLimitMiddleware",
        "import:datetime.Request\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\nfrom fastapi.responses import JSONResponse"
      ]
    },
    "GET:/version": {
      "method": "GET",
      "path": "/version",
      "file": "services/api-gateway/app/main.py",
      "line": 115,
      "dependencies": [
        "import:datetime.wrapper_class=structlog.stdlib.BoundLogger",
        "import:datetime.structlog.processors.JSONRenderer()\n    ]",
        "import:datetime.)\n\napp.add_middleware(TrustedHostMiddleware",
        "import:datetime.)\n\nlogger = structlog.get_logger()\n\n# Initialize FastAPI app\napp = FastAPI(\n    title=\"Merge V2 API Gateway\"",
        "import:datetime.allow_methods=[\"*\"]",
        "import:datetime.\"database\": \"connected\"\n    }",
        "import:datetime.structlog.stdlib.add_log_level",
        "import:datetime.structlog.processors.UnicodeDecoder()",
        "import:datetime.\"docs\": \"/docs\"",
        "function:health_check",
        "import:datetime.\"timestamp\": datetime.now().isoformat() + \"Z\"",
        "import:datetime.check_db_connection\n\n# Configure structured logging\nstructlog.configure(\n    processors=[\n        structlog.stdlib.filter_by_level",
        "import:datetime.structlog.processors.format_exc_info",
        "import:datetime.logger_factory=structlog.stdlib.LoggerFactory()",
        "import:datetime.structlog.processors.StackInfoRenderer()",
        "import:datetime.\"health\": \"/healthz\"\n    }\n\n@app.get(\"/healthz\")\nasync def health_check():\n    \"\"\"Health check endpoint.\"\"\"\n    return {\n        \"status\": \"ok\"",
        "import:datetime.\"environment\": \"development\"",
        "import:datetime.structlog.stdlib.PositionalArgumentsFormatter()",
        "import:datetime.RedisRateLimitMiddleware\nfrom app.core.metrics import setup_metrics\nfrom app.database import init_db",
        "import:datetime.version=\"1.0.0\"",
        "import:datetime.Response\nimport structlog\n\nfrom app.config import settings\nfrom app.api.v1.api import api_router\nfrom app.core.middleware import RequestLoggingMiddleware",
        "import:datetime.)\n\n# Add middleware\napp.add_middleware(\n    CORSMiddleware",
        "import:datetime.prefix=\"/api/v1\")\n\n@app.on_event(\"startup\")\nasync def startup_event():\n    \"\"\"Initialize database on startup.\"\"\"\n    try:\n        if check_db_connection():\n            init_db()\n            print(\"\u2705 Database initialized successfully\")\n        else:\n            print(\"\u26a0\ufe0f  Database connection failed - running in mock mode\")\n    except Exception as e:\n        print(f\"\u26a0\ufe0f  Database initialization warning: {e}\")\n        print(\"   This is normal if the database schema already exists\")\n\n@app.get(\"/\")\nasync def root():\n    \"\"\"Root endpoint with API information.\"\"\"\n    return {\n        \"message\": \"Welcome to OpenPolicy API\"",
        "import:datetime.datetime\nfrom fastapi import FastAPI",
        "import:datetime.structlog.processors.TimeStamper(fmt=\"iso\")",
        "import:datetime.\"version\": \"0.1.0\"",
        "import:datetime.cache_logger_on_first_use=True",
        "import:datetime.docs_url=\"/docs\" if settings.DEBUG else None",
        "import:datetime.context_class=dict",
        "import:datetime.allow_headers=[\"*\"]",
        "import:datetime.allow_origins=settings.BACKEND_CORS_ORIGINS",
        "import:datetime.redoc_url=\"/redoc\" if settings.DEBUG else None",
        "import:datetime.allowed_hosts=[\"*\"])\napp.add_middleware(RequestLoggingMiddleware)\n\n# Add rate limiting middleware based on configuration\nif settings.RATE_LIMIT_ENABLED:\n    if settings.RATE_LIMIT_BACKEND == \"redis\":\n        app.add_middleware(RedisRateLimitMiddleware)\n        logger.info(\"Redis-based rate limiting enabled\")\n    else:\n        app.add_middleware(RateLimitMiddleware)\n        logger.info(\"In-memory rate limiting enabled\")\nelse:\n    logger.info(\"Rate limiting disabled\")\n\n# Setup metrics\nsetup_metrics(app)\n\n# Include API router\napp.include_router(api_router",
        "import:datetime.structlog.stdlib.add_logger_name",
        "import:datetime.description=\"Unified API for parliamentary and municipal data\"",
        "import:datetime.allow_credentials=True",
        "import:datetime.RateLimitMiddleware",
        "import:datetime.Request\nfrom fastapi.middleware.cors import CORSMiddleware\nfrom fastapi.middleware.trustedhost import TrustedHostMiddleware\nfrom fastapi.responses import JSONResponse"
      ]
    },
    "GET:/metrics": {
      "method": "GET",
      "path": "/metrics",
      "file": "services/api-gateway/app/api/v1/performance_optimization.py",
      "line": 83,
      "dependencies": [
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.performance_optimization import (\n    PerformanceMetric",
        "import:fastapi.EffortLevelEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PERFORMANCE METRICS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/metrics\"",
        "import:fastapi.metric_category=metric.metric_category",
        "import:fastapi.PerformanceMetricCreateRequest",
        "import:fastapi.PerformanceAlertResponse",
        "import:fastapi.MetricTypeEnum",
        "import:fastapi.List\nfrom datetime import datetime",
        "import:fastapi.SystemHealth\n)\nfrom app.models.users import User\nfrom app.schemas.performance_optimization import (\n    PerformanceMetricResponse",
        "import:fastapi.source_endpoint=metric.source_endpoint",
        "import:fastapi.HealthStatusEnum",
        "import:fastapi.threshold_critical=metric.threshold_critical",
        "import:fastapi.AlertSeverityEnum",
        "import:fastapi.HealthCheckRequest",
        "import:fastapi.response_model=PerformanceMetricResponse)\nasync def create_performance_metric(\n    metric_data: PerformanceMetricCreateRequest = Body(...)",
        "import:fastapi.ip_address=metric.ip_address",
        "import:fastapi.created_at=metric.created_at\n    )",
        "import:fastapi.metric_value=metric.metric_value",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.threshold_warning=metric.threshold_warning",
        "import:fastapi.MetricCategoryEnum",
        "import:fastapi.PerformanceAlertCreateRequest",
        "import:fastapi.AlertTypeEnum",
        "import:fastapi.PerformanceMetricListResponse",
        "import:fastapi.PerformanceAlertListResponse",
        "import:fastapi.metric_unit=metric.metric_unit",
        "import:fastapi.metric)\n    \n    logger.info(f\"Performance metric created: {current_user.username} - {metric_data.metric_name}\")\n    \n    return PerformanceMetricResponse(\n        id=str(metric.id)",
        "import:fastapi.metric_type=metric.metric_type",
        "import:fastapi.PerformanceAnalysisRequest",
        "function:create_performance_metric",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new performance metric.\n    \n    This creates a new performance metric for monitoring system performance.\n    \"\"\"\n    # Create new metric\n    metric = PerformanceMetric(**metric_data.dict())\n    db.add(metric)\n    db.commit()\n    db.refresh(metric)\n    \n    # Check if alert should be triggered\n    if metric.is_alert_enabled:\n        await _check_and_create_alerts(db",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Path",
        "import:fastapi.PerformanceTrend",
        "import:fastapi.metric_name=metric.metric_name",
        "import:fastapi.PerformanceAlert",
        "import:fastapi.session_id=metric.session_id",
        "import:fastapi.SystemOverview",
        "import:fastapi.ImpactLevelEnum",
        "import:fastapi.StrategyCategoryEnum",
        "import:fastapi.is_alert_enabled=metric.is_alert_enabled",
        "import:fastapi.collection_timestamp=metric.collection_timestamp",
        "import:fastapi.PriorityEnum",
        "import:fastapi.user_agent=metric.user_agent",
        "import:fastapi.OptimizationRecommendation",
        "import:fastapi.APIRouter",
        "import:fastapi.HealthCheckTypeEnum",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional"
      ]
    },
    "GET:/suggestions": {
      "method": "GET",
      "path": "/suggestions",
      "file": "services/api-gateway/app/api/v1/members.py",
      "line": 348,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.'Provincial and Municipal Governments'\n        ]",
        "import:fastapi.'constituency': rep.get('district_name'",
        "import:fastapi.fall back to basic information\n            representatives['federal'] = {\n                'level': 'federal'",
        "import:fastapi.detail=\"Invalid postal code format. Use format: A1A1A1 or A1A 1A1\")\n    \n    # Format postal code with space\n    formatted_postal_code = f\"{postal_code_clean[:3]} {postal_code_clean[3:]}\"\n    \n    representatives = {}\n    \n    try:\n        # Import httpx for external API calls\n        import httpx\n        \n        # Call Represent Canada API for comprehensive representative information\n        represent_api_url = f\"https://represent.opennorth.ca/postcodes/{postal_code_clean}/\"\n        \n        with httpx.Client(timeout=10.0) as client:\n            response = client.get(represent_api_url)\n        \n        if response.status_code == 200:\n            data = response.json()\n            \n            # Process federal representatives\n            if include_federal and 'representatives_centroid' in data:\n                federal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') == 'MP':\n                        federal_reps.append({\n                            'level': 'federal'",
        "import:fastapi.[{}])[0].get('address'",
        "import:fastapi.description=\"Province filter\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.party_slug=member.party.short_name if member.party else None",
        "import:fastapi.'suggestions': [\n                'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.sponsored_bills_count=len(sponsored_bills)",
        "import:fastapi.members.first_name || ' ' || members.last_name\n            ) @@ plainto_tsquery('english'",
        "import:fastapi.ge=1",
        "import:fastapi.'Councillor'",
        "import:fastapi.party_name=member.party.name if member.party else None",
        "import:fastapi.'unknown')}\"",
        "import:fastapi.'message': f'No municipal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.le=100",
        "import:fastapi.'MHA']:\n                        provincial_reps.append({\n                            'level': 'provincial'",
        "import:fastapi.end_date=member.end_date\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.end_date=member.end_date",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                ]\n            }\n    \n    except Exception as e:\n        # Fallback to basic information if API call fails\n        representatives['federal'] = {\n            'level': 'federal'",
        "import:fastapi.up-to-date representative information.\n    This endpoint implements the postal code search functionality required by\n    checklist items 51-70 and integrates with Feature F007: Multi-Level Government.\n    \"\"\"\n    \n    # Validate postal code format (Canadian postal code pattern)\n    import re\n    postal_code_clean = postal_code.upper().replace(\" \"",
        "import:fastapi.Jurisdiction\nfrom app.schemas.members import (\n    MemberSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Include federal representatives\")",
        "import:fastapi.'urls': {\n                                'profile': rep.get('url'",
        "import:fastapi.'message': f'No provincial representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.description=\"Show only current MPs\")",
        "import:fastapi.'Parliament of Canada'",
        "import:fastapi.pages=total_pages\n    )\n    \n    return {\n        \"members\": member_summaries",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n            ]\n        }\n    \n    if not representatives:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if provincial_reps:\n                    representatives['provincial'] = provincial_reps\n                else:\n                    representatives['provincial'] = {\n                        'level': 'provincial'",
        "import:fastapi.'postal_code': formatted_postal_code",
        "import:fastapi.'Contact office for details')\n                            }",
        "import:fastapi.MemberProfileResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.MemberListResponse",
        "import:fastapi.'message': f'Unable to determine representatives for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact your city/town hall for assistance'\n                        ]\n                    }\n        \n        else:\n            # If Represent API doesn't have data",
        "import:fastapi.[{}])[0].get('tel'",
        "import:fastapi.province=member.jurisdiction.province if member.jurisdiction else None",
        "import:fastapi.response_model=MemberDetailResponse)\nasync def get_member_detail(\n    member_id: int",
        "import:fastapi.'MLA'",
        "import:fastapi.'contact_info': {\n                                'office': rep.get('offices'",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    members = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    member_summaries = []\n    for member in members:\n        member_summaries.append(MemberSummary(\n            id=str(member.id)",
        "import:fastapi.'Reeve']:\n                        municipal_reps.append({\n                            'level': 'municipal'",
        "import:fastapi.'Provincial Legislature') if rep.get('offices') else 'Provincial Legislature'",
        "import:fastapi.detail=\"No representatives found for the specified postal code and levels\"\n        )\n    \n    return {\n        'postal_code': formatted_postal_code",
        "import:fastapi.'party_slug': rep.get('party_slug'",
        "import:fastapi.'unknown')}@parl.gc.ca\")\n                            }",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.Party",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List Members of Parliament with optional filtering and search.\n    \n    Supports:\n    - Full-text search on member names\n    - Filtering by province\n    - Filtering by party\n    - Filtering by current status\n    - Pagination\n    \"\"\"\n    \n    # Build base query - join with jurisdiction and party info\n    query = db.query(Member).join(Member.jurisdiction",
        "import:fastapi.include_federal: bool = Query(True",
        "import:fastapi.full_name=f\"{member.politician.name_given} {member.politician.name_family}\"",
        "import:fastapi.'Unknown')",
        "import:fastapi.current_only: bool = Query(True",
        "import:fastapi.description=\"Include provincial representatives\")",
        "import:fastapi.province=riding.province if riding else None",
        "import:fastapi.'province': rep.get('province'",
        "import:fastapi.'profile': f\"/api/v1/members/profile/{rep.get('id')}\" if rep.get('id') else None\n                            }\n                        })\n                \n                if federal_reps:\n                    representatives['federal'] = federal_reps\n                else:\n                    representatives['federal'] = {\n                        'level': 'federal'",
        "import:fastapi.ON K1A 0A6'",
        "import:fastapi.'suggestions': [\n                            'Visit your provincial government website to find your MLA/MPP/MNA'",
        "import:fastapi.party_slug=member.party.slug",
        "import:fastapi.MemberSuggestionsResponse",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.MemberDetail",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if province:\n        query = query.filter(Member.jurisdiction.has(Jurisdiction.province == province))\n    \n    if party:\n        query = query.filter(Party.name.ilike(f\"%{party}%\"))\n    \n    if current_only:\n        query = query.filter(Member.end_date.is_(None))\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on member names\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.Vote.votequestion.bill_id == Bill.id\n    ).filter(\n        Vote.member_id == member_id\n    ).order_by(\n        Vote.date.desc()\n    ).limit(10).all()\n    \n    member_detail = MemberDetail(\n        id=str(member.id)",
        "import:fastapi.'unknown')",
        "import:fastapi.first_name=member.politician.name_given",
        "import:fastapi.MemberDetailResponse",
        "import:fastapi.Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Member",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Include municipal representatives\")",
        "import:fastapi.Query",
        "import:fastapi.'suggestions': [\n                    'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.'MNA'",
        "import:fastapi.full_name=member.full_name or f\"{member.first_name} {member.last_name}\"",
        "import:fastapi.total=total",
        "import:fastapi.'suggestions': [\n                            'Visit your municipal government website to find your councillor'",
        "import:fastapi.'Municipal Office') if rep.get('offices') else 'Municipal Office'",
        "import:fastapi.isouter=True).join(Member.party",
        "import:fastapi.\"pagination\": pagination\n    }\n\n\n@router.get(\"/{member_id}\"",
        "import:fastapi.description=\"Party slug filter\")",
        "import:fastapi.'urls': {\n                                'parliament': f\"https://www.ourcommons.ca/members/en/{rep.get('slug'",
        "import:fastapi.constituency=member.district",
        "import:fastapi.constituency=riding.name_en if riding else None",
        "import:fastapi.last_name=member.politician.name_family",
        "import:fastapi.is_current=member.end_date is None",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific Member of Parliament.\n    \"\"\"\n    member = db.query(Member).filter(Member.id == member_id).first()\n    \n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.# Dynamic timestamp\n        'accuracy_note': 'Representative information is sourced from the Represent Canada API and is updated regularly'\n    }",
        "import:fastapi.'member_id': rep.get('id')",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.party_name=member.party.name_en",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get riding info\n    riding = db.query(Riding).filter(Riding.id == member.riding_id).first()\n    \n    # Get sponsored bills\n    sponsored_bills = db.query(Bill).filter(Bill.sponsor_member_id == member_id).all()\n    \n    # Get recent votes\n    recent_votes = db.query(\n        Vote",
        "import:fastapi.'representatives': representatives",
        "function:get_members_by_postal_code",
        "import:fastapi.'contact_info': {\n                                'hill_office': 'House of Commons",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find Members of Parliament and other representatives by postal code.\n    \n    Uses the Represent Canada API for accurate",
        "import:fastapi.'full_name': rep.get('name'",
        "import:fastapi.Bill\n    ).join(\n        Bill",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if municipal_reps:\n                    representatives['municipal'] = municipal_reps\n                else:\n                    representatives['municipal'] = {\n                        'level': 'municipal'",
        "import:fastapi.'suggestions': [\n                            'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.'613-992-4793') if rep.get('offices') else '613-992-4793'",
        "import:fastapi.'Independent')",
        "import:fastapi.description=\"Search query for member name\")",
        "import:fastapi.first_name=member.first_name",
        "import:fastapi.'party': rep.get('party_name'",
        "import:fastapi.'data_sources': [\n            'Represent Canada API'",
        "import:fastapi.start_date=member.start_date",
        "import:fastapi.postal_code_clean):\n        raise HTTPException(status_code=400",
        "import:fastapi.f\"{rep.get('slug'",
        "import:fastapi.'last_updated': '2025-08-22'",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import List",
        "import:fastapi.'phone': rep.get('offices'",
        "import:fastapi.'Contact office for details') if rep.get('offices') else 'Contact office for details'",
        "import:fastapi.Vote",
        "import:fastapi.Ottawa",
        "import:fastapi.include_municipal: bool = Query(False",
        "import:fastapi.recent_votes_count=len(recent_votes)\n    )\n    \n    return MemberDetailResponse(member=member_detail)\n\n\n@router.get(\"/by-postal-code/{postal_code}\")\nasync def get_members_by_postal_code(\n    postal_code: str",
        "import:fastapi.'Contact your provincial elections office for assistance'\n                        ]\n                    }\n            \n            # Process municipal representatives\n            if include_municipal and 'representatives_centroid' in data:\n                municipal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['Mayor'",
        "import:fastapi.response_model=MemberListResponse)\nasync def list_members(\n    q: Optional[str] = Query(None",
        "import:fastapi.include_provincial: bool = Query(False",
        "import:fastapi.last_name=member.last_name",
        "import:fastapi.MemberSummaryResponse",
        "import:fastapi.\"\")\n    if not re.match(r'^[A-Z]\\d[A-Z]\\d[A-Z]\\d$'",
        "import:fastapi.Pagination",
        "import:fastapi.'Municipality')",
        "import:fastapi.'message': f'No federal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                        ]\n                    }\n            \n            # Process provincial representatives\n            if include_provincial and 'representatives_centroid' in data:\n                provincial_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['MPP'",
        "import:fastapi.'email': rep.get('email'",
        "import:fastapi.APIRouter",
        "import:fastapi.MemberProfile"
      ]
    },
    "GET:/summary/stats": {
      "method": "GET",
      "path": "/summary/stats",
      "file": "services/api-gateway/app/api/v1/members.py",
      "line": 384,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.'Provincial and Municipal Governments'\n        ]",
        "import:fastapi.'constituency': rep.get('district_name'",
        "import:fastapi.cp.name_given\n        LIMIT :limit\n    \"\"\")\n    \n    results = db.execute(suggestions_query",
        "import:fastapi.fall back to basic information\n            representatives['federal'] = {\n                'level': 'federal'",
        "import:fastapi.detail=\"Invalid postal code format. Use format: A1A1A1 or A1A 1A1\")\n    \n    # Format postal code with space\n    formatted_postal_code = f\"{postal_code_clean[:3]} {postal_code_clean[3:]}\"\n    \n    representatives = {}\n    \n    try:\n        # Import httpx for external API calls\n        import httpx\n        \n        # Call Represent Canada API for comprehensive representative information\n        represent_api_url = f\"https://represent.opennorth.ca/postcodes/{postal_code_clean}/\"\n        \n        with httpx.Client(timeout=10.0) as client:\n            response = client.get(represent_api_url)\n        \n        if response.status_code == 200:\n            data = response.json()\n            \n            # Process federal representatives\n            if include_federal and 'representatives_centroid' in data:\n                federal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') == 'MP':\n                        federal_reps.append({\n                            'level': 'federal'",
        "import:fastapi.similarity(cp.name_given || ' ' || cp.name_family",
        "import:fastapi.[{}])[0].get('address'",
        "import:fastapi.description=\"Province filter\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.party_slug=member.party.short_name if member.party else None",
        "import:fastapi.'suggestions': [\n                'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.sponsored_bills_count=len(sponsored_bills)",
        "import:fastapi.members.first_name || ' ' || members.last_name\n            ) @@ plainto_tsquery('english'",
        "import:fastapi.ge=1",
        "import:fastapi.'Councillor'",
        "import:fastapi.party_name=member.party.name if member.party else None",
        "import:fastapi.'unknown')}\"",
        "import:fastapi.'message': f'No municipal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.le=100",
        "import:fastapi.'MHA']:\n                        provincial_reps.append({\n                            'level': 'provincial'",
        "import:fastapi.end_date=member.end_date\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.end_date=member.end_date",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                ]\n            }\n    \n    except Exception as e:\n        # Fallback to basic information if API call fails\n        representatives['federal'] = {\n            'level': 'federal'",
        "import:fastapi.up-to-date representative information.\n    This endpoint implements the postal code search functionality required by\n    checklist items 51-70 and integrates with Feature F007: Multi-Level Government.\n    \"\"\"\n    \n    # Validate postal code format (Canadian postal code pattern)\n    import re\n    postal_code_clean = postal_code.upper().replace(\" \"",
        "import:fastapi.Jurisdiction\nfrom app.schemas.members import (\n    MemberSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Include federal representatives\")",
        "import:fastapi.'urls': {\n                                'profile': rep.get('url'",
        "import:fastapi.'message': f'No provincial representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.description=\"Show only current MPs\")",
        "import:fastapi.'Parliament of Canada'",
        "import:fastapi.cp.name_family",
        "import:fastapi.pages=total_pages\n    )\n    \n    return {\n        \"members\": member_summaries",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n            ]\n        }\n    \n    if not representatives:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if provincial_reps:\n                    representatives['provincial'] = provincial_reps\n                else:\n                    representatives['provincial'] = {\n                        'level': 'provincial'",
        "import:fastapi.'postal_code': formatted_postal_code",
        "import:fastapi.'Contact office for details')\n                            }",
        "import:fastapi.MemberProfileResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.MemberListResponse",
        "import:fastapi.'message': f'Unable to determine representatives for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact your city/town hall for assistance'\n                        ]\n                    }\n        \n        else:\n            # If Represent API doesn't have data",
        "import:fastapi.[{}])[0].get('tel'",
        "import:fastapi.province=member.jurisdiction.province if member.jurisdiction else None",
        "import:fastapi.response_model=MemberDetailResponse)\nasync def get_member_detail(\n    member_id: int",
        "import:fastapi.'MLA'",
        "import:fastapi.'contact_info': {\n                                'office': rep.get('offices'",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    members = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    member_summaries = []\n    for member in members:\n        member_summaries.append(MemberSummary(\n            id=str(member.id)",
        "import:fastapi.description=\"Search query for member suggestions\")",
        "import:fastapi.response_model=MemberSuggestionsResponse)\nasync def get_member_suggestions(\n    q: str = Query(...",
        "import:fastapi.# Dynamic timestamp\n        'accuracy_note': 'Representative information is sourced from the Represent Canada API and is updated regularly'\n    }\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.'Reeve']:\n                        municipal_reps.append({\n                            'level': 'municipal'",
        "import:fastapi.'Provincial Legislature') if rep.get('offices') else 'Provincial Legislature'",
        "import:fastapi.detail=\"No representatives found for the specified postal code and levels\"\n        )\n    \n    return {\n        'postal_code': formatted_postal_code",
        "import:fastapi.min_length=1",
        "import:fastapi.'party_slug': rep.get('party_slug'",
        "import:fastapi.'unknown')}@parl.gc.ca\")\n                            }",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.Party",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List Members of Parliament with optional filtering and search.\n    \n    Supports:\n    - Full-text search on member names\n    - Filtering by province\n    - Filtering by party\n    - Filtering by current status\n    - Pagination\n    \"\"\"\n    \n    # Build base query - join with jurisdiction and party info\n    query = db.query(Member).join(Member.jurisdiction",
        "import:fastapi.include_federal: bool = Query(True",
        "import:fastapi.full_name=f\"{member.politician.name_given} {member.politician.name_family}\"",
        "import:fastapi.'Unknown')",
        "import:fastapi.le=50",
        "import:fastapi.current_only: bool = Query(True",
        "import:fastapi.description=\"Include provincial representatives\")",
        "import:fastapi.province=riding.province if riding else None",
        "import:fastapi.'province': rep.get('province'",
        "import:fastapi.'profile': f\"/api/v1/members/profile/{rep.get('id')}\" if rep.get('id') else None\n                            }\n                        })\n                \n                if federal_reps:\n                    representatives['federal'] = federal_reps\n                else:\n                    representatives['federal'] = {\n                        'level': 'federal'",
        "import:fastapi.ON K1A 0A6'",
        "import:fastapi.'suggestions': [\n                            'Visit your provincial government website to find your MLA/MPP/MNA'",
        "import:fastapi.party_slug=member.party.slug",
        "import:fastapi.{\"query\": q",
        "import:fastapi.MemberSuggestionsResponse",
        "import:fastapi.page: int = Query(1",
        "function:get_member_suggestions",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.MemberDetail",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if province:\n        query = query.filter(Member.jurisdiction.has(Jurisdiction.province == province))\n    \n    if party:\n        query = query.filter(Party.name.ilike(f\"%{party}%\"))\n    \n    if current_only:\n        query = query.filter(Member.end_date.is_(None))\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on member names\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.Vote.votequestion.bill_id == Bill.id\n    ).filter(\n        Vote.member_id == member_id\n    ).order_by(\n        Vote.date.desc()\n    ).limit(10).all()\n    \n    member_detail = MemberDetail(\n        id=str(member.id)",
        "import:fastapi.'unknown')",
        "import:fastapi.first_name=member.politician.name_given",
        "import:fastapi.MemberDetailResponse",
        "import:fastapi.Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Member",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Include municipal representatives\")",
        "import:fastapi.Query",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get member name suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return MemberSuggestionsResponse(suggestions=[])\n    \n    # Use trigram similarity for fuzzy matching on politician names\n    suggestions_query = text(\"\"\"\n        SELECT em.id",
        "import:fastapi.'suggestions': [\n                    'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.'MNA'",
        "import:fastapi.full_name=member.full_name or f\"{member.first_name} {member.last_name}\"",
        "import:fastapi.total=total",
        "import:fastapi.'suggestions': [\n                            'Visit your municipal government website to find your councillor'",
        "import:fastapi.'Municipal Office') if rep.get('offices') else 'Municipal Office'",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.isouter=True).join(Member.party",
        "import:fastapi.\"pagination\": pagination\n    }\n\n\n@router.get(\"/{member_id}\"",
        "import:fastapi.description=\"Party slug filter\")",
        "import:fastapi.'urls': {\n                                'parliament': f\"https://www.ourcommons.ca/members/en/{rep.get('slug'",
        "import:fastapi.constituency=member.district",
        "import:fastapi.constituency=riding.name_en if riding else None",
        "import:fastapi.last_name=member.politician.name_family",
        "import:fastapi.is_current=member.end_date is None",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific Member of Parliament.\n    \"\"\"\n    member = db.query(Member).filter(Member.id == member_id).first()\n    \n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.'member_id': rep.get('id')",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.party_name=member.party.name_en",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get riding info\n    riding = db.query(Riding).filter(Riding.id == member.riding_id).first()\n    \n    # Get sponsored bills\n    sponsored_bills = db.query(Bill).filter(Bill.sponsor_member_id == member_id).all()\n    \n    # Get recent votes\n    recent_votes = db.query(\n        Vote",
        "import:fastapi.'representatives': representatives",
        "import:fastapi.'contact_info': {\n                                'hill_office': 'House of Commons",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find Members of Parliament and other representatives by postal code.\n    \n    Uses the Represent Canada API for accurate",
        "import:fastapi.'full_name': rep.get('name'",
        "import:fastapi.Bill\n    ).join(\n        Bill",
        "import:fastapi.\"full_name\": f\"{row.name_given} {row.name_family}\"",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if municipal_reps:\n                    representatives['municipal'] = municipal_reps\n                else:\n                    representatives['municipal'] = {\n                        'level': 'municipal'",
        "import:fastapi.'suggestions': [\n                            'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.'613-992-4793') if rep.get('offices') else '613-992-4793'",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n    \n    return MemberSuggestionsResponse(suggestions=suggestions)",
        "import:fastapi.'Independent')",
        "import:fastapi.description=\"Search query for member name\")",
        "import:fastapi.first_name=member.first_name",
        "import:fastapi.'party': rep.get('party_name'",
        "import:fastapi.'data_sources': [\n            'Represent Canada API'",
        "import:fastapi.start_date=member.start_date",
        "import:fastapi.postal_code_clean):\n        raise HTTPException(status_code=400",
        "import:fastapi.f\"{rep.get('slug'",
        "import:fastapi.'last_updated': '2025-08-22'",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import List",
        "import:fastapi.'phone': rep.get('offices'",
        "import:fastapi.'Contact office for details') if rep.get('offices') else 'Contact office for details'",
        "import:fastapi.Vote",
        "import:fastapi.Ottawa",
        "import:fastapi.cp.name_given",
        "import:fastapi.include_municipal: bool = Query(False",
        "import:fastapi.recent_votes_count=len(recent_votes)\n    )\n    \n    return MemberDetailResponse(member=member_detail)\n\n\n@router.get(\"/by-postal-code/{postal_code}\")\nasync def get_members_by_postal_code(\n    postal_code: str",
        "import:fastapi.'Contact your provincial elections office for assistance'\n                        ]\n                    }\n            \n            # Process municipal representatives\n            if include_municipal and 'representatives_centroid' in data:\n                municipal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['Mayor'",
        "import:fastapi.response_model=MemberListResponse)\nasync def list_members(\n    q: Optional[str] = Query(None",
        "import:fastapi.include_provincial: bool = Query(False",
        "import:fastapi.last_name=member.last_name",
        "import:fastapi.MemberSummaryResponse",
        "import:fastapi.\"\")\n    if not re.match(r'^[A-Z]\\d[A-Z]\\d[A-Z]\\d$'",
        "import:fastapi.:query) as sim\n        FROM core_member em\n        JOIN core_politician cp ON em.politician_id = cp.id\n        WHERE cp.name_given || ' ' || cp.name_family % :query\n        ORDER BY sim DESC",
        "import:fastapi.Pagination",
        "import:fastapi.\"limit\": limit})\n    \n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Municipality')",
        "import:fastapi.'message': f'No federal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                        ]\n                    }\n            \n            # Process provincial representatives\n            if include_provincial and 'representatives_centroid' in data:\n                provincial_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['MPP'",
        "import:fastapi.'email': rep.get('email'",
        "import:fastapi.APIRouter",
        "import:fastapi.MemberProfile"
      ]
    },
    "GET:/{bill_id}": {
      "method": "GET",
      "path": "/{bill_id}",
      "file": "services/api-gateway/app/api/v1/bills.py",
      "line": 165,
      "dependencies": [
        "import:fastapi.HTTPException",
        "import:fastapi.\"bill_number\": row.number",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.status=bill.status",
        "import:fastapi.# Not available in this schema\n            session_name=f\"Session {bill.session_id}\"",
        "import:fastapi.bills.name) @@ plainto_tsquery('english'",
        "import:fastapi.BillStatus",
        "import:fastapi.tags=[]  # Not available in this schema\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return BillListResponse(\n        bills=bill_summaries",
        "import:fastapi.title=bill.title",
        "import:fastapi.Member",
        "import:fastapi.pagination=Pagination(\n            page=page",
        "import:fastapi.description=\"Bill status filter\")",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.# Not available in this schema\n            party_name=None",
        "import:fastapi.BillDetailResponse",
        "import:fastapi.response_model=BillSuggestionsResponse)\nasync def get_bill_suggestions(\n    q: str = Query(...",
        "import:fastapi.{\"query\": q",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.status_code).all()\n    \n    # Get bills by session\n    session_counts = db.query(\n        Bill.session_id",
        "import:fastapi.:query) as sim\n        FROM bills_bill\n        WHERE name_en % :query\n        ORDER BY sim DESC",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.session_id).all()\n\n    return BillSummaryResponse(\n        total_bills=total_bills",
        "import:fastapi.BillDetail",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.count in session_counts}\n    )",
        "import:fastapi.# Use title as short title\n            summary=bill.summary",
        "import:fastapi.session_breakdown={session: count for session",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.ge=1",
        "import:fastapi.Jurisdiction",
        "import:fastapi.number",
        "import:fastapi.Vote",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.status_breakdown={status: count for status",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill title suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return BillSuggestionsResponse(suggestions=[])\n\n    # Use trigram similarity for fuzzy matching\n    suggestions_query = text(\"\"\"\n        SELECT id",
        "import:fastapi.VoteInfo",
        "import:fastapi.keywords=bill.keywords or []",
        "import:fastapi.name_en\n        LIMIT :limit\n    \"\"\")\n\n    results = db.execute(suggestions_query",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.min_length=1",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.BillSuggestionsResponse",
        "import:fastapi.count in status_counts}",
        "import:fastapi.Query",
        "import:fastapi.description=\"Search query for bill suggestions\")",
        "import:fastapi.le=100",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n\n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    bills = query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    bill_summaries = []\n    \n    for bill in bills:\n        bill_summaries.append(BillSummary(\n            id=str(bill.id)",
        "import:fastapi.pages=total_pages\n        )\n    )\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.total=total",
        "import:fastapi.\"title\": row.name_en",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.BillSummaryResponse",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.'44-1')\")",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.BillStage\n)\nfrom app.schemas.amendments import (\n    AmendmentSummary",
        "import:fastapi.Party",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.BillStatusResponse",
        "import:fastapi.AmendmentListResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.similarity(name_en",
        "import:fastapi.Pagination",
        "import:fastapi.short_title=bill.title[:100] if bill.title else None",
        "import:fastapi.le=50",
        "import:fastapi.\"limit\": limit})\n\n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n\n    return BillSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.Session\nfrom app.schemas.bills import (\n    BillSummary",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List bills with optional filtering and search.\n\n    Supports:\n    - Full-text search on title\n    - Filtering by session\n    - Filtering by status\n    - Pagination\n    \"\"\"\n\n    # Build base query\n    query = db.query(Bill)\n\n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n\n    if status:\n        query = query.filter(Bill.status == status)\n\n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on name\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.APIRouter",
        "import:fastapi.name_en",
        "import:fastapi.response_model=BillSummaryResponse)\nasync def get_bill_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about bills.\n    \"\"\"\n    # Get total bills count\n    total_bills = db.query(Bill).count()\n    \n    # Get bills by status\n    status_counts = db.query(\n        Bill.status_code",
        "import:fastapi.BillListResponse",
        "function:get_bill_summary_stats",
        "import:fastapi.sponsor_name=None"
      ]
    },
    "GET:/{bill_id}/votes": {
      "method": "GET",
      "path": "/{bill_id}/votes",
      "file": "services/api-gateway/app/api/v1/bills.py",
      "line": 308,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.\"third_reading\": 6",
        "import:fastapi.BillStatus",
        "import:fastapi.title=bill.title",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.session_id).all()\n\n    return BillSummaryResponse(\n        total_bills=total_bills",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'Unknown') if str(type(bill.session_id)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    institution = getattr(bill",
        "import:fastapi.# Use title as short title\n            summary=bill.summary",
        "import:fastapi.'session_id'",
        "import:fastapi.institution=institution",
        "import:fastapi.description=vote.description_en",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.ge=1",
        "import:fastapi.bill_number=bill_number",
        "import:fastapi.VoteInfo",
        "import:fastapi.count in status_counts}",
        "import:fastapi.datetime\n    \n    today = date.today()\n    \n    # Determine current stage based on bill status\n    status_to_stage = {\n        \"INTRODUCED\": \"introduction\"",
        "import:fastapi.\"second_reading\": 3",
        "import:fastapi.# Not available in this schema\n        status=status",
        "import:fastapi.session_id=session_id",
        "import:fastapi.'introduced'",
        "import:fastapi.total_legislative_days=total_legislative_days\n    )\n\n    return BillDetailResponse(bill=bill_detail)",
        "import:fastapi.description=\"Search query for bill suggestions\")",
        "import:fastapi.'name_en'",
        "import:fastapi.le=100",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n\n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    bills = query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    bill_summaries = []\n    \n    for bill in bills:\n        bill_summaries.append(BillSummary(\n            id=str(bill.id)",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    title = getattr(bill",
        "import:fastapi.\"REPORT\": \"report_stage\"",
        "import:fastapi.\"introduction\")\n    \n    # Calculate stage progress (simplified)\n    stage_order = {\n        \"introduction\": 1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List bills with optional filtering and search.\n\n    Supports:\n    - Full-text search on title\n    - Filtering by session\n    - Filtering by status\n    - Pagination\n    \"\"\"\n\n    # Build base query\n    query = db.query(Bill)\n\n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n\n    if status:\n        query = query.filter(Bill.status == status)\n\n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on name\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.name_en",
        "import:fastapi.count in session_counts}\n    )\n\n\n@router.get(\"/{bill_id}\"",
        "import:fastapi.summary=None",
        "import:fastapi.Session\nfrom app.schemas.bills import (\n    BillSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get sponsor info\n    sponsor_name = None\n    party_name = None\n    riding_name = None\n\n    if bill.sponsor_member_id:\n        sponsor_member = db.query(Member).filter(\n            Member.id == bill.sponsor_member_id\n        ).first()\n\n        if sponsor_member:\n            sponsor_name = f\"{sponsor_member.politician.name_given} {sponsor_member.politician.name_family}\"\n\n            # Get party info\n            party = db.query(Party).filter(Party.id == sponsor_member.party_id).first()\n            if party:\n                party_name = party.name_en\n\n            # Get riding info\n            riding = db.query(Riding).filter(Riding.id == sponsor_member.riding_id).first()\n            if riding:\n                riding_name = riding.name_en\n\n    # Get vote information\n    votes = db.query(Vote).filter(Vote.bill_id == bill_id).all()\n    \n    vote_info = []\n\n    for vote in votes:\n        vote_info.append(VoteInfo(\n            vote_id=str(vote.id)",
        "import:fastapi.# Enhanced status tracking\n        current_stage=current_stage",
        "import:fastapi.\"FIRST_READING\": \"first_reading\"",
        "import:fastapi.status=bill.status",
        "import:fastapi.\"ROYAL_ASSENT\": \"royal_assent\"",
        "import:fastapi.'Unknown') if str(type(bill.institution)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n\n    # Calculate enhanced status tracking information\n    from datetime import date",
        "import:fastapi.Member",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.status_code).all()\n    \n    # Get bills by session\n    session_counts = db.query(\n        Bill.session_id",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.date) and current_stage_order < 8:\n        remaining_stages = 8 - current_stage_order\n        estimated_days = remaining_stages * 30  # Assume 30 days per stage\n        estimated_completion = introduced_date + datetime.timedelta(days=estimated_days)\n    \n    bill_detail = BillDetail(\n        id=bill_id_str",
        "import:fastapi.BillDetailResponse",
        "import:fastapi.party_name=party_name",
        "import:fastapi.votes=vote_info",
        "import:fastapi.'status_code'",
        "import:fastapi.BillDetail",
        "import:fastapi.\"royal_assent\": 8\n    }\n    current_stage_order = stage_order.get(current_stage",
        "import:fastapi.\"LAW\": \"royal_assent\"\n    }\n    \n    current_stage = status_to_stage.get(status",
        "import:fastapi.\"PASSED\": \"senate\"",
        "import:fastapi.'Unknown') if str(type(bill.short_title_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    status = getattr(bill",
        "import:fastapi.'legisinfo_id'",
        "import:fastapi.# LEGISinfo integration\n        legisinfo_id=getattr(bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill title suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return BillSuggestionsResponse(suggestions=[])\n\n    # Use trigram similarity for fuzzy matching\n    suggestions_query = text(\"\"\"\n        SELECT id",
        "import:fastapi.keywords=bill.keywords or []",
        "import:fastapi.min_length=1",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    session_id = getattr(bill",
        "import:fastapi.# Use description_en from database\n            result=vote.result\n        ))\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_id_str = str(bill.id) if hasattr(bill",
        "import:fastapi.BillSummaryResponse",
        "import:fastapi.BillStage\n)\nfrom app.schemas.amendments import (\n    AmendmentSummary",
        "import:fastapi.Party",
        "function:get_bill_detail",
        "import:fastapi.BillStatusResponse",
        "import:fastapi.short_title=short_title",
        "import:fastapi.le=50",
        "import:fastapi.vote_date=vote.date",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.response_model=BillDetailResponse)\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.\"bill_number\": row.number",
        "import:fastapi.'id') and bill.id is not None else str(bill_id)\n    bill_number = getattr(bill",
        "import:fastapi.'Unknown') if str(type(bill.name_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    short_title = getattr(bill",
        "import:fastapi.# Not available in this schema\n            session_name=f\"Session {bill.session_id}\"",
        "import:fastapi.bills.name) @@ plainto_tsquery('english'",
        "import:fastapi.date):\n        total_legislative_days = (today - introduced_date).days\n        last_activity_date = introduced_date  # Simplified - would come from actual activity tracking\n    \n    # Estimate completion date\n    estimated_completion = None\n    if isinstance(introduced_date",
        "import:fastapi.description=\"Bill status filter\")",
        "import:fastapi.# Not available in this schema\n            party_name=None",
        "import:fastapi.response_model=BillSuggestionsResponse)\nasync def get_bill_suggestions(\n    q: str = Query(...",
        "import:fastapi.{\"query\": q",
        "import:fastapi.library_summary=None",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'number'",
        "import:fastapi.\"SECOND_READING\": \"second_reading\"",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.'institution'",
        "import:fastapi.Jurisdiction",
        "import:fastapi.number",
        "import:fastapi.\"THIRD_READING\": \"third_reading\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.status_breakdown={status: count for status",
        "import:fastapi.name_en\n        LIMIT :limit\n    \"\"\")\n\n    results = db.execute(suggestions_query",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.BillSuggestionsResponse",
        "import:fastapi.Query",
        "import:fastapi.# Would come from Library of Parliament API\n        \n        # Bill lifecycle\n        last_activity_date=last_activity_date",
        "import:fastapi.days_in_current_stage=days_in_current_stage",
        "import:fastapi.total=total",
        "import:fastapi.\"title\": row.name_en",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.riding_name=riding_name",
        "import:fastapi.\"first_reading\": 2",
        "import:fastapi.short_title=bill.title[:100] if bill.title else None",
        "import:fastapi.\"limit\": limit})\n\n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Unknown') if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    introduced_date = getattr(bill",
        "import:fastapi.1)\n    stage_progress = (current_stage_order - 1) / 7.0  # 8 stages total\n    \n    # Determine next stage\n    next_stage = None\n    if current_stage_order < 8:\n        next_stage = list(stage_order.keys())[current_stage_order]\n    \n    # Calculate lifecycle information\n    last_activity_date = None\n    days_in_current_stage = 0\n    total_legislative_days = 0\n    \n    if isinstance(introduced_date",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n\n    return BillSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.response_model=BillSummaryResponse)\nasync def get_bill_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about bills.\n    \"\"\"\n    # Get total bills count\n    total_bills = db.query(Bill).count()\n    \n    # Get bills by status\n    status_counts = db.query(\n        Bill.status_code",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.title=title",
        "import:fastapi.None)",
        "import:fastapi.tags=[]  # Not available in this schema\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return BillListResponse(\n        bills=bill_summaries",
        "import:fastapi.pagination=Pagination(\n            page=page",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific bill.\n    \"\"\"\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"committee_stage\": 4",
        "import:fastapi.next_stage=next_stage",
        "import:fastapi.\"COMMITTEE\": \"committee_stage\"",
        "import:fastapi.\"senate\": 7",
        "import:fastapi.stage_progress=stage_progress",
        "import:fastapi.session_breakdown={session: count for session",
        "import:fastapi.introduced_date=introduced_date",
        "import:fastapi.estimated_completion=estimated_completion",
        "import:fastapi.Vote",
        "import:fastapi.pages=total_pages\n        )\n    )\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.\"report_stage\": 5",
        "import:fastapi.'short_title_en'",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.'44-1')\")",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.AmendmentListResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.similarity(name_en",
        "import:fastapi.Pagination",
        "import:fastapi.sponsor_name=sponsor_name",
        "import:fastapi.APIRouter",
        "import:fastapi.BillListResponse",
        "import:fastapi.:query) as sim\n        FROM bills_bill\n        WHERE name_en % :query\n        ORDER BY sim DESC",
        "import:fastapi.sponsor_name=None"
      ]
    },
    "GET:/{bill_id}/history": {
      "method": "GET",
      "path": "/{bill_id}/history",
      "file": "services/api-gateway/app/api/v1/bills.py",
      "line": 643,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    bill_number = getattr(bill",
        "import:fastapi.\"third_reading\": 6",
        "import:fastapi.line_number=amendment.line_number",
        "import:fastapi.\"timeline\": timeline_events",
        "import:fastapi.amendment_type=amendment.amendment_type",
        "import:fastapi.BillStatus",
        "import:fastapi.\"date\": bill.introduced.isoformat()",
        "import:fastapi.title=bill.title",
        "import:fastapi.'House')\n        })\n    \n    # Add typical parliamentary stages\n    stages = [\n        {\n            \"stage\": \"first_reading\"",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.session_id).all()\n\n    return BillSummaryResponse(\n        total_bills=total_bills",
        "import:fastapi.\"title\": \"Second Reading\"",
        "import:fastapi.status=amendment.status",
        "import:fastapi.\"title\": f\"Status: {bill_status_code}\"",
        "import:fastapi.None) if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else None\n\n    # Add introduction\n    if bill_introduced:\n        history_items.append({\n            \"id\": f\"intro-{bill_id}\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'Unknown') if str(type(bill.session_id)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    institution = getattr(bill",
        "import:fastapi.\"bill_id\": str(vote.bill_id)",
        "import:fastapi.\"DEFEATED\": \"Bill defeated\"",
        "import:fastapi.# Use title as short title\n            summary=bill.summary",
        "import:fastapi.'session_id'",
        "import:fastapi.institution=institution",
        "import:fastapi.total_legislative_days=total_legislative_days\n    )\n\n    return BillDetailResponse(bill=bill_detail)\n\n\n@router.get(\"/{bill_id}/votes\")\nasync def get_bill_votes(\n    bill_id: int",
        "import:fastapi.mover_name=mover_name",
        "import:fastapi.description=vote.description_en",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.description=\"Response format (json/minimal)\")",
        "import:fastapi.ge=1",
        "import:fastapi.bill_number=bill_number",
        "import:fastapi.VoteInfo",
        "import:fastapi.count in status_counts}",
        "import:fastapi.datetime\n    \n    today = date.today()\n    \n    # Determine current stage based on bill status\n    status_to_stage = {\n        \"INTRODUCED\": \"introduction\"",
        "import:fastapi.\"second_reading\": 3",
        "import:fastapi.# Not available in this schema\n        status=status",
        "import:fastapi.session_id=session_id",
        "import:fastapi.'introduced'",
        "import:fastapi.\"date\": bill_introduced or \"Unknown\"",
        "import:fastapi.description=\"Search query for bill suggestions\")",
        "import:fastapi.'name_en'",
        "import:fastapi.le=100",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n\n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    bills = query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    bill_summaries = []\n    \n    for bill in bills:\n        bill_summaries.append(BillSummary(\n            id=str(bill.id)",
        "import:fastapi.institution=amendment.institution",
        "import:fastapi.\"stage\": stage[\"stage\"]",
        "import:fastapi.stage=amendment.stage",
        "import:fastapi.\"vote_date\": vote.date",
        "import:fastapi.proposed_date=amendment.proposed_date",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get the legislative timeline for a specific bill.\n    \n    Returns a chronological sequence of events in the bill's legislative journey",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    title = getattr(bill",
        "import:fastapi.\"REPORT\": \"report_stage\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get amendments for a specific bill.\n\n    Returns all amendments proposed for the specified bill",
        "import:fastapi.f\"Status changed to {bill_status_code}\")\n        history_items.append({\n            \"id\": f\"status-{bill_id}\"",
        "import:fastapi.\"introduction\")\n    \n    # Calculate stage progress (simplified)\n    stage_order = {\n        \"introduction\": 1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List bills with optional filtering and search.\n\n    Supports:\n    - Full-text search on title\n    - Filtering by session\n    - Filtering by status\n    - Pagination\n    \"\"\"\n\n    # Build base query\n    query = db.query(Bill)\n\n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n\n    if status:\n        query = query.filter(Bill.status == status)\n\n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on name\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.# Use description_en from database\n            \"result\": vote.result",
        "import:fastapi.stage in enumerate(stages):\n        timeline_events.append({\n            \"id\": f\"{bill_id}_{stage['stage']}\"",
        "import:fastapi.name_en",
        "import:fastapi.count in session_counts}\n    )\n\n\n@router.get(\"/{bill_id}\"",
        "import:fastapi.summary=None",
        "import:fastapi.Session\nfrom app.schemas.bills import (\n    BillSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get sponsor info\n    sponsor_name = None\n    party_name = None\n    riding_name = None\n\n    if bill.sponsor_member_id:\n        sponsor_member = db.query(Member).filter(\n            Member.id == bill.sponsor_member_id\n        ).first()\n\n        if sponsor_member:\n            sponsor_name = f\"{sponsor_member.politician.name_given} {sponsor_member.politician.name_family}\"\n\n            # Get party info\n            party = db.query(Party).filter(Party.id == sponsor_member.party_id).first()\n            if party:\n                party_name = party.name_en\n\n            # Get riding info\n            riding = db.query(Riding).filter(Riding.id == sponsor_member.riding_id).first()\n            if riding:\n                riding_name = riding.name_en\n\n    # Get vote information\n    votes = db.query(Vote).filter(Vote.bill_id == bill_id).all()\n    \n    vote_info = []\n\n    for vote in votes:\n        vote_info.append(VoteInfo(\n            vote_id=str(vote.id)",
        "import:fastapi.description_en=amendment.description_en",
        "import:fastapi.# Enhanced status tracking\n        current_stage=current_stage",
        "import:fastapi.\"FIRST_READING\": \"first_reading\"",
        "import:fastapi.Amendment.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    amendment_summaries = []\n    \n    for amendment in amendments:\n        # Get mover information\n        mover_name = None\n        mover_party = None\n\n        if amendment.mover_member_id:\n            mover_member = db.query(Member).filter(\n                Member.id == amendment.mover_member_id\n            ).first()\n\n            if mover_member:\n                mover_name = f\"{mover_member.politician.name_given} {mover_member.politician.name_family}\"\n\n                # Get party info\n                party = db.query(Party).filter(Party.id == mover_member.party_id).first()\n                if party:\n                    mover_party = party.name_en\n        elif amendment.mover_politician_id:\n            mover_politician = db.query(Politician).filter(\n                Politician.id == amendment.mover_politician_id\n            ).first()\n\n            if mover_politician:\n                mover_name = f\"{mover_politician.name_given} {mover_politician.name_family}\"\n\n        amendment_summaries.append(AmendmentSummary(\n            id=amendment.id",
        "import:fastapi.status=bill.status",
        "import:fastapi.\"ROYAL_ASSENT\": \"royal_assent\"",
        "import:fastapi.'Unknown') if str(type(bill.institution)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n\n    # Calculate enhanced status tracking information\n    from datetime import date",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # Timeline events list\n    timeline_events = []\n    \n    # Introduction event (always first)\n    if hasattr(bill",
        "import:fastapi.\"title\": \"Third Reading\"",
        "import:fastapi.'House')}\"",
        "import:fastapi.Member",
        "import:fastapi.\"date\": None",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.status_code).all()\n    \n    # Get bills by session\n    session_counts = db.query(\n        Bill.session_id",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.date) and current_stage_order < 8:\n        remaining_stages = 8 - current_stage_order\n        estimated_days = remaining_stages * 30  # Assume 30 days per stage\n        estimated_completion = introduced_date + datetime.timedelta(days=estimated_days)\n    \n    bill_detail = BillDetail(\n        id=bill_id_str",
        "import:fastapi.BillDetailResponse",
        "import:fastapi.party_name=party_name",
        "import:fastapi.votes=vote_info",
        "import:fastapi.including readings",
        "import:fastapi.\"description\": \"Debate on the general principles of the bill\"\n        }",
        "import:fastapi.'status_code'",
        "import:fastapi.BillDetail",
        "import:fastapi.\"royal_assent\": 8\n    }\n    current_stage_order = stage_order.get(current_stage",
        "import:fastapi.\"LAW\": \"royal_assent\"\n    }\n    \n    current_stage = status_to_stage.get(status",
        "import:fastapi.\"order\": i + 1\n        })\n    \n    # Return timeline response\n    return {\n        \"bill_id\": str(bill_id)",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.\"description\": f\"Bill {bill_number} was introduced in the House of Commons\"",
        "import:fastapi.\"PASSED\": \"senate\"",
        "import:fastapi.\"COMMITTEE\": \"Bill referred to committee for study\"",
        "import:fastapi.\"pending_stages\": len(timeline_events) - 1",
        "import:fastapi.'Unknown') if str(type(bill.short_title_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    status = getattr(bill",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    bill_status_code = getattr(bill",
        "import:fastapi.'legisinfo_id'",
        "import:fastapi.# LEGISinfo integration\n        legisinfo_id=getattr(bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill title suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return BillSuggestionsResponse(suggestions=[])\n\n    # Use trigram similarity for fuzzy matching\n    suggestions_query = text(\"\"\"\n        SELECT id",
        "import:fastapi.bill_id=amendment.bill_id",
        "import:fastapi.keywords=bill.keywords or []",
        "import:fastapi.min_length=1",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.\"REPORT\": \"Committee report presented\"",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    session_id = getattr(bill",
        "import:fastapi.\"SECOND_READING\": \"Bill read for the second time\"",
        "import:fastapi.# Use description_en from database\n            result=vote.result\n        ))\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_id_str = str(bill.id) if hasattr(bill",
        "import:fastapi.\"type\": \"status_change\"",
        "import:fastapi.BillSummaryResponse",
        "import:fastapi.\"description\": vote.description_en",
        "import:fastapi.BillStage\n)\nfrom app.schemas.amendments import (\n    AmendmentSummary",
        "import:fastapi.Party",
        "import:fastapi.title_fr=amendment.title_fr",
        "import:fastapi.BillStatusResponse",
        "import:fastapi.short_title=short_title",
        "import:fastapi.'Unknown')",
        "import:fastapi.le=50",
        "import:fastapi.format: str = Query(\"json\"",
        "import:fastapi.\"summary\": {\n            \"total_events\": len(timeline_events)",
        "import:fastapi.\"stage\": \"first_reading\"",
        "import:fastapi.vote_date=vote.date",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{bill_id}/amendments\"",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.\"THIRD_READING\": \"Bill read for the third time\"",
        "import:fastapi.response_model=BillDetailResponse)\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.committee stages",
        "import:fastapi.'House')",
        "import:fastapi.institution: Optional[str] = Query(None",
        "import:fastapi.\"bill_number\": row.number",
        "import:fastapi.'id') and bill.id is not None else str(bill_id)\n    bill_number = getattr(bill",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.'Unknown') if str(type(bill.name_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    short_title = getattr(bill",
        "import:fastapi.# Not available in this schema\n            session_name=f\"Session {bill.session_id}\"",
        "import:fastapi.\"description\": \"Review of committee amendments\"\n        }",
        "import:fastapi.bills.name) @@ plainto_tsquery('english'",
        "import:fastapi.\"description\": \"Final debate and vote on the bill\"\n        }\n    ]\n    \n    # Add stage events (simplified for demo)\n    for i",
        "import:fastapi.\"progress_percentage\": round((1 / len(timeline_events)) * 100",
        "import:fastapi.date):\n        total_legislative_days = (today - introduced_date).days\n        last_activity_date = introduced_date  # Simplified - would come from actual activity tracking\n    \n    # Estimate completion date\n    estimated_completion = None\n    if isinstance(introduced_date",
        "import:fastapi.'Unknown Bill')",
        "import:fastapi.description=\"Bill status filter\")",
        "import:fastapi.# Not available in this schema\n            party_name=None",
        "import:fastapi.response_model=BillSuggestionsResponse)\nasync def get_bill_suggestions(\n    q: str = Query(...",
        "import:fastapi.{\"query\": q",
        "import:fastapi.library_summary=None",
        "import:fastapi.\"type\": \"introduction\"",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"current_stage\": \"first_reading\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'number'",
        "import:fastapi.\"chamber\": getattr(bill",
        "import:fastapi.response_model=AmendmentListResponse)\nasync def get_bill_amendments(\n    bill_id: int",
        "import:fastapi.\"SECOND_READING\": \"second_reading\"",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.'institution'",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.amendments",
        "import:fastapi.Jurisdiction",
        "import:fastapi.number",
        "import:fastapi.{\n            \"stage\": \"committee_stage\"",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{bill_id}/history\")\nasync def get_bill_history(\n    bill_id: int",
        "import:fastapi.\"THIRD_READING\": \"third_reading\"",
        "import:fastapi.with optional filtering\n    by status",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.status_breakdown={status: count for status",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get vote questions for this bill\n    votes_query = db.query(Vote).filter(Vote.bill_id == bill_id)\n\n    # Get total count for pagination\n    total = votes_query.count()\n\n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = votes_query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    vote_results = []\n    for vote in votes:\n        vote_results.append({\n            \"id\": str(vote.id)",
        "import:fastapi.\"completed_stages\": 1",
        "import:fastapi.name_en\n        LIMIT :limit\n    \"\"\")\n\n    results = db.execute(suggestions_query",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"bill_number\": bill.number\n        })\n\n    return {\n        \"results\": vote_results",
        "import:fastapi.BillSuggestionsResponse",
        "import:fastapi.Query",
        "import:fastapi.# Would come from Library of Parliament API\n        \n        # Bill lifecycle\n        last_activity_date=last_activity_date",
        "import:fastapi.days_in_current_stage=days_in_current_stage",
        "import:fastapi.{\n            \"stage\": \"third_reading\"",
        "import:fastapi.total=total",
        "import:fastapi.\"title\": row.name_en",
        "import:fastapi.\"date\": bill_introduced",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.riding_name=riding_name",
        "import:fastapi.\"first_reading\": 2",
        "import:fastapi.\"pages\": total_pages",
        "import:fastapi.\"status\": \"pending\"",
        "import:fastapi.short_title=bill.title[:100] if bill.title else None",
        "import:fastapi.\"limit\": limit})\n\n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Unknown') if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    introduced_date = getattr(bill",
        "import:fastapi.1)\n    stage_progress = (current_stage_order - 1) / 7.0  # 8 stages total\n    \n    # Determine next stage\n    next_stage = None\n    if current_stage_order < 8:\n        next_stage = list(stage_order.keys())[current_stage_order]\n    \n    # Calculate lifecycle information\n    last_activity_date = None\n    days_in_current_stage = 0\n    total_legislative_days = 0\n    \n    if isinstance(introduced_date",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n\n    return BillSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.{\n            \"stage\": \"second_reading\"",
        "import:fastapi.\"bill_number\": getattr(bill",
        "import:fastapi.1) if timeline_events else 0\n        }",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get voting records for a specific bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by amendment type\")",
        "import:fastapi.response_model=BillSummaryResponse)\nasync def get_bill_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about bills.\n    \"\"\"\n    # Get total bills count\n    total_bills = db.query(Bill).count()\n    \n    # Get bills by status\n    status_counts = db.query(\n        Bill.status_code",
        "import:fastapi.\"description\": stage[\"description\"]",
        "function:get_bill_timeline",
        "import:fastapi.\"event_type\": \"legislative_stage\"",
        "import:fastapi.amendment_type: Optional[str] = Query(None",
        "import:fastapi.create a basic history based on bill data\n    # In a full implementation",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.clause_reference=amendment.clause_reference",
        "import:fastapi.title=title",
        "import:fastapi.None)",
        "import:fastapi.tags=[]  # Not available in this schema\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return BillListResponse(\n        bills=bill_summaries",
        "import:fastapi.pagination=Pagination(\n            page=page",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"bill_title\": getattr(bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific bill.\n    \"\"\"\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.and amendment type.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.reverse=True)\n\n    # Apply pagination\n    total = len(history_items)\n    offset = (page - 1) * page_size\n    paginated_history = history_items[offset:offset + page_size]\n\n    return {\n        \"results\": paginated_history",
        "import:fastapi.description=\"Filter by institution (House/Senate)\")",
        "import:fastapi.\"committee_stage\": 4",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get legislative history for a specific bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    \n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.and votes.\n    \n    This endpoint implements the timeline functionality required by\n    checklist item 150.2.\n    \"\"\"\n    \n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.next_stage=next_stage",
        "import:fastapi.pagination={\n            \"page\": page",
        "import:fastapi.\"title\": \"Report Stage\"",
        "import:fastapi.\"COMMITTEE\": \"committee_stage\"",
        "import:fastapi.\"senate\": 7",
        "import:fastapi.institution",
        "import:fastapi.'introduced') and bill.introduced:\n        timeline_events.append({\n            \"id\": f\"{bill_id}_introduced\"",
        "import:fastapi.\"event_type\": \"introduction\"",
        "import:fastapi.description=\"Filter by amendment status\")",
        "import:fastapi.\"title\": \"Committee Study\"",
        "import:fastapi.# Would be populated from actual legislative history\n            \"title\": stage[\"title\"]",
        "import:fastapi.stage_progress=stage_progress",
        "import:fastapi.session_breakdown={session: count for session",
        "import:fastapi.\"PASSED\": \"Bill passed by the House of Commons\"",
        "import:fastapi.\"WITHDRAWN\": \"Bill withdrawn\"\n        }\n\n        status_desc = status_descriptions.get(bill_status_code",
        "import:fastapi.\"related_document\": None\n        })\n\n    # Add status changes (simplified)\n    if bill_status_code:\n        status_descriptions = {\n            \"INTRODUCED\": \"Bill introduced and read for the first time\"",
        "import:fastapi.{\n            \"stage\": \"report_stage\"",
        "import:fastapi.\"status\": \"completed\"",
        "import:fastapi.introduced_date=introduced_date",
        "import:fastapi.estimated_completion=estimated_completion",
        "import:fastapi.\"title\": \"Bill Introduced\"",
        "import:fastapi.Vote",
        "import:fastapi.detail=\"Bill not found\")\n\n    # For now",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Build query for amendments\n    query = db.query(Amendment).filter(Amendment.bill_id == bill_id)\n\n    # Apply filters\n    if status:\n        query = query.filter(Amendment.status == status)\n\n    if institution:\n        query = query.filter(Amendment.institution.ilike(f\"%{institution}%\"))\n\n    if amendment_type:\n        query = query.filter(Amendment.amendment_type == amendment_type)\n\n        # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination and ordering\n    offset = (page - 1) * page_size\n    amendments = query.order_by(Amendment.proposed_date.desc()",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    )\n\n\n@router.get(\"/{bill_id}/timeline\")\nasync def get_bill_timeline(\n    bill_id: int",
        "import:fastapi.description_fr=amendment.description_fr",
        "import:fastapi.\"description\": f\"Bill introduced in the {getattr(bill",
        "import:fastapi.\"FIRST_READING\": \"Bill read for the first time\"",
        "import:fastapi.pages=total_pages\n        )\n    )\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.\"report_stage\": 5",
        "import:fastapi.mover_party=mover_party\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return AmendmentListResponse(\n        amendments=amendment_summaries",
        "import:fastapi.'short_title_en'",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.'44-1')\")",
        "import:fastapi.title_en=amendment.title_en",
        "import:fastapi.\"description\": \"Bill read for the first time and ordered printed\"\n        }",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.\"location\": \"House of Commons\"",
        "import:fastapi.AmendmentListResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.number=amendment.number",
        "import:fastapi.similarity(name_en",
        "import:fastapi.Pagination",
        "import:fastapi.\"description\": \"Detailed examination by parliamentary committee\"\n        }",
        "import:fastapi.sponsor_name=sponsor_name",
        "import:fastapi.\"title\": \"First Reading\"",
        "import:fastapi.APIRouter",
        "import:fastapi.this would come from a separate history table\n    history_items = []\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_introduced = getattr(bill",
        "import:fastapi.\"description\": status_desc",
        "import:fastapi.\"last_updated\": \"2024-01-01T00:00:00Z\"\n    }",
        "import:fastapi.BillListResponse",
        "import:fastapi.\"related_document\": None\n        })\n\n    # Sort by date (most recent first)\n    history_items.sort(key=lambda x: x[\"date\"] or \"1900-01-01\"",
        "import:fastapi.:query) as sim\n        FROM bills_bill\n        WHERE name_en % :query\n        ORDER BY sim DESC",
        "import:fastapi.\"pagination\": {\n            \"page\": page",
        "import:fastapi.sponsor_name=None"
      ]
    },
    "GET:/{bill_id}/amendments": {
      "method": "GET",
      "path": "/{bill_id}/amendments",
      "file": "services/api-gateway/app/api/v1/bills.py",
      "line": 442,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    bill_number = getattr(bill",
        "import:fastapi.\"third_reading\": 6",
        "import:fastapi.BillStatus",
        "import:fastapi.title=bill.title",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.session_id).all()\n\n    return BillSummaryResponse(\n        total_bills=total_bills",
        "import:fastapi.\"title\": f\"Status: {bill_status_code}\"",
        "import:fastapi.None) if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else None\n\n    # Add introduction\n    if bill_introduced:\n        history_items.append({\n            \"id\": f\"intro-{bill_id}\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'Unknown') if str(type(bill.session_id)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    institution = getattr(bill",
        "import:fastapi.\"bill_id\": str(vote.bill_id)",
        "import:fastapi.\"DEFEATED\": \"Bill defeated\"",
        "import:fastapi.# Use title as short title\n            summary=bill.summary",
        "import:fastapi.'session_id'",
        "import:fastapi.institution=institution",
        "import:fastapi.total_legislative_days=total_legislative_days\n    )\n\n    return BillDetailResponse(bill=bill_detail)\n\n\n@router.get(\"/{bill_id}/votes\")\nasync def get_bill_votes(\n    bill_id: int",
        "import:fastapi.description=vote.description_en",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.ge=1",
        "import:fastapi.bill_number=bill_number",
        "import:fastapi.VoteInfo",
        "import:fastapi.count in status_counts}",
        "import:fastapi.datetime\n    \n    today = date.today()\n    \n    # Determine current stage based on bill status\n    status_to_stage = {\n        \"INTRODUCED\": \"introduction\"",
        "import:fastapi.\"second_reading\": 3",
        "import:fastapi.# Not available in this schema\n        status=status",
        "import:fastapi.session_id=session_id",
        "import:fastapi.'introduced'",
        "import:fastapi.\"date\": bill_introduced or \"Unknown\"",
        "import:fastapi.description=\"Search query for bill suggestions\")",
        "import:fastapi.'name_en'",
        "import:fastapi.le=100",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n\n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    bills = query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    bill_summaries = []\n    \n    for bill in bills:\n        bill_summaries.append(BillSummary(\n            id=str(bill.id)",
        "import:fastapi.\"vote_date\": vote.date",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    title = getattr(bill",
        "import:fastapi.\"REPORT\": \"report_stage\"",
        "import:fastapi.f\"Status changed to {bill_status_code}\")\n        history_items.append({\n            \"id\": f\"status-{bill_id}\"",
        "import:fastapi.\"introduction\")\n    \n    # Calculate stage progress (simplified)\n    stage_order = {\n        \"introduction\": 1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List bills with optional filtering and search.\n\n    Supports:\n    - Full-text search on title\n    - Filtering by session\n    - Filtering by status\n    - Pagination\n    \"\"\"\n\n    # Build base query\n    query = db.query(Bill)\n\n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n\n    if status:\n        query = query.filter(Bill.status == status)\n\n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on name\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.# Use description_en from database\n            \"result\": vote.result",
        "import:fastapi.name_en",
        "import:fastapi.count in session_counts}\n    )\n\n\n@router.get(\"/{bill_id}\"",
        "import:fastapi.summary=None",
        "import:fastapi.Session\nfrom app.schemas.bills import (\n    BillSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get sponsor info\n    sponsor_name = None\n    party_name = None\n    riding_name = None\n\n    if bill.sponsor_member_id:\n        sponsor_member = db.query(Member).filter(\n            Member.id == bill.sponsor_member_id\n        ).first()\n\n        if sponsor_member:\n            sponsor_name = f\"{sponsor_member.politician.name_given} {sponsor_member.politician.name_family}\"\n\n            # Get party info\n            party = db.query(Party).filter(Party.id == sponsor_member.party_id).first()\n            if party:\n                party_name = party.name_en\n\n            # Get riding info\n            riding = db.query(Riding).filter(Riding.id == sponsor_member.riding_id).first()\n            if riding:\n                riding_name = riding.name_en\n\n    # Get vote information\n    votes = db.query(Vote).filter(Vote.bill_id == bill_id).all()\n    \n    vote_info = []\n\n    for vote in votes:\n        vote_info.append(VoteInfo(\n            vote_id=str(vote.id)",
        "import:fastapi.# Enhanced status tracking\n        current_stage=current_stage",
        "import:fastapi.\"FIRST_READING\": \"first_reading\"",
        "import:fastapi.status=bill.status",
        "import:fastapi.\"ROYAL_ASSENT\": \"royal_assent\"",
        "import:fastapi.'Unknown') if str(type(bill.institution)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n\n    # Calculate enhanced status tracking information\n    from datetime import date",
        "import:fastapi.Member",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.status_code).all()\n    \n    # Get bills by session\n    session_counts = db.query(\n        Bill.session_id",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.date) and current_stage_order < 8:\n        remaining_stages = 8 - current_stage_order\n        estimated_days = remaining_stages * 30  # Assume 30 days per stage\n        estimated_completion = introduced_date + datetime.timedelta(days=estimated_days)\n    \n    bill_detail = BillDetail(\n        id=bill_id_str",
        "import:fastapi.BillDetailResponse",
        "import:fastapi.party_name=party_name",
        "import:fastapi.votes=vote_info",
        "import:fastapi.'status_code'",
        "import:fastapi.BillDetail",
        "import:fastapi.\"royal_assent\": 8\n    }\n    current_stage_order = stage_order.get(current_stage",
        "import:fastapi.\"LAW\": \"royal_assent\"\n    }\n    \n    current_stage = status_to_stage.get(status",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.\"description\": f\"Bill {bill_number} was introduced in the House of Commons\"",
        "import:fastapi.\"PASSED\": \"senate\"",
        "import:fastapi.\"COMMITTEE\": \"Bill referred to committee for study\"",
        "import:fastapi.'Unknown') if str(type(bill.short_title_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    status = getattr(bill",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    bill_status_code = getattr(bill",
        "import:fastapi.'legisinfo_id'",
        "import:fastapi.# LEGISinfo integration\n        legisinfo_id=getattr(bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill title suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return BillSuggestionsResponse(suggestions=[])\n\n    # Use trigram similarity for fuzzy matching\n    suggestions_query = text(\"\"\"\n        SELECT id",
        "import:fastapi.keywords=bill.keywords or []",
        "import:fastapi.min_length=1",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }",
        "import:fastapi.\"REPORT\": \"Committee report presented\"",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    session_id = getattr(bill",
        "import:fastapi.\"SECOND_READING\": \"Bill read for the second time\"",
        "import:fastapi.# Use description_en from database\n            result=vote.result\n        ))\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_id_str = str(bill.id) if hasattr(bill",
        "import:fastapi.\"type\": \"status_change\"",
        "import:fastapi.BillSummaryResponse",
        "import:fastapi.\"description\": vote.description_en",
        "import:fastapi.BillStage\n)\nfrom app.schemas.amendments import (\n    AmendmentSummary",
        "import:fastapi.Party",
        "import:fastapi.BillStatusResponse",
        "import:fastapi.short_title=short_title",
        "import:fastapi.le=50",
        "import:fastapi.vote_date=vote.date",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.\"THIRD_READING\": \"Bill read for the third time\"",
        "import:fastapi.response_model=BillDetailResponse)\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.\"bill_number\": row.number",
        "import:fastapi.'id') and bill.id is not None else str(bill_id)\n    bill_number = getattr(bill",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.'Unknown') if str(type(bill.name_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    short_title = getattr(bill",
        "import:fastapi.# Not available in this schema\n            session_name=f\"Session {bill.session_id}\"",
        "import:fastapi.bills.name) @@ plainto_tsquery('english'",
        "import:fastapi.date):\n        total_legislative_days = (today - introduced_date).days\n        last_activity_date = introduced_date  # Simplified - would come from actual activity tracking\n    \n    # Estimate completion date\n    estimated_completion = None\n    if isinstance(introduced_date",
        "import:fastapi.description=\"Bill status filter\")",
        "import:fastapi.# Not available in this schema\n            party_name=None",
        "import:fastapi.response_model=BillSuggestionsResponse)\nasync def get_bill_suggestions(\n    q: str = Query(...",
        "import:fastapi.{\"query\": q",
        "import:fastapi.library_summary=None",
        "import:fastapi.\"type\": \"introduction\"",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'number'",
        "import:fastapi.\"SECOND_READING\": \"second_reading\"",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.'institution'",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.Jurisdiction",
        "import:fastapi.number",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{bill_id}/history\")\nasync def get_bill_history(\n    bill_id: int",
        "import:fastapi.\"THIRD_READING\": \"third_reading\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.status_breakdown={status: count for status",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get vote questions for this bill\n    votes_query = db.query(Vote).filter(Vote.bill_id == bill_id)\n\n    # Get total count for pagination\n    total = votes_query.count()\n\n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = votes_query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    vote_results = []\n    for vote in votes:\n        vote_results.append({\n            \"id\": str(vote.id)",
        "import:fastapi.name_en\n        LIMIT :limit\n    \"\"\")\n\n    results = db.execute(suggestions_query",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"bill_number\": bill.number\n        })\n\n    return {\n        \"results\": vote_results",
        "import:fastapi.BillSuggestionsResponse",
        "import:fastapi.Query",
        "import:fastapi.# Would come from Library of Parliament API\n        \n        # Bill lifecycle\n        last_activity_date=last_activity_date",
        "import:fastapi.days_in_current_stage=days_in_current_stage",
        "import:fastapi.total=total",
        "import:fastapi.\"title\": row.name_en",
        "import:fastapi.\"date\": bill_introduced",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.riding_name=riding_name",
        "import:fastapi.\"first_reading\": 2",
        "import:fastapi.short_title=bill.title[:100] if bill.title else None",
        "import:fastapi.\"limit\": limit})\n\n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Unknown') if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    introduced_date = getattr(bill",
        "import:fastapi.1)\n    stage_progress = (current_stage_order - 1) / 7.0  # 8 stages total\n    \n    # Determine next stage\n    next_stage = None\n    if current_stage_order < 8:\n        next_stage = list(stage_order.keys())[current_stage_order]\n    \n    # Calculate lifecycle information\n    last_activity_date = None\n    days_in_current_stage = 0\n    total_legislative_days = 0\n    \n    if isinstance(introduced_date",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n\n    return BillSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get voting records for a specific bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.response_model=BillSummaryResponse)\nasync def get_bill_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about bills.\n    \"\"\"\n    # Get total bills count\n    total_bills = db.query(Bill).count()\n    \n    # Get bills by status\n    status_counts = db.query(\n        Bill.status_code",
        "import:fastapi.create a basic history based on bill data\n    # In a full implementation",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.title=title",
        "import:fastapi.None)",
        "import:fastapi.tags=[]  # Not available in this schema\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return BillListResponse(\n        bills=bill_summaries",
        "import:fastapi.pagination=Pagination(\n            page=page",
        "import:fastapi.\"total\": total",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific bill.\n    \"\"\"\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.reverse=True)\n\n    # Apply pagination\n    total = len(history_items)\n    offset = (page - 1) * page_size\n    paginated_history = history_items[offset:offset + page_size]\n\n    return {\n        \"results\": paginated_history",
        "import:fastapi.\"committee_stage\": 4",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get legislative history for a specific bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    \n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.next_stage=next_stage",
        "function:get_bill_history",
        "import:fastapi.\"COMMITTEE\": \"committee_stage\"",
        "import:fastapi.\"senate\": 7",
        "import:fastapi.stage_progress=stage_progress",
        "import:fastapi.session_breakdown={session: count for session",
        "import:fastapi.\"PASSED\": \"Bill passed by the House of Commons\"",
        "import:fastapi.\"WITHDRAWN\": \"Bill withdrawn\"\n        }\n\n        status_desc = status_descriptions.get(bill_status_code",
        "import:fastapi.\"related_document\": None\n        })\n\n    # Add status changes (simplified)\n    if bill_status_code:\n        status_descriptions = {\n            \"INTRODUCED\": \"Bill introduced and read for the first time\"",
        "import:fastapi.introduced_date=introduced_date",
        "import:fastapi.estimated_completion=estimated_completion",
        "import:fastapi.\"title\": \"Bill Introduced\"",
        "import:fastapi.Vote",
        "import:fastapi.detail=\"Bill not found\")\n\n    # For now",
        "import:fastapi.\"FIRST_READING\": \"Bill read for the first time\"",
        "import:fastapi.pages=total_pages\n        )\n    )\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.\"report_stage\": 5",
        "import:fastapi.'short_title_en'",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.'44-1')\")",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.\"location\": \"House of Commons\"",
        "import:fastapi.AmendmentListResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.similarity(name_en",
        "import:fastapi.Pagination",
        "import:fastapi.sponsor_name=sponsor_name",
        "import:fastapi.APIRouter",
        "import:fastapi.this would come from a separate history table\n    history_items = []\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_introduced = getattr(bill",
        "import:fastapi.\"description\": status_desc",
        "import:fastapi.BillListResponse",
        "import:fastapi.\"related_document\": None\n        })\n\n    # Sort by date (most recent first)\n    history_items.sort(key=lambda x: x[\"date\"] or \"1900-01-01\"",
        "import:fastapi.:query) as sim\n        FROM bills_bill\n        WHERE name_en % :query\n        ORDER BY sim DESC",
        "import:fastapi.\"pagination\": {\n            \"page\": page",
        "import:fastapi.sponsor_name=None"
      ]
    },
    "GET:/{bill_id}/timeline": {
      "method": "GET",
      "path": "/{bill_id}/timeline",
      "file": "services/api-gateway/app/api/v1/bills.py",
      "line": 546,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    bill_number = getattr(bill",
        "import:fastapi.\"third_reading\": 6",
        "import:fastapi.line_number=amendment.line_number",
        "import:fastapi.amendment_type=amendment.amendment_type",
        "import:fastapi.BillStatus",
        "import:fastapi.title=bill.title",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.session_id).all()\n\n    return BillSummaryResponse(\n        total_bills=total_bills",
        "import:fastapi.status=amendment.status",
        "import:fastapi.\"title\": f\"Status: {bill_status_code}\"",
        "function:get_bill_amendments",
        "import:fastapi.None) if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else None\n\n    # Add introduction\n    if bill_introduced:\n        history_items.append({\n            \"id\": f\"intro-{bill_id}\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'Unknown') if str(type(bill.session_id)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    institution = getattr(bill",
        "import:fastapi.\"bill_id\": str(vote.bill_id)",
        "import:fastapi.\"DEFEATED\": \"Bill defeated\"",
        "import:fastapi.# Use title as short title\n            summary=bill.summary",
        "import:fastapi.'session_id'",
        "import:fastapi.institution=institution",
        "import:fastapi.total_legislative_days=total_legislative_days\n    )\n\n    return BillDetailResponse(bill=bill_detail)\n\n\n@router.get(\"/{bill_id}/votes\")\nasync def get_bill_votes(\n    bill_id: int",
        "import:fastapi.mover_name=mover_name",
        "import:fastapi.description=vote.description_en",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.ge=1",
        "import:fastapi.bill_number=bill_number",
        "import:fastapi.VoteInfo",
        "import:fastapi.count in status_counts}",
        "import:fastapi.datetime\n    \n    today = date.today()\n    \n    # Determine current stage based on bill status\n    status_to_stage = {\n        \"INTRODUCED\": \"introduction\"",
        "import:fastapi.\"second_reading\": 3",
        "import:fastapi.# Not available in this schema\n        status=status",
        "import:fastapi.session_id=session_id",
        "import:fastapi.'introduced'",
        "import:fastapi.\"date\": bill_introduced or \"Unknown\"",
        "import:fastapi.description=\"Search query for bill suggestions\")",
        "import:fastapi.'name_en'",
        "import:fastapi.le=100",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n\n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    bills = query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    bill_summaries = []\n    \n    for bill in bills:\n        bill_summaries.append(BillSummary(\n            id=str(bill.id)",
        "import:fastapi.institution=amendment.institution",
        "import:fastapi.stage=amendment.stage",
        "import:fastapi.\"vote_date\": vote.date",
        "import:fastapi.proposed_date=amendment.proposed_date",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    title = getattr(bill",
        "import:fastapi.\"REPORT\": \"report_stage\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get amendments for a specific bill.\n\n    Returns all amendments proposed for the specified bill",
        "import:fastapi.f\"Status changed to {bill_status_code}\")\n        history_items.append({\n            \"id\": f\"status-{bill_id}\"",
        "import:fastapi.\"introduction\")\n    \n    # Calculate stage progress (simplified)\n    stage_order = {\n        \"introduction\": 1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List bills with optional filtering and search.\n\n    Supports:\n    - Full-text search on title\n    - Filtering by session\n    - Filtering by status\n    - Pagination\n    \"\"\"\n\n    # Build base query\n    query = db.query(Bill)\n\n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n\n    if status:\n        query = query.filter(Bill.status == status)\n\n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on name\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.# Use description_en from database\n            \"result\": vote.result",
        "import:fastapi.name_en",
        "import:fastapi.count in session_counts}\n    )\n\n\n@router.get(\"/{bill_id}\"",
        "import:fastapi.summary=None",
        "import:fastapi.Session\nfrom app.schemas.bills import (\n    BillSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get sponsor info\n    sponsor_name = None\n    party_name = None\n    riding_name = None\n\n    if bill.sponsor_member_id:\n        sponsor_member = db.query(Member).filter(\n            Member.id == bill.sponsor_member_id\n        ).first()\n\n        if sponsor_member:\n            sponsor_name = f\"{sponsor_member.politician.name_given} {sponsor_member.politician.name_family}\"\n\n            # Get party info\n            party = db.query(Party).filter(Party.id == sponsor_member.party_id).first()\n            if party:\n                party_name = party.name_en\n\n            # Get riding info\n            riding = db.query(Riding).filter(Riding.id == sponsor_member.riding_id).first()\n            if riding:\n                riding_name = riding.name_en\n\n    # Get vote information\n    votes = db.query(Vote).filter(Vote.bill_id == bill_id).all()\n    \n    vote_info = []\n\n    for vote in votes:\n        vote_info.append(VoteInfo(\n            vote_id=str(vote.id)",
        "import:fastapi.description_en=amendment.description_en",
        "import:fastapi.# Enhanced status tracking\n        current_stage=current_stage",
        "import:fastapi.\"FIRST_READING\": \"first_reading\"",
        "import:fastapi.Amendment.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    amendment_summaries = []\n    \n    for amendment in amendments:\n        # Get mover information\n        mover_name = None\n        mover_party = None\n\n        if amendment.mover_member_id:\n            mover_member = db.query(Member).filter(\n                Member.id == amendment.mover_member_id\n            ).first()\n\n            if mover_member:\n                mover_name = f\"{mover_member.politician.name_given} {mover_member.politician.name_family}\"\n\n                # Get party info\n                party = db.query(Party).filter(Party.id == mover_member.party_id).first()\n                if party:\n                    mover_party = party.name_en\n        elif amendment.mover_politician_id:\n            mover_politician = db.query(Politician).filter(\n                Politician.id == amendment.mover_politician_id\n            ).first()\n\n            if mover_politician:\n                mover_name = f\"{mover_politician.name_given} {mover_politician.name_family}\"\n\n        amendment_summaries.append(AmendmentSummary(\n            id=amendment.id",
        "import:fastapi.status=bill.status",
        "import:fastapi.\"ROYAL_ASSENT\": \"royal_assent\"",
        "import:fastapi.'Unknown') if str(type(bill.institution)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n\n    # Calculate enhanced status tracking information\n    from datetime import date",
        "import:fastapi.Member",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.status_code).all()\n    \n    # Get bills by session\n    session_counts = db.query(\n        Bill.session_id",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.date) and current_stage_order < 8:\n        remaining_stages = 8 - current_stage_order\n        estimated_days = remaining_stages * 30  # Assume 30 days per stage\n        estimated_completion = introduced_date + datetime.timedelta(days=estimated_days)\n    \n    bill_detail = BillDetail(\n        id=bill_id_str",
        "import:fastapi.BillDetailResponse",
        "import:fastapi.party_name=party_name",
        "import:fastapi.votes=vote_info",
        "import:fastapi.'status_code'",
        "import:fastapi.BillDetail",
        "import:fastapi.\"royal_assent\": 8\n    }\n    current_stage_order = stage_order.get(current_stage",
        "import:fastapi.\"LAW\": \"royal_assent\"\n    }\n    \n    current_stage = status_to_stage.get(status",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.\"description\": f\"Bill {bill_number} was introduced in the House of Commons\"",
        "import:fastapi.\"PASSED\": \"senate\"",
        "import:fastapi.\"COMMITTEE\": \"Bill referred to committee for study\"",
        "import:fastapi.'Unknown') if str(type(bill.short_title_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    status = getattr(bill",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    bill_status_code = getattr(bill",
        "import:fastapi.'legisinfo_id'",
        "import:fastapi.# LEGISinfo integration\n        legisinfo_id=getattr(bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill title suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return BillSuggestionsResponse(suggestions=[])\n\n    # Use trigram similarity for fuzzy matching\n    suggestions_query = text(\"\"\"\n        SELECT id",
        "import:fastapi.bill_id=amendment.bill_id",
        "import:fastapi.keywords=bill.keywords or []",
        "import:fastapi.min_length=1",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.\"REPORT\": \"Committee report presented\"",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    session_id = getattr(bill",
        "import:fastapi.\"SECOND_READING\": \"Bill read for the second time\"",
        "import:fastapi.# Use description_en from database\n            result=vote.result\n        ))\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_id_str = str(bill.id) if hasattr(bill",
        "import:fastapi.\"type\": \"status_change\"",
        "import:fastapi.BillSummaryResponse",
        "import:fastapi.\"description\": vote.description_en",
        "import:fastapi.BillStage\n)\nfrom app.schemas.amendments import (\n    AmendmentSummary",
        "import:fastapi.Party",
        "import:fastapi.title_fr=amendment.title_fr",
        "import:fastapi.BillStatusResponse",
        "import:fastapi.short_title=short_title",
        "import:fastapi.le=50",
        "import:fastapi.vote_date=vote.date",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{bill_id}/amendments\"",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.\"THIRD_READING\": \"Bill read for the third time\"",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    )",
        "import:fastapi.response_model=BillDetailResponse)\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.institution: Optional[str] = Query(None",
        "import:fastapi.\"bill_number\": row.number",
        "import:fastapi.'id') and bill.id is not None else str(bill_id)\n    bill_number = getattr(bill",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.'Unknown') if str(type(bill.name_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    short_title = getattr(bill",
        "import:fastapi.# Not available in this schema\n            session_name=f\"Session {bill.session_id}\"",
        "import:fastapi.bills.name) @@ plainto_tsquery('english'",
        "import:fastapi.date):\n        total_legislative_days = (today - introduced_date).days\n        last_activity_date = introduced_date  # Simplified - would come from actual activity tracking\n    \n    # Estimate completion date\n    estimated_completion = None\n    if isinstance(introduced_date",
        "import:fastapi.description=\"Bill status filter\")",
        "import:fastapi.# Not available in this schema\n            party_name=None",
        "import:fastapi.response_model=BillSuggestionsResponse)\nasync def get_bill_suggestions(\n    q: str = Query(...",
        "import:fastapi.{\"query\": q",
        "import:fastapi.library_summary=None",
        "import:fastapi.\"type\": \"introduction\"",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'number'",
        "import:fastapi.response_model=AmendmentListResponse)\nasync def get_bill_amendments(\n    bill_id: int",
        "import:fastapi.\"SECOND_READING\": \"second_reading\"",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.'institution'",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.Jurisdiction",
        "import:fastapi.number",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{bill_id}/history\")\nasync def get_bill_history(\n    bill_id: int",
        "import:fastapi.\"THIRD_READING\": \"third_reading\"",
        "import:fastapi.with optional filtering\n    by status",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.status_breakdown={status: count for status",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get vote questions for this bill\n    votes_query = db.query(Vote).filter(Vote.bill_id == bill_id)\n\n    # Get total count for pagination\n    total = votes_query.count()\n\n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = votes_query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    vote_results = []\n    for vote in votes:\n        vote_results.append({\n            \"id\": str(vote.id)",
        "import:fastapi.name_en\n        LIMIT :limit\n    \"\"\")\n\n    results = db.execute(suggestions_query",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"bill_number\": bill.number\n        })\n\n    return {\n        \"results\": vote_results",
        "import:fastapi.BillSuggestionsResponse",
        "import:fastapi.Query",
        "import:fastapi.# Would come from Library of Parliament API\n        \n        # Bill lifecycle\n        last_activity_date=last_activity_date",
        "import:fastapi.days_in_current_stage=days_in_current_stage",
        "import:fastapi.total=total",
        "import:fastapi.\"title\": row.name_en",
        "import:fastapi.\"date\": bill_introduced",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.riding_name=riding_name",
        "import:fastapi.\"first_reading\": 2",
        "import:fastapi.\"pages\": total_pages",
        "import:fastapi.short_title=bill.title[:100] if bill.title else None",
        "import:fastapi.\"limit\": limit})\n\n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Unknown') if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    introduced_date = getattr(bill",
        "import:fastapi.1)\n    stage_progress = (current_stage_order - 1) / 7.0  # 8 stages total\n    \n    # Determine next stage\n    next_stage = None\n    if current_stage_order < 8:\n        next_stage = list(stage_order.keys())[current_stage_order]\n    \n    # Calculate lifecycle information\n    last_activity_date = None\n    days_in_current_stage = 0\n    total_legislative_days = 0\n    \n    if isinstance(introduced_date",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n\n    return BillSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get voting records for a specific bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by amendment type\")",
        "import:fastapi.response_model=BillSummaryResponse)\nasync def get_bill_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about bills.\n    \"\"\"\n    # Get total bills count\n    total_bills = db.query(Bill).count()\n    \n    # Get bills by status\n    status_counts = db.query(\n        Bill.status_code",
        "import:fastapi.amendment_type: Optional[str] = Query(None",
        "import:fastapi.create a basic history based on bill data\n    # In a full implementation",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.clause_reference=amendment.clause_reference",
        "import:fastapi.title=title",
        "import:fastapi.None)",
        "import:fastapi.tags=[]  # Not available in this schema\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return BillListResponse(\n        bills=bill_summaries",
        "import:fastapi.pagination=Pagination(\n            page=page",
        "import:fastapi.\"total\": total",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific bill.\n    \"\"\"\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.and amendment type.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.reverse=True)\n\n    # Apply pagination\n    total = len(history_items)\n    offset = (page - 1) * page_size\n    paginated_history = history_items[offset:offset + page_size]\n\n    return {\n        \"results\": paginated_history",
        "import:fastapi.description=\"Filter by institution (House/Senate)\")",
        "import:fastapi.\"committee_stage\": 4",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get legislative history for a specific bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    \n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.next_stage=next_stage",
        "import:fastapi.pagination={\n            \"page\": page",
        "import:fastapi.\"COMMITTEE\": \"committee_stage\"",
        "import:fastapi.\"senate\": 7",
        "import:fastapi.institution",
        "import:fastapi.description=\"Filter by amendment status\")",
        "import:fastapi.stage_progress=stage_progress",
        "import:fastapi.session_breakdown={session: count for session",
        "import:fastapi.\"PASSED\": \"Bill passed by the House of Commons\"",
        "import:fastapi.\"WITHDRAWN\": \"Bill withdrawn\"\n        }\n\n        status_desc = status_descriptions.get(bill_status_code",
        "import:fastapi.\"related_document\": None\n        })\n\n    # Add status changes (simplified)\n    if bill_status_code:\n        status_descriptions = {\n            \"INTRODUCED\": \"Bill introduced and read for the first time\"",
        "import:fastapi.introduced_date=introduced_date",
        "import:fastapi.estimated_completion=estimated_completion",
        "import:fastapi.\"title\": \"Bill Introduced\"",
        "import:fastapi.Vote",
        "import:fastapi.detail=\"Bill not found\")\n\n    # For now",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Build query for amendments\n    query = db.query(Amendment).filter(Amendment.bill_id == bill_id)\n\n    # Apply filters\n    if status:\n        query = query.filter(Amendment.status == status)\n\n    if institution:\n        query = query.filter(Amendment.institution.ilike(f\"%{institution}%\"))\n\n    if amendment_type:\n        query = query.filter(Amendment.amendment_type == amendment_type)\n\n        # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination and ordering\n    offset = (page - 1) * page_size\n    amendments = query.order_by(Amendment.proposed_date.desc()",
        "import:fastapi.description_fr=amendment.description_fr",
        "import:fastapi.\"FIRST_READING\": \"Bill read for the first time\"",
        "import:fastapi.pages=total_pages\n        )\n    )\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.\"report_stage\": 5",
        "import:fastapi.mover_party=mover_party\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return AmendmentListResponse(\n        amendments=amendment_summaries",
        "import:fastapi.'short_title_en'",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.'44-1')\")",
        "import:fastapi.title_en=amendment.title_en",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.\"location\": \"House of Commons\"",
        "import:fastapi.AmendmentListResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.number=amendment.number",
        "import:fastapi.similarity(name_en",
        "import:fastapi.Pagination",
        "import:fastapi.sponsor_name=sponsor_name",
        "import:fastapi.APIRouter",
        "import:fastapi.this would come from a separate history table\n    history_items = []\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_introduced = getattr(bill",
        "import:fastapi.\"description\": status_desc",
        "import:fastapi.BillListResponse",
        "import:fastapi.\"related_document\": None\n        })\n\n    # Sort by date (most recent first)\n    history_items.sort(key=lambda x: x[\"date\"] or \"1900-01-01\"",
        "import:fastapi.:query) as sim\n        FROM bills_bill\n        WHERE name_en % :query\n        ORDER BY sim DESC",
        "import:fastapi.\"pagination\": {\n            \"page\": page",
        "import:fastapi.sponsor_name=None"
      ]
    },
    "GET:/{bill_id}/status": {
      "method": "GET",
      "path": "/{bill_id}/status",
      "file": "services/api-gateway/app/api/v1/bills.py",
      "line": 739,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    bill_number = getattr(bill",
        "import:fastapi.\"third_reading\": 6",
        "import:fastapi.line_number=amendment.line_number",
        "import:fastapi.\"timeline\": timeline_events",
        "import:fastapi.amendment_type=amendment.amendment_type",
        "import:fastapi.BillStatus",
        "import:fastapi.\"date\": bill.introduced.isoformat()",
        "import:fastapi.title=bill.title",
        "import:fastapi.'House')\n        })\n    \n    # Add typical parliamentary stages\n    stages = [\n        {\n            \"stage\": \"first_reading\"",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.session_id).all()\n\n    return BillSummaryResponse(\n        total_bills=total_bills",
        "import:fastapi.\"title\": \"Second Reading\"",
        "import:fastapi.status=amendment.status",
        "import:fastapi.\"title\": f\"Status: {bill_status_code}\"",
        "import:fastapi.None) if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else None\n\n    # Add introduction\n    if bill_introduced:\n        history_items.append({\n            \"id\": f\"intro-{bill_id}\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'Unknown') if str(type(bill.session_id)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    institution = getattr(bill",
        "import:fastapi.\"bill_id\": str(vote.bill_id)",
        "import:fastapi.\"DEFEATED\": \"Bill defeated\"",
        "import:fastapi.# Use title as short title\n            summary=bill.summary",
        "import:fastapi.'session_id'",
        "import:fastapi.institution=institution",
        "import:fastapi.total_legislative_days=total_legislative_days\n    )\n\n    return BillDetailResponse(bill=bill_detail)\n\n\n@router.get(\"/{bill_id}/votes\")\nasync def get_bill_votes(\n    bill_id: int",
        "import:fastapi.mover_name=mover_name",
        "import:fastapi.description=vote.description_en",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.description=\"Response format (json/minimal)\")",
        "import:fastapi.ge=1",
        "import:fastapi.bill_number=bill_number",
        "import:fastapi.'Unknown')} introduced in the {getattr(bill",
        "import:fastapi.\"description\": f\"Bill {getattr(bill",
        "import:fastapi.VoteInfo",
        "import:fastapi.count in status_counts}",
        "import:fastapi.datetime\n    \n    today = date.today()\n    \n    # Determine current stage based on bill status\n    status_to_stage = {\n        \"INTRODUCED\": \"introduction\"",
        "import:fastapi.\"second_reading\": 3",
        "import:fastapi.# Not available in this schema\n        status=status",
        "import:fastapi.session_id=session_id",
        "import:fastapi.'introduced'",
        "import:fastapi.\"date\": bill_introduced or \"Unknown\"",
        "import:fastapi.description=\"Search query for bill suggestions\")",
        "import:fastapi.'name_en'",
        "import:fastapi.le=100",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n\n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    bills = query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    bill_summaries = []\n    \n    for bill in bills:\n        bill_summaries.append(BillSummary(\n            id=str(bill.id)",
        "import:fastapi.institution=amendment.institution",
        "import:fastapi.\"stage\": stage[\"stage\"]",
        "import:fastapi.'sponsor_politician_id'",
        "import:fastapi.\"details\": f\"Stage: {stage['stage'].replace('_'",
        "import:fastapi.stage=amendment.stage",
        "import:fastapi.\"vote_date\": vote.date",
        "import:fastapi.proposed_date=amendment.proposed_date",
        "import:fastapi.'introduced') and bill.introduced:\n        history_events.append({\n            \"id\": f\"{bill_id}_introduced\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get the legislative timeline for a specific bill.\n    \n    Returns a chronological sequence of events in the bill's legislative journey",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    title = getattr(bill",
        "import:fastapi.\"REPORT\": \"report_stage\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get amendments for a specific bill.\n\n    Returns all amendments proposed for the specified bill",
        "import:fastapi.f\"Status changed to {bill_status_code}\")\n        history_items.append({\n            \"id\": f\"status-{bill_id}\"",
        "import:fastapi.\"introduction\")\n    \n    # Calculate stage progress (simplified)\n    stage_order = {\n        \"introduction\": 1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List bills with optional filtering and search.\n\n    Supports:\n    - Full-text search on title\n    - Filtering by session\n    - Filtering by status\n    - Pagination\n    \"\"\"\n\n    # Build base query\n    query = db.query(Bill)\n\n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n\n    if status:\n        query = query.filter(Bill.status == status)\n\n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on name\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.# Use description_en from database\n            \"result\": vote.result",
        "import:fastapi.stage in enumerate(stages):\n        timeline_events.append({\n            \"id\": f\"{bill_id}_{stage['stage']}\"",
        "import:fastapi.name_en",
        "import:fastapi.count in session_counts}\n    )\n\n\n@router.get(\"/{bill_id}\"",
        "import:fastapi.summary=None",
        "import:fastapi.Session\nfrom app.schemas.bills import (\n    BillSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get sponsor info\n    sponsor_name = None\n    party_name = None\n    riding_name = None\n\n    if bill.sponsor_member_id:\n        sponsor_member = db.query(Member).filter(\n            Member.id == bill.sponsor_member_id\n        ).first()\n\n        if sponsor_member:\n            sponsor_name = f\"{sponsor_member.politician.name_given} {sponsor_member.politician.name_family}\"\n\n            # Get party info\n            party = db.query(Party).filter(Party.id == sponsor_member.party_id).first()\n            if party:\n                party_name = party.name_en\n\n            # Get riding info\n            riding = db.query(Riding).filter(Riding.id == sponsor_member.riding_id).first()\n            if riding:\n                riding_name = riding.name_en\n\n    # Get vote information\n    votes = db.query(Vote).filter(Vote.bill_id == bill_id).all()\n    \n    vote_info = []\n\n    for vote in votes:\n        vote_info.append(VoteInfo(\n            vote_id=str(vote.id)",
        "import:fastapi.description_en=amendment.description_en",
        "import:fastapi.# Enhanced status tracking\n        current_stage=current_stage",
        "import:fastapi.\"FIRST_READING\": \"first_reading\"",
        "import:fastapi.Amendment.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    amendment_summaries = []\n    \n    for amendment in amendments:\n        # Get mover information\n        mover_name = None\n        mover_party = None\n\n        if amendment.mover_member_id:\n            mover_member = db.query(Member).filter(\n                Member.id == amendment.mover_member_id\n            ).first()\n\n            if mover_member:\n                mover_name = f\"{mover_member.politician.name_given} {mover_member.politician.name_family}\"\n\n                # Get party info\n                party = db.query(Party).filter(Party.id == mover_member.party_id).first()\n                if party:\n                    mover_party = party.name_en\n        elif amendment.mover_politician_id:\n            mover_politician = db.query(Politician).filter(\n                Politician.id == amendment.mover_politician_id\n            ).first()\n\n            if mover_politician:\n                mover_name = f\"{mover_politician.name_given} {mover_politician.name_family}\"\n\n        amendment_summaries.append(AmendmentSummary(\n            id=amendment.id",
        "import:fastapi.status=bill.status",
        "import:fastapi.\"ROYAL_ASSENT\": \"royal_assent\"",
        "import:fastapi.'Unknown') if str(type(bill.institution)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n\n    # Calculate enhanced status tracking information\n    from datetime import date",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # Timeline events list\n    timeline_events = []\n    \n    # Introduction event (always first)\n    if hasattr(bill",
        "import:fastapi.\"title\": \"Third Reading\"",
        "import:fastapi.'House')}\"",
        "import:fastapi.Member",
        "import:fastapi.\"date\": None",
        "import:fastapi.db.func.count(Bill.id)\n    ).group_by(Bill.status_code).all()\n    \n    # Get bills by session\n    session_counts = db.query(\n        Bill.session_id",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.date) and current_stage_order < 8:\n        remaining_stages = 8 - current_stage_order\n        estimated_days = remaining_stages * 30  # Assume 30 days per stage\n        estimated_completion = introduced_date + datetime.timedelta(days=estimated_days)\n    \n    bill_detail = BillDetail(\n        id=bill_id_str",
        "import:fastapi.BillDetailResponse",
        "import:fastapi.party_name=party_name",
        "import:fastapi.votes=vote_info",
        "import:fastapi.including readings",
        "import:fastapi.\"description\": \"Debate on the general principles of the bill\"\n        }",
        "import:fastapi.'status_code'",
        "import:fastapi.BillDetail",
        "import:fastapi.\"royal_assent\": 8\n    }\n    current_stage_order = stage_order.get(current_stage",
        "import:fastapi.' ').title()}\"\n        })\n    \n    # Apply pagination\n    total = len(history_events)\n    offset = (page - 1) * page_size\n    paginated_events = history_events[offset:offset + page_size]\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    return {\n        \"results\": paginated_events",
        "import:fastapi.\"LAW\": \"royal_assent\"\n    }\n    \n    current_stage = status_to_stage.get(status",
        "import:fastapi.\"order\": i + 1\n        })\n    \n    # Return timeline response\n    return {\n        \"bill_id\": str(bill_id)",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.\"description\": f\"Bill {bill_number} was introduced in the House of Commons\"",
        "import:fastapi.\"PASSED\": \"senate\"",
        "import:fastapi.\"COMMITTEE\": \"Bill referred to committee for study\"",
        "import:fastapi.\"pending_stages\": len(timeline_events) - 1",
        "import:fastapi.'Unknown') if str(type(bill.short_title_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    status = getattr(bill",
        "import:fastapi.'Unknown') if str(type(bill.number)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    bill_status_code = getattr(bill",
        "import:fastapi.'legisinfo_id'",
        "import:fastapi.# Would be populated from actual legislative history\n            \"status\": stage[\"status\"]",
        "import:fastapi.# LEGISinfo integration\n        legisinfo_id=getattr(bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill title suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return BillSuggestionsResponse(suggestions=[])\n\n    # Use trigram similarity for fuzzy matching\n    suggestions_query = text(\"\"\"\n        SELECT id",
        "import:fastapi.bill_id=amendment.bill_id",
        "import:fastapi.keywords=bill.keywords or []",
        "import:fastapi.\"status\": \"introduced\"",
        "import:fastapi.min_length=1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get the legislative history for a specific bill.\n    \n    Returns a chronological list of events and status changes\n    in the bill's legislative journey.\n    \n    This endpoint provides the bill history functionality required by\n    the web UI bill detail page.\n    \"\"\"\n    \n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }",
        "import:fastapi.\"REPORT\": \"Committee report presented\"",
        "import:fastapi.None) if str(type(bill.introduced)) != \"<class 'unittest.mock.Mock'>\" else None\n    session_id = getattr(bill",
        "import:fastapi.\"SECOND_READING\": \"Bill read for the second time\"",
        "import:fastapi.# Use description_en from database\n            result=vote.result\n        ))\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_id_str = str(bill.id) if hasattr(bill",
        "import:fastapi.\"type\": \"status_change\"",
        "import:fastapi.BillSummaryResponse",
        "import:fastapi.\"description\": vote.description_en",
        "import:fastapi.BillStage\n)\nfrom app.schemas.amendments import (\n    AmendmentSummary",
        "import:fastapi.Party",
        "import:fastapi.title_fr=amendment.title_fr",
        "import:fastapi.BillStatusResponse",
        "import:fastapi.short_title=short_title",
        "import:fastapi.'Unknown')",
        "import:fastapi.le=50",
        "import:fastapi.format: str = Query(\"json\"",
        "import:fastapi.\"summary\": {\n            \"total_events\": len(timeline_events)",
        "import:fastapi.\"stage\": \"first_reading\"",
        "import:fastapi.\"status\": \"in_progress\"",
        "import:fastapi.vote_date=vote.date",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{bill_id}/amendments\"",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.\"THIRD_READING\": \"Bill read for the third time\"",
        "import:fastapi.response_model=BillDetailResponse)\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.committee stages",
        "import:fastapi.'House')",
        "import:fastapi.institution: Optional[str] = Query(None",
        "import:fastapi.\"bill_number\": row.number",
        "import:fastapi.'id') and bill.id is not None else str(bill_id)\n    bill_number = getattr(bill",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.'Unknown') if str(type(bill.name_en)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    short_title = getattr(bill",
        "import:fastapi.# Not available in this schema\n            session_name=f\"Session {bill.session_id}\"",
        "import:fastapi.\"description\": \"Review of committee amendments\"\n        }",
        "import:fastapi.bills.name) @@ plainto_tsquery('english'",
        "import:fastapi.\"description\": \"Final debate and vote on the bill\"\n        }\n    ]\n    \n    # Add stage events (simplified for demo)\n    for i",
        "import:fastapi.\"progress_percentage\": round((1 / len(timeline_events)) * 100",
        "import:fastapi.date):\n        total_legislative_days = (today - introduced_date).days\n        last_activity_date = introduced_date  # Simplified - would come from actual activity tracking\n    \n    # Estimate completion date\n    estimated_completion = None\n    if isinstance(introduced_date",
        "import:fastapi.'Unknown Bill')",
        "import:fastapi.'Unknown sponsor')}\"\n        })\n    \n    # Add legislative stages (simplified for demo)\n    stages = [\n        {\n            \"stage\": \"first_reading\"",
        "import:fastapi.description=\"Bill status filter\")",
        "import:fastapi.# Not available in this schema\n            party_name=None",
        "import:fastapi.response_model=BillSuggestionsResponse)\nasync def get_bill_suggestions(\n    q: str = Query(...",
        "import:fastapi.{\"query\": q",
        "import:fastapi.library_summary=None",
        "import:fastapi.\"type\": \"introduction\"",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"current_stage\": \"first_reading\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'number'",
        "import:fastapi.\"chamber\": getattr(bill",
        "import:fastapi.response_model=AmendmentListResponse)\nasync def get_bill_amendments(\n    bill_id: int",
        "import:fastapi.\"SECOND_READING\": \"second_reading\"",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.'institution'",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.amendments",
        "import:fastapi.Jurisdiction",
        "import:fastapi.number",
        "import:fastapi.{\n            \"stage\": \"committee_stage\"",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{bill_id}/history\")\nasync def get_bill_history(\n    bill_id: int",
        "import:fastapi.\"THIRD_READING\": \"third_reading\"",
        "import:fastapi.with optional filtering\n    by status",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.status_breakdown={status: count for status",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Get vote questions for this bill\n    votes_query = db.query(Vote).filter(Vote.bill_id == bill_id)\n\n    # Get total count for pagination\n    total = votes_query.count()\n\n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = votes_query.offset(offset).limit(page_size).all()\n\n    # Convert to response format\n    vote_results = []\n    for vote in votes:\n        vote_results.append({\n            \"id\": str(vote.id)",
        "import:fastapi.\"completed_stages\": 1",
        "import:fastapi.name_en\n        LIMIT :limit\n    \"\"\")\n\n    results = db.execute(suggestions_query",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"bill_number\": bill.number\n        })\n\n    return {\n        \"results\": vote_results",
        "import:fastapi.BillSuggestionsResponse",
        "import:fastapi.Query",
        "import:fastapi.\"description\": \"Final debate and vote on the bill\"\n        }\n    ]\n    \n    for stage in stages:\n        history_events.append({\n            \"id\": f\"{bill_id}_{stage['stage']}\"",
        "import:fastapi.# Would come from Library of Parliament API\n        \n        # Bill lifecycle\n        last_activity_date=last_activity_date",
        "import:fastapi.days_in_current_stage=days_in_current_stage",
        "import:fastapi.{\n            \"stage\": \"third_reading\"",
        "import:fastapi.total=total",
        "import:fastapi.\"title\": row.name_en",
        "import:fastapi.\"date\": bill_introduced",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.riding_name=riding_name",
        "import:fastapi.\"first_reading\": 2",
        "import:fastapi.\"pages\": total_pages",
        "import:fastapi.\"status\": \"pending\"",
        "import:fastapi.\"details\": f\"Introduced by {getattr(bill",
        "import:fastapi.short_title=bill.title[:100] if bill.title else None",
        "import:fastapi.\"limit\": limit})\n\n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Unknown') if str(type(bill.status_code)) != \"<class 'unittest.mock.Mock'>\" else 'Unknown'\n    introduced_date = getattr(bill",
        "import:fastapi.1)\n    stage_progress = (current_stage_order - 1) / 7.0  # 8 stages total\n    \n    # Determine next stage\n    next_stage = None\n    if current_stage_order < 8:\n        next_stage = list(stage_order.keys())[current_stage_order]\n    \n    # Calculate lifecycle information\n    last_activity_date = None\n    days_in_current_stage = 0\n    total_legislative_days = 0\n    \n    if isinstance(introduced_date",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n\n    return BillSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.{\n            \"stage\": \"second_reading\"",
        "import:fastapi.\"bill_number\": getattr(bill",
        "import:fastapi.1) if timeline_events else 0\n        }",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get voting records for a specific bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"last_updated\": \"2024-01-01T00:00:00Z\"\n    }\n\n\n@router.get(\"/{bill_id}/history\")\nasync def get_bill_history(\n    bill_id: int",
        "import:fastapi.description=\"Filter by amendment type\")",
        "import:fastapi.response_model=BillSummaryResponse)\nasync def get_bill_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about bills.\n    \"\"\"\n    # Get total bills count\n    total_bills = db.query(Bill).count()\n    \n    # Get bills by status\n    status_counts = db.query(\n        Bill.status_code",
        "import:fastapi.\"description\": stage[\"description\"]",
        "import:fastapi.\"event_type\": \"legislative_stage\"",
        "import:fastapi.amendment_type: Optional[str] = Query(None",
        "import:fastapi.create a basic history based on bill data\n    # In a full implementation",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.clause_reference=amendment.clause_reference",
        "import:fastapi.title=title",
        "import:fastapi.None)",
        "import:fastapi.tags=[]  # Not available in this schema\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return BillListResponse(\n        bills=bill_summaries",
        "import:fastapi.pagination=Pagination(\n            page=page",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"bill_title\": getattr(bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific bill.\n    \"\"\"\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.and amendment type.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.reverse=True)\n\n    # Apply pagination\n    total = len(history_items)\n    offset = (page - 1) * page_size\n    paginated_history = history_items[offset:offset + page_size]\n\n    return {\n        \"results\": paginated_history",
        "import:fastapi.description=\"Filter by institution (House/Senate)\")",
        "import:fastapi.\"committee_stage\": 4",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get legislative history for a specific bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    \n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.and votes.\n    \n    This endpoint implements the timeline functionality required by\n    checklist item 150.2.\n    \"\"\"\n    \n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.next_stage=next_stage",
        "function:get_bill_history",
        "import:fastapi.pagination={\n            \"page\": page",
        "import:fastapi.\"title\": \"Report Stage\"",
        "import:fastapi.\"COMMITTEE\": \"committee_stage\"",
        "import:fastapi.\"senate\": 7",
        "import:fastapi.institution",
        "import:fastapi.'introduced') and bill.introduced:\n        timeline_events.append({\n            \"id\": f\"{bill_id}_introduced\"",
        "import:fastapi.\"event_type\": \"introduction\"",
        "import:fastapi.description=\"Filter by amendment status\")",
        "import:fastapi.\"title\": \"Committee Study\"",
        "import:fastapi.# Would be populated from actual legislative history\n            \"title\": stage[\"title\"]",
        "import:fastapi.stage_progress=stage_progress",
        "import:fastapi.session_breakdown={session: count for session",
        "import:fastapi.\"PASSED\": \"Bill passed by the House of Commons\"",
        "import:fastapi.\"WITHDRAWN\": \"Bill withdrawn\"\n        }\n\n        status_desc = status_descriptions.get(bill_status_code",
        "import:fastapi.\"related_document\": None\n        })\n\n    # Add status changes (simplified)\n    if bill_status_code:\n        status_descriptions = {\n            \"INTRODUCED\": \"Bill introduced and read for the first time\"",
        "import:fastapi.{\n            \"stage\": \"report_stage\"",
        "import:fastapi.\"status\": \"completed\"",
        "import:fastapi.introduced_date=introduced_date",
        "import:fastapi.estimated_completion=estimated_completion",
        "import:fastapi.\"title\": \"Bill Introduced\"",
        "import:fastapi.Vote",
        "import:fastapi.detail=\"Bill not found\")\n\n    # For now",
        "import:fastapi.detail=\"Bill not found\")\n\n    # Build query for amendments\n    query = db.query(Amendment).filter(Amendment.bill_id == bill_id)\n\n    # Apply filters\n    if status:\n        query = query.filter(Amendment.status == status)\n\n    if institution:\n        query = query.filter(Amendment.institution.ilike(f\"%{institution}%\"))\n\n    if amendment_type:\n        query = query.filter(Amendment.amendment_type == amendment_type)\n\n        # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination and ordering\n    offset = (page - 1) * page_size\n    amendments = query.order_by(Amendment.proposed_date.desc()",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    )\n\n\n@router.get(\"/{bill_id}/timeline\")\nasync def get_bill_timeline(\n    bill_id: int",
        "import:fastapi.description_fr=amendment.description_fr",
        "import:fastapi.\"description\": f\"Bill introduced in the {getattr(bill",
        "import:fastapi.\"FIRST_READING\": \"Bill read for the first time\"",
        "import:fastapi.pages=total_pages\n        )\n    )\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.\"report_stage\": 5",
        "import:fastapi.mover_party=mover_party\n        ))\n\n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n\n    return AmendmentListResponse(\n        amendments=amendment_summaries",
        "import:fastapi.'short_title_en'",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.'44-1')\")",
        "import:fastapi.title_en=amendment.title_en",
        "import:fastapi.\"description\": \"Bill read for the first time and ordered printed\"\n        }",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # Build history events list\n    history_events = []\n    \n    # Introduction event\n    if hasattr(bill",
        "import:fastapi.\"location\": \"House of Commons\"",
        "import:fastapi.AmendmentListResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.number=amendment.number",
        "import:fastapi.similarity(name_en",
        "import:fastapi.Pagination",
        "import:fastapi.\"description\": \"Detailed examination by parliamentary committee\"\n        }",
        "import:fastapi.sponsor_name=sponsor_name",
        "import:fastapi.\"title\": \"First Reading\"",
        "import:fastapi.APIRouter",
        "import:fastapi.this would come from a separate history table\n    history_items = []\n\n    # Handle mock results for testing - provide safe defaults for bill attributes\n    bill_introduced = getattr(bill",
        "import:fastapi.\"description\": status_desc",
        "import:fastapi.BillListResponse",
        "import:fastapi.\"related_document\": None\n        })\n\n    # Sort by date (most recent first)\n    history_items.sort(key=lambda x: x[\"date\"] or \"1900-01-01\"",
        "import:fastapi.:query) as sim\n        FROM bills_bill\n        WHERE name_en % :query\n        ORDER BY sim DESC",
        "import:fastapi.\"pagination\": {\n            \"page\": page",
        "import:fastapi.sponsor_name=None"
      ]
    },
    "POST:/bills/{bill_id}/cast-vote": {
      "method": "POST",
      "path": "/bills/{bill_id}/cast-vote",
      "file": "services/api-gateway/app/api/v1/votes.py",
      "line": 498,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.constituency_impact=\"Regional interests\" if not voted_with_party else None\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.yea_votes=yea_votes",
        "import:fastapi.assume full unity\n            \n            party_unity_scores[party_name] = (unity_count / party_total) * 100 if party_total > 0 else 0\n    \n    # Government vs Opposition analysis (simplified)\n    # In Canada",
        "import:fastapi.'Yea']:\n                unity_count = party_yea\n            elif party_position in ['N'",
        "import:fastapi.party_dissents=party_dissents",
        "import:fastapi.party_unity_scores=party_unity_scores",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.government_support=government_support",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.parties_yea=parties_y",
        "import:fastapi.vote_number = vote.split('/'",
        "import:fastapi.parties_nay=parties_n\n    )\n    \n    return VoteDetailResponse(vote=vote_detail)\n\n\n@router.get(\"/ballots/\"",
        "import:fastapi.description=\"Politician filter\")",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db.func.count(Vote.id)\n    ).group_by(Vote.result).all()\n    \n    # Get votes by session\n    session_counts = db.query(\n        Bill.session_id",
        "import:fastapi.description=\"Vote filter (e.g.",
        "import:fastapi.'total': 0}\n        \n        regional_breakdown[province]['total'] += 1\n        if mv.vote in ['Yea'",
        "import:fastapi.'nay': 0",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.Vote.number == vote_number\n    ).first()\n    \n    if not vote:\n        raise HTTPException(status_code=404",
        "import:fastapi.constituency=member.riding.name_en if member.riding else \"Unknown\"",
        "import:fastapi.'Nay']:\n                unity_count = party_nay\n            else:\n                unity_count = party_total  # If no official position",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.'Y']])\n    nay_votes = len([v for v in member_votes if v.vote in ['Nay'",
        "import:fastapi.Conservative = Official Opposition\n    government_parties = ['Liberal']\n    government_votes = sum([party_breakdown.get(party",
        "import:fastapi.le=100",
        "import:fastapi.\"45-1/34\")\n        if '/' in vote:\n            session_id",
        "import:fastapi.# Would come from actual whip data\n            dissent_reason=\"Policy disagreement\" if not voted_with_party else None",
        "import:fastapi.votes_cast=votes_cast",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'N']:\n            regional_breakdown[province]['nay'] += 1\n    \n    # Create comprehensive analysis\n    analysis = VoteAnalysis(\n        vote_id=str(vote.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.'total': party_total",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.voted_with_government=voted_with_government",
        "import:fastapi.'Unknown')\n        \n        # Determine if MP voted with party\n        voted_with_party = True\n        if party_position in ['Y'",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.# Enhanced MP position analysis\n            party_position=party_position",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get individual vote ballots (how each MP voted).\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Member).join(Vote).join(Bill)\n    \n    # Apply filters\n    if vote:\n        # Parse vote filter (e.g.",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.absent_votes=absent_votes",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.party_name=ballot.member.party.name_en",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.party_breakdown=party_breakdown",
        "import:fastapi.number=vote.number",
        "import:fastapi.HTTPException",
        "import:fastapi.'Y']:\n            voted_with_party = False\n        elif party_position in ['N'",
        "import:fastapi.0) for party in opposition_parties])\n    opposition_yea = sum([party_breakdown.get(party",
        "import:fastapi.'Yea'] and mv.vote not in ['Yea'",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.'Y']:\n            regional_breakdown[province]['yea'] += 1\n        elif mv.vote in ['Nay'",
        "import:fastapi.vote_choice=mv.vote",
        "import:fastapi.date=vote.date",
        "import:fastapi.party_name=party_name",
        "import:fastapi.total_members=total_members",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteBallotsResponse(\n        ballots=ballot_list",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{session_id}/{vote_number}\"",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.response_model=VoteDetailResponse)\nasync def get_vote_detail(\n    session_id: str",
        "import:fastapi.member_name=f\"{member.politician.name_given} {member.politician.name_family}\"",
        "import:fastapi.{}).get('yea'",
        "import:fastapi.'N']])\n            \n            party_breakdown[party_name] = {\n                'yea': party_yea",
        "import:fastapi.'N']\n        \n        ballot_list.append(VoteBallot(\n            ballot_id=str(ballot.id)",
        "import:fastapi.1)\n            query = query.filter(\n                Bill.session_id == session_id",
        "import:fastapi.\"bill_title\": vote.bill.name_en",
        "import:fastapi.Party.party_id == ballot.member.party_id\n        ).first()\n        \n        party_position = party_vote.vote if party_vote else \"Unknown\"\n        \n        # Determine if MP voted with party\n        voted_with_party = True\n        if party_position in ['Y'",
        "import:fastapi.'N']\n        \n        mp_position = MPVotePosition(\n            member_id=str(member.id)",
        "import:fastapi.'Y'] if government_position == 'Yea' else ballot.vote in ['Nay'",
        "import:fastapi.voted_with_party=voted_with_party",
        "import:fastapi.paired_votes=paired_votes",
        "import:fastapi.VoteListResponse",
        "import:fastapi.0) for party in government_parties])\n    government_support = (government_yea / government_votes * 100) if government_votes > 0 else 0\n    \n    opposition_parties = ['Conservative'",
        "import:fastapi.'45-1')\")",
        "import:fastapi.'N']:\n            voted_with_party = False\n        \n        # Determine government position (simplified)\n        vote_question = db.query(Vote).filter(Vote.id == ballot.votequestion_id).first()\n        government_position = 'Yea' if vote_question and vote_question.result in ['Y'",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.bill_title=vote.bill.name_en",
        "import:fastapi.count in result_counts}",
        "import:fastapi.constituency=ballot.member.riding.name_en",
        "import:fastapi.description=\"Vote choice filter (Yea",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.'official_position': party_position\n            }\n            \n            # Calculate party unity (percentage who voted with official position)\n            if party_position in ['Y'",
        "import:fastapi.VoteDetail",
        "import:fastapi.vote_choice=ballot.vote",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.ballot: Optional[str] = Query(None",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.Vote.number == int(vote_number)\n            )\n    \n    if politician:\n        query = query.join(Member.politician).filter(\n            Member.politician.name.contains(politician)\n        )\n    \n    if ballot:\n        query = query.filter(Member.vote == ballot)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    ballots = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    ballot_list = []\n    for ballot in ballots:\n        # Get party position (simplified - in real implementation would come from PartyVote)\n        party_vote = db.query(Party).filter(\n            Party.votequestion_id == ballot.votequestion_id",
        "import:fastapi.typically Liberal = Government",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.politician: Optional[str] = Query(None",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.response_model=VoteBallotsResponse)\nasync def get_vote_ballots(\n    vote: Optional[str] = Query(None",
        "import:fastapi.0) for party in government_parties])\n    government_yea = sum([party_breakdown.get(party",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.whip_status=\"unknown\"",
        "import:fastapi.'Passed'] else 'Nay'\n        voted_with_government = ballot.vote in ['Yea'",
        "import:fastapi.0) for party in opposition_parties])\n    opposition_support = (opposition_yea / opposition_votes * 100) if opposition_votes > 0 else 0\n    \n    # Find party dissents (MPs who voted against their party position)\n    party_dissents = []\n    cross_party_supporters = []\n    \n    for mv in member_votes:\n        member = mv.member\n        party_name = member.party.name_en\n        party_position = party_breakdown.get(party_name",
        "import:fastapi.'45-1/34')\")",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.vote_number: int",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific vote.\n    \"\"\"\n    \n    vote = db.query(Vote).join(Bill).filter(\n        Bill.session_id == session_id",
        "import:fastapi.party_position=party_position",
        "import:fastapi.party unity",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.etc.)\")",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Nay",
        "import:fastapi.government_position=government_position",
        "import:fastapi.Query",
        "import:fastapi.'N']])\n    absent_votes = total_members - votes_cast\n    paired_votes = vote.paired_total if hasattr(vote",
        "import:fastapi.'NDP'",
        "import:fastapi.total=total",
        "import:fastapi.response_model=VoteAnalysisResponse)\nasync def get_vote_comprehensive_analysis(\n    session_id: str",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.'Nay'] and ballot.vote not in ['Nay'",
        "import:fastapi.'nay': party_nay",
        "import:fastapi.count in session_counts}",
        "import:fastapi.'Bloc Qu\u00e9b\u00e9cois']\n    opposition_votes = sum([party_breakdown.get(party",
        "import:fastapi.detail=\"Vote not found\")\n    \n    # Get bill info\n    bill_info = {\n        \"bill_number\": vote.bill.number",
        "import:fastapi.'N']:\n            voted_with_party = False\n        \n        # Determine government position (simplified)\n        government_position = 'Yea' if vote.result in ['Y'",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get comprehensive analysis of a specific vote.\n    \n    Implements Feature F004: Complete Voting Records with MP Positions\n    Provides detailed analysis of MP positions",
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.and dissent patterns.\n    \"\"\"\n    # Find the vote\n    vote = db.query(Vote).join(Bill).filter(\n        Bill.session_id == session_id",
        "import:fastapi.nay_votes=nay_votes",
        "import:fastapi.latest_vote_date=latest_vote.date if latest_vote else None\n    )\n\n\n@router.get(\"/{session_id}/{vote_number}/analysis\"",
        "import:fastapi.result_breakdown={result: count for result",
        "import:fastapi.'Passed'] else 'Nay'\n        voted_with_government = mv.vote in ['Yea'",
        "import:fastapi.VoteBallot",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.'paired_total') else 0\n    \n    # Party breakdown analysis\n    party_breakdown = {}\n    party_unity_scores = {}\n    \n    for party_vote in party_votes:\n        party_name = party_vote.party.name_en\n        party_position = party_vote.vote\n        \n        # Count how party members actually voted\n        party_member_votes = [mv for mv in member_votes if mv.member.party.name_en == party_name]\n        party_total = len(party_member_votes)\n        \n        if party_total > 0:\n            party_yea = len([v for v in party_member_votes if v.vote in ['Yea'",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.Member.vote == 'Nay'\n    ).count()\n    \n    # Get party votes\n    party_votes = db.query(Party).filter(\n        Party.votequestion_id == vote.id\n    ).all()\n    \n    parties_y = [pv.party.name_en for pv in party_votes if pv.vote == 'Y']\n    parties_n = [pv.party.name_en for pv in party_votes if pv.vote == 'N']\n    \n    vote_detail = VoteDetail(\n        vote_id=str(vote.id)",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.'Nay'] and mv.vote not in ['Nay'",
        "import:fastapi.session_breakdown={session: count for session",
        "import:fastapi.opposition_support=opposition_support",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.regional_breakdown=regional_breakdown\n    )\n    \n    return VoteAnalysisResponse(analysis=analysis)",
        "import:fastapi.VoteAnalysisResponse",
        "function:get_vote_comprehensive_analysis",
        "import:fastapi.\"session\": vote.bill.session_id\n    }\n    \n    # Get vote totals\n    yea_total = db.query(Member).filter(\n        Member.votequestion_id == vote.id",
        "import:fastapi.'Y']])\n            party_nay = len([v for v in party_member_votes if v.vote in ['Nay'",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.'Yea'] and ballot.vote not in ['Yea'",
        "import:fastapi.MPVotePosition",
        "import:fastapi.cross_party_supporters=cross_party_supporters",
        "import:fastapi.detail=\"Vote not found\")\n    \n    # Get all MP votes for this question\n    member_votes = db.query(Member).filter(\n        Member.votequestion_id == vote.id\n    ).all()\n    \n    # Get party votes\n    party_votes = db.query(Party).filter(\n        Party.votequestion_id == vote.id\n    ).all()\n    \n    # Calculate basic statistics\n    total_members = 338  # Total seats in House of Commons\n    votes_cast = len(member_votes)\n    yea_votes = len([v for v in member_votes if v.vote in ['Yea'",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.vote_id=str(ballot.votequestion_id)",
        "import:fastapi.'Y'] if government_position == 'Yea' else mv.vote in ['Nay'",
        "import:fastapi.Member.vote == 'Yea'\n    ).count()\n    \n    nay_total = db.query(Member).filter(\n        Member.votequestion_id == vote.id",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.result=vote.result",
        "import:fastapi.member_name=f\"{ballot.member.politician.name_given} {ballot.member.politician.name_family}\"",
        "import:fastapi.response_model=VoteSummaryResponse)\nasync def get_vote_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about votes.\n    \"\"\"\n    \n    # Get total votes count\n    total_votes = db.query(Vote).count()\n    \n    # Get votes by result\n    result_counts = db.query(\n        Vote.result",
        "import:fastapi.{}).get('official_position'",
        "import:fastapi.APIRouter",
        "import:fastapi.db.func.count(Vote.id)\n    ).join(Vote).group_by(Bill.session_id).all()\n    \n    # Get most recent vote\n    latest_vote = db.query(Vote).order_by(Vote.date.desc()).first()\n    \n    return VoteSummaryResponse(\n        total_votes=total_votes",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.{}).get('total'",
        "import:fastapi.# Would be determined from actual whip data\n            dissent_impact=\"Low\" if not voted_with_party else None\n        )\n        \n        if not voted_with_party:\n            party_dissents.append(mp_position)\n        \n        # Cross-party support (opposition members supporting government position)\n        if party_name in opposition_parties and voted_with_government:\n            cross_party_supporters.append(mp_position)\n    \n    # Regional breakdown (simplified by province)\n    regional_breakdown = {}\n    for mv in member_votes:\n        province = mv.member.riding.province if mv.member.riding else \"Unknown\"\n        if province not in regional_breakdown:\n            regional_breakdown[province] = {'yea': 0"
      ]
    },
    "GET:/bills/{bill_id}/user-votes": {
      "method": "GET",
      "path": "/bills/{bill_id}/user-votes",
      "file": "services/api-gateway/app/api/v1/bill_voting.py",
      "line": 93,
      "dependencies": [
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate vote choice\n    valid_choices = [\"yes\"",
        "import:fastapi.\"user_id\": vote_data[\"user_id\"]",
        "import:fastapi.\"vote_choice\": vote_data[\"vote_choice\"].lower()",
        "import:fastapi.\"public_visibility\": vote_data.get(\"public_visibility\"",
        "import:fastapi.\"vote_weight\": vote_data.get(\"vote_weight\"",
        "function:cast_bill_vote",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Cast a vote on a specific bill.\n    Users can vote Yes",
        "import:fastapi.\"medium\")",
        "import:fastapi.\"vote_date\": datetime.utcnow().isoformat()",
        "import:fastapi.1.0)",
        "import:fastapi.timedelta\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"message\": \"Vote cast successfully\"",
        "import:fastapi.create mock vote response\n    # In a full implementation",
        "import:fastapi.\"status\": bill.status_code\n        }\n    }",
        "import:fastapi.we'll assume all bills are open for voting\n    # In a real implementation",
        "import:fastapi.\"bill_id\": str(bill_id)",
        "import:fastapi.\"no\"",
        "import:fastapi.\"constituency\": vote_data.get(\"constituency\")",
        "import:fastapi.or Abstain on bills.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"user_id\"",
        "import:fastapi.\"influence_factors\": vote_data.get(\"influence_factors\"",
        "import:fastapi.this would save to the database\n    vote_record = {\n        \"id\": \"vote-123\"",
        "import:fastapi.\"vote_record\": vote_record",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.this would check bill status and voting windows\n    \n    # Check if user has already voted on this bill\n    # For now",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.Politician",
        "import:fastapi.vote_data: Dict[str",
        "import:fastapi.\"bill_info\": {\n            \"id\": str(bill.id)",
        "import:fastapi.\"abstain\"]\n    if vote_data[\"vote_choice\"].lower() not in valid_choices:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.\"reason\"]\n    for field in required_fields:\n        if field not in vote_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.we'll allow multiple votes (in real implementation",
        "import:fastapi.\"vote_choice\"",
        "import:fastapi.\"location\": vote_data.get(\"location\")",
        "import:fastapi.\"session_id\": vote_data.get(\"session_id\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.detail=f\"Invalid vote choice. Must be one of: {'",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"public\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # Check if bill is currently open for voting\n    # For now",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/bills/{bill_id}/cast-vote\")\nasync def cast_bill_vote(\n    bill_id: int",
        "import:fastapi.\"party_preference\": vote_data.get(\"party_preference\")",
        "import:fastapi.\"web\")",
        "import:fastapi.Party",
        "import:fastapi.List",
        "import:fastapi.description=\"Vote data\")",
        "import:fastapi.'.join(valid_choices)}\"\n        )\n    \n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"confidence_level\": vote_data.get(\"confidence_level\"",
        "import:fastapi.[])",
        "import:fastapi.\"metadata\": {\n            \"device\": vote_data.get(\"device\"",
        "import:fastapi.No",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.this would be restricted)\n    \n    # For now",
        "import:fastapi.\"reason\": vote_data[\"reason\"]",
        "import:fastapi.\"related_issues\": vote_data.get(\"related_issues\"",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"number\": bill.number"
      ]
    },
    "GET:/user/{user_id}/voting-history": {
      "method": "GET",
      "path": "/user/{user_id}/voting-history",
      "file": "services/api-gateway/app/api/v1/user-voting.py",
      "line": 113,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.vote_weight=vote_data.vote_weight",
        "import:fastapi.response_model=UserVoteResponse)\nasync def cast_bill_vote(\n    bill_id: str = Query(...",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get user votes for a specific bill\"\"\"\n    try:\n        query = db.query(UserVote).filter(UserVote.bill_id == bill_id)\n        \n        if public_only:\n            query = query.filter(UserVote.public_visibility == 'public')\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        votes = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [UserVoteResponse.from_orm(vote) for vote in votes]\n        \n        return UserVoteListResponse(\n            results=results",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Cast a user vote on a bill\"\"\"\n    try:\n        # Check if user already voted on this bill\n        existing_vote = db.query(UserVote).filter(\n            UserVote.user_id == vote_data.user_id",
        "import:fastapi.total_pages=(total_count + page_size - 1) // page_size\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.vote_data: UserVoteCreate = None",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.party_preference=vote_data.party_preference",
        "import:fastapi.constituency=vote_data.constituency",
        "import:fastapi.UserVoteListResponse",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.user_voting import UserVote\nfrom app.schemas.user_voting import UserVoteCreate",
        "import:fastapi.influence_factors=vote_data.influence_factors",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.response_model=UserVoteListResponse)\nasync def get_bill_user_votes(\n    bill_id: str",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.tags=[\"User Voting\"])\n\n@router.post(\"/cast-vote\"",
        "import:fastapi.public_visibility=vote_data.public_visibility",
        "import:fastapi.vote_date=datetime.utcnow()\n        )\n        \n        db.add(new_vote)\n        db.commit()\n        db.refresh(new_vote)\n        \n        return UserVoteResponse.from_orm(new_vote)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.ge=1",
        "import:fastapi.total_count=total_count",
        "import:fastapi.description=\"Bill ID to vote on\")",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.session_id=vote_data.session_id",
        "import:fastapi.Depends",
        "import:fastapi.le=100",
        "import:fastapi.confidence_level=vote_data.confidence_level",
        "import:fastapi.description=\"Show only public votes\")",
        "import:fastapi.UserVote.bill_id == bill_id\n        ).first()\n        \n        if existing_vote:\n            # Update existing vote\n            existing_vote.vote_choice = vote_data.vote_choice\n            existing_vote.reason = vote_data.reason\n            existing_vote.confidence_level = vote_data.confidence_level\n            existing_vote.constituency = vote_data.constituency\n            existing_vote.party_preference = vote_data.party_preference\n            existing_vote.influence_factors = vote_data.influence_factors\n            existing_vote.related_issues = vote_data.related_issues\n            existing_vote.public_visibility = vote_data.public_visibility\n            existing_vote.vote_weight = vote_data.vote_weight\n            existing_vote.device = vote_data.device\n            existing_vote.location = vote_data.location\n            existing_vote.session_id = vote_data.session_id\n            existing_vote.updated_at = datetime.utcnow()\n            \n            db.commit()\n            db.refresh(existing_vote)\n            \n            return UserVoteResponse.from_orm(existing_vote)\n        \n        # Create new vote\n        new_vote = UserVote(\n            user_id=vote_data.user_id",
        "import:fastapi.related_issues=vote_data.related_issues",
        "import:fastapi.page=page",
        "import:fastapi.VoteSummaryResponse\n\nrouter = APIRouter(prefix=\"/user-voting\"",
        "import:fastapi.UserVoteResponse",
        "import:fastapi.detail=f\"Failed to retrieve user votes: {str(e)}\")",
        "import:fastapi.reason=vote_data.reason",
        "function:get_bill_user_votes",
        "import:fastapi.public_only: bool = Query(True",
        "import:fastapi.bill_id=bill_id",
        "import:fastapi.detail=f\"Failed to cast vote: {str(e)}\")\n\n@router.get(\"/bill/{bill_id}/user-votes\"",
        "import:fastapi.location=vote_data.location",
        "import:fastapi.device=vote_data.device",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "import:fastapi.vote_choice=vote_data.vote_choice"
      ]
    },
    "GET:/bills/{bill_id}/voting-summary": {
      "method": "GET",
      "path": "/bills/{bill_id}/voting-summary",
      "file": "services/api-gateway/app/api/v1/bill_voting.py",
      "line": 370,
      "dependencies": [
        "import:fastapi.\"bill_title\": \"Healthcare Accessibility Act\"",
        "import:fastapi.\"bill_id\": \"125\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Cast a vote on a specific bill.\n    Users can vote Yes",
        "import:fastapi.\"influence_factors\": [\"economic_concerns\"",
        "import:fastapi.\"vote_statistics\": vote_stats",
        "import:fastapi.\"message\": \"Vote cast successfully\"",
        "import:fastapi.\"reason\": \"Strongly support environmental protection measures\"",
        "import:fastapi.\"constituency_consensus\": \"medium\"\n        }",
        "import:fastapi.\"constituency\": vote_data.get(\"constituency\")",
        "import:fastapi.\"no\"",
        "import:fastapi.\"influence_factors\": vote_data.get(\"influence_factors\"",
        "import:fastapi.create mock user votes data\n    # In a full implementation",
        "import:fastapi.this would save to the database\n    vote_record = {\n        \"id\": \"vote-123\"",
        "import:fastapi.\"vote_record\": vote_record",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"healthcare\"",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"status\": bill.status_code\n        }\n    }\n\n\n@router.get(\"/bills/{bill_id}/user-votes\")\nasync def get_bill_user_votes(\n    bill_id: int",
        "import:fastapi.\"username\": \"john_doe\"",
        "import:fastapi.Politician",
        "import:fastapi.this would come from the database\n    mock_voting_history = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.create mock voting history data\n    # In a full implementation",
        "import:fastapi.ge=1",
        "import:fastapi.\"bill_info\": {\n            \"id\": str(bill.id)",
        "import:fastapi.description=\"Filter by vote choice\")",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.vote_choice: Optional[str] = Query(None",
        "import:fastapi.\"bill_id\": \"123\"",
        "import:fastapi.\"economic_philosophy\"]",
        "import:fastapi.\"medium_consensus\": len([v for v in filtered_history if v[\"constituency_consensus\"] == \"medium\"])",
        "import:fastapi.\"constituency_alignment\": {\n            \"high_consensus\": len([v for v in filtered_history if v[\"constituency_consensus\"] in [\"high\"",
        "import:fastapi.\"yes_votes\": len([v for v in mock_user_votes if v[\"vote_choice\"] == \"yes\"])",
        "import:fastapi.\"related_issues\": [\"implementation\"",
        "import:fastapi.\"public_visibility\": \"public\"",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.detail=f\"Invalid vote choice. Must be one of: {'",
        "import:fastapi.le=100",
        "import:fastapi.\"party_preference\": vote_data.get(\"party_preference\")",
        "import:fastapi.\"web\")",
        "import:fastapi.\"mp_vote_match\": True",
        "import:fastapi.'.join(valid_choices)}\"\n        )\n    \n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"metadata\": {\n            \"device\": vote_data.get(\"device\"",
        "import:fastapi.[])",
        "import:fastapi.\"constituency_match\": False\n        }\n    ]\n    \n    # Apply user filter if specified\n    if user_id:\n        mock_user_votes = [\n            vote for vote in mock_user_votes\n            if vote[\"user_id\"] == user_id\n        ]\n    \n    # Apply pagination\n    total = len(mock_user_votes)\n    offset = (page - 1) * page_size\n    paginated_votes = mock_user_votes[offset:offset + page_size]\n    \n    # Calculate vote statistics\n    vote_stats = {\n        \"total_votes\": total",
        "import:fastapi.\"reason\": \"Need more information about implementation details\"",
        "import:fastapi.\"user_verified\": False",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }\n    }",
        "import:fastapi.\"reason\": vote_data[\"reason\"]",
        "import:fastapi.\"user_verified\": True",
        "import:fastapi.\"status\": bill.status_code\n        }\n    }\n\n\n@router.get(\"/user/{user_id}/voting-history\")\nasync def get_user_voting_history(\n    user_id: str",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"vote_date\": \"2025-01-15T09:15:00Z\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate vote choice\n    valid_choices = [\"yes\"",
        "import:fastapi.\"results\": paginated_history",
        "import:fastapi.\"party_preference\": \"Conservative\"",
        "import:fastapi.\"vote_weight\": vote_data.get(\"vote_weight\"",
        "import:fastapi.\"constituency\": \"Toronto Centre\"",
        "import:fastapi.\"confidence_level\": \"low\"",
        "import:fastapi.\"vote_choice\": \"abstain\"",
        "import:fastapi.\"medium\": len([v for v in filtered_history if v[\"confidence_level\"] == \"medium\"])",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.\"vote_choice\": vote_choice",
        "import:fastapi.create mock vote response\n    # In a full implementation",
        "import:fastapi.\"vote_weight\": 1.0",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.this would check bill status and voting windows\n    \n    # Check if user has already voted on this bill\n    # For now",
        "import:fastapi.\"constituency_consensus\": \"high\"\n        }",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.\"abstentions\": len([v for v in mock_user_votes if v[\"vote_choice\"] == \"abstain\"])",
        "import:fastapi.\"party_preference\": \"Liberal\"",
        "import:fastapi.\"influence_factors\": [\"healthcare_values\"",
        "import:fastapi.\"reason\": \"Universal healthcare is a fundamental right\"",
        "import:fastapi.\"vote_date\": \"2025-01-15T10:30:00Z\"",
        "import:fastapi.\"vote_choice\"",
        "import:fastapi.\"low_consensus\": len([v for v in filtered_history if v[\"constituency_consensus\"] == \"low\"])\n        }",
        "import:fastapi.\"influence_score\": 8.5\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.Depends",
        "import:fastapi.\"influence_factors\": [\"environmental_concerns\"",
        "import:fastapi.\"influence_factors\": [\"information_gaps\"",
        "import:fastapi.\"related_issues\": [\"healthcare\"",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # Check if bill is currently open for voting\n    # For now",
        "import:fastapi.Party",
        "import:fastapi.description=\"Filter by specific bill\")",
        "import:fastapi.\"economic_policy\"]",
        "import:fastapi.\"confidence_level\": vote_data.get(\"confidence_level\"",
        "import:fastapi.\"transparency\"]",
        "import:fastapi.\"abstentions\": len([v for v in filtered_history if v[\"vote_choice\"] == \"abstain\"])\n        }",
        "import:fastapi.\"confidence_breakdown\": {\n            \"high\": len([v for v in filtered_history if v[\"confidence_level\"] == \"high\"])",
        "import:fastapi.\"economy\"]",
        "import:fastapi.\"vote_choice\": \"yes\"",
        "import:fastapi.\"confidence_breakdown\": {\n            \"high\": len([v for v in mock_user_votes if v[\"confidence_level\"] == \"high\"])",
        "import:fastapi.No",
        "import:fastapi.\"accessibility\"]",
        "import:fastapi.\"constituency\": \"Calgary Centre\"",
        "import:fastapi.this would be restricted)\n    \n    # For now",
        "import:fastapi.\"related_issues\": [\"climate_change\"",
        "import:fastapi.1.0)",
        "import:fastapi.\"related_issues\": [\"economic_impact\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"user_id\": vote_data[\"user_id\"]",
        "import:fastapi.\"related_issues\": [\"government_spending\"",
        "import:fastapi.\"vote_choice\": vote_data[\"vote_choice\"].lower()",
        "import:fastapi.\"party_diversity\": len(set(v[\"party_preference\"] for v in mock_user_votes if v[\"party_preference\"]))\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"voting_frequency\": \"regular\"",
        "import:fastapi.\"display_name\": \"John Doe\"",
        "import:fastapi.\"results\": paginated_votes",
        "import:fastapi.\"vote_date\": \"2025-01-05T11:15:00Z\"",
        "import:fastapi.\"no_votes\": len([v for v in filtered_history if v[\"vote_choice\"] == \"no\"])",
        "import:fastapi.\"vote_date\": datetime.utcnow().isoformat()",
        "import:fastapi.we'll assume all bills are open for voting\n    # In a real implementation",
        "import:fastapi.\"bill_id\": str(bill_id)",
        "import:fastapi.\"bill_number\": \"C-125\"",
        "import:fastapi.\"confidence_level\": \"medium\"",
        "import:fastapi.or Abstain on bills.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"user_id\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a user's complete voting history.\n    Shows all bills they've voted on and their voting patterns.\n    \"\"\"\n    # For now",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"username\": \"jane_smith\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.\"voting_pattern\": {\n            \"yes_votes\": len([v for v in filtered_history if v[\"vote_choice\"] == \"yes\"])",
        "import:fastapi.\"user_id\": \"user-123\"",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.\"uncertainty\"]",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.vote_data: Dict[str",
        "import:fastapi.\"bill_outcome\": \"Passed\"",
        "import:fastapi.\"filters_applied\": {\n            \"bill_id\": bill_id",
        "import:fastapi.\"display_name\": \"Jane Smith\"",
        "import:fastapi.\"abstain\"]\n    if vote_data[\"vote_choice\"].lower() not in valid_choices:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.\"reason\"]\n    for field in required_fields:\n        if field not in vote_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.we'll allow multiple votes (in real implementation",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"pollution_control\"]",
        "import:fastapi.\"location\": vote_data.get(\"location\")",
        "import:fastapi.\"user_id\": \"user-789\"",
        "import:fastapi.\"influence_factors\": [\"fiscal_concerns\"",
        "import:fastapi.\"bill_status\": \"Third Reading\"",
        "import:fastapi.\"mismatches\": len([v for v in filtered_history if not v[\"mp_vote_match\"]])\n        }",
        "import:fastapi.\"public\")",
        "import:fastapi.Query",
        "import:fastapi.\"very_high\"]])",
        "import:fastapi.\"no_votes\": len([v for v in mock_user_votes if v[\"vote_choice\"] == \"no\"])",
        "import:fastapi.\"constituency_consensus\": \"very_high\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_history = mock_voting_history\n    \n    if bill_id:\n        filtered_history = [\n            vote for vote in filtered_history\n            if vote[\"bill_id\"] == str(bill_id)\n        ]\n    \n    if vote_choice:\n        filtered_history = [\n            vote for vote in filtered_history\n            if vote[\"vote_choice\"] == vote_choice.lower()\n        ]\n    \n    # Apply pagination\n    total = len(filtered_history)\n    offset = (page - 1) * page_size\n    paginated_history = filtered_history[offset:offset + page_size]\n    \n    # Calculate user voting statistics\n    user_stats = {\n        \"total_votes_cast\": total",
        "import:fastapi.user_id: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by specific user\")",
        "import:fastapi.\"constituency_coverage\": len(set(v[\"constituency\"] for v in mock_user_votes if v[\"constituency\"]))",
        "import:fastapi.\"bill_number\": \"C-124\"",
        "function:get_user_voting_history",
        "import:fastapi.\"party_preference\": \"Independent\"",
        "import:fastapi.this would come from the database\n    mock_user_votes = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"display_name\": \"Bob Wilson\"",
        "import:fastapi.\"bill_status\": \"Royal Assent\"",
        "import:fastapi.\"related_issues\": vote_data.get(\"related_issues\"",
        "import:fastapi.\"low\": len([v for v in mock_user_votes if v[\"confidence_level\"] == \"low\"])\n        }",
        "import:fastapi.\"number\": bill.number",
        "import:fastapi.\"bill_status\": \"Second Reading\"",
        "import:fastapi.\"reason\": \"Concerned about increased government spending\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"public_visibility\": vote_data.get(\"public_visibility\"",
        "import:fastapi.\"bill_id\": \"124\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\"social_justice\"]",
        "import:fastapi.\"medium\")",
        "import:fastapi.\"total\": total",
        "import:fastapi.timedelta\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"constituent_feedback\"]",
        "import:fastapi.\"mp_vote_alignment\": {\n            \"matches\": len([v for v in filtered_history if v[\"mp_vote_match\"]])",
        "import:fastapi.\"bill_title\": \"Environmental Protection Act\"",
        "import:fastapi.\"bill_number\": \"C-123\"",
        "import:fastapi.\"vote_choice\": \"no\"",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get all user votes for a specific bill.\n    Shows how the public is voting on the bill.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"username\": \"bob_wilson\"",
        "import:fastapi.\"medium\": len([v for v in mock_user_votes if v[\"confidence_level\"] == \"medium\"])",
        "import:fastapi.\"top_issues\": [\"environment\"",
        "import:fastapi.bill_id: Optional[int] = Query(None",
        "import:fastapi.\"confidence_level\": \"high\"",
        "import:fastapi.\"constituency_match\": True\n        }",
        "import:fastapi.\"mp_vote_match\": False",
        "import:fastapi.\"vote_date\": \"2025-01-10T14:20:00Z\"",
        "import:fastapi.\"reason\": \"Concerned about economic impact on small businesses\"",
        "import:fastapi.\"session_id\": vote_data.get(\"session_id\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"bill_title\": \"Economic Recovery Act\"",
        "import:fastapi.\"user_id\": \"user-456\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/bills/{bill_id}/cast-vote\")\nasync def cast_bill_vote(\n    bill_id: int",
        "import:fastapi.\"low\": len([v for v in filtered_history if v[\"confidence_level\"] == \"low\"])\n        }",
        "import:fastapi.\"business_regulation\"]",
        "import:fastapi.List",
        "import:fastapi.description=\"Vote data\")",
        "import:fastapi.\"user_voting_statistics\": user_stats",
        "import:fastapi.\"business_interests\"]",
        "import:fastapi.Dict",
        "import:fastapi.\"vote_date\": \"2025-01-15T08:45:00Z\"",
        "import:fastapi.APIRouter",
        "import:fastapi.\"constituency\": \"Vancouver Centre\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/user/{user_id}/voting-recommendations": {
      "method": "GET",
      "path": "/user/{user_id}/voting-recommendations",
      "file": "services/api-gateway/app/api/v1/user-voting.py",
      "line": 289,
      "dependencies": [
        "import:fastapi.detail=f\"Failed to retrieve user votes: {str(e)}\")\n\n@router.get(\"/user/{user_id}/voting-history\"",
        "import:fastapi.page_size=page_size",
        "import:fastapi.overall_statistics={\n                    \"total_votes_cast\": 0",
        "import:fastapi.vote_weight=vote_data.vote_weight",
        "import:fastapi.\"abstain_percentage\": round((abstentions / total_votes) * 100",
        "import:fastapi.\"abstentions\": 0",
        "import:fastapi.1) if total > 0 else 0\n            no_pct = round((stats[\"no\"] / total) * 100",
        "import:fastapi.\"total\": 0}\n                \n                party_preferences[vote.party_preference][vote.vote_choice] += 1\n                party_preferences[vote.party_preference][\"total\"] += 1\n        \n        # Calculate party percentages\n        for party",
        "import:fastapi.# Would need age data from user profiles\n            \"party_preferences\": party_preferences\n        }\n        \n        # Calculate voting trends\n        daily_voting = {}\n        for vote in all_votes:\n            date_str = vote.vote_date.strftime(\"%Y-%m-%d\")\n            daily_voting[date_str] = daily_voting.get(date_str",
        "import:fastapi.vote_data: UserVoteCreate = None",
        "import:fastapi.constituency=vote_data.constituency",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get voting history for a specific user\"\"\"\n    try:\n        query = db.query(UserVote).filter(UserVote.user_id == user_id).order_by(UserVote.vote_date.desc())\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        votes = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [UserVoteResponse.from_orm(vote) for vote in votes]\n        \n        return UserVoteListResponse(\n            results=results",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.user_voting import UserVote\nfrom app.schemas.user_voting import UserVoteCreate",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"constituency_coverage\": round((len(constituencies) / 338) * 100",
        "import:fastapi.constituency_breakdown={\n                    \"total_constituencies\": 0",
        "import:fastapi.1) if total > 0 else 0",
        "import:fastapi.# Simplified\n            \"voting_momentum\": \"Steady\" if len(daily_voting) > 1 else \"Initial\"",
        "import:fastapi.vote_date=datetime.utcnow()\n        )\n        \n        db.add(new_vote)\n        db.commit()\n        db.refresh(new_vote)\n        \n        return UserVoteResponse.from_orm(new_vote)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.ge=1",
        "import:fastapi.total_count=total_count",
        "import:fastapi.\"abstain\": round((stats[\"abstain\"] / total) * 100",
        "import:fastapi.session_id=vote_data.session_id",
        "import:fastapi.le=100",
        "import:fastapi.constituency_breakdown=constituency_breakdown",
        "import:fastapi.\"yes_votes\": stats[\"yes\"]",
        "import:fastapi.related_issues=vote_data.related_issues",
        "import:fastapi.\"top_opposing_constituencies\": []\n                }",
        "import:fastapi.VoteSummaryResponse\n\nrouter = APIRouter(prefix=\"/user-voting\"",
        "import:fastapi.\"party_preferences\": {}\n                }",
        "import:fastapi.\"no\": 0",
        "import:fastapi.UserVoteResponse",
        "import:fastapi.detail=f\"Failed to cast vote: {str(e)}\")\n\n@router.get(\"/bill/{bill_id}/user-votes\"",
        "import:fastapi.stats in constituencies.items():\n            total = stats[\"total\"]\n            yes_pct = round((stats[\"yes\"] / total) * 100",
        "import:fastapi.\"daily_voting\": {}\n                }\n            )\n        \n        # Calculate overall statistics\n        total_votes = len(all_votes)\n        yes_votes = len([v for v in all_votes if v.vote_choice == 'yes'])\n        no_votes = len([v for v in all_votes if v.vote_choice == 'no'])\n        abstentions = len([v for v in all_votes if v.vote_choice == 'abstain'])\n        \n        overall_stats = {\n            \"total_votes_cast\": total_votes",
        "import:fastapi.HTTPException",
        "import:fastapi.\"yes_percentage\": yes_pct",
        "import:fastapi.\"yes_percentage\": 0",
        "import:fastapi.\"yes_votes\": yes_votes",
        "import:fastapi.demographic_breakdown=demographic_breakdown",
        "import:fastapi.total_pages=(total_count + page_size - 1) // page_size\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.UserVoteListResponse",
        "import:fastapi.influence_factors=vote_data.influence_factors",
        "import:fastapi.response_model=UserVoteListResponse)\nasync def get_bill_user_votes(\n    bill_id: str",
        "import:fastapi.\"no_percentage\": round((no_votes / total_votes) * 100",
        "import:fastapi.tags=[\"User Voting\"])\n\n@router.post(\"/cast-vote\"",
        "import:fastapi.\"yes_percentage\": round((yes_votes / total_votes) * 100",
        "import:fastapi.response_model=UserVoteListResponse)\nasync def get_user_voting_history(\n    user_id: str",
        "import:fastapi.key=lambda x: x[\"no_percentage\"]",
        "import:fastapi.# Assuming 338 federal ridings\n            \"top_supporting_constituencies\": supporting_constituencies",
        "import:fastapi.0) + 1\n        \n        voting_trends = {\n            \"peak_voting_time\": \"Afternoon\"",
        "import:fastapi.detail=f\"Failed to generate voting summary: {str(e)}\")",
        "import:fastapi.Depends",
        "import:fastapi.confidence_level=vote_data.confidence_level",
        "import:fastapi.page=page",
        "import:fastapi.\"constituency_coverage\": 0",
        "import:fastapi.location=vote_data.location",
        "import:fastapi.overall_statistics=overall_stats",
        "import:fastapi.1) if total > 0 else 0\n            }\n        \n        demographic_breakdown = {\n            \"age_groups\": {}",
        "import:fastapi.vote_choice=vote_data.vote_choice",
        "import:fastapi.\"no_votes\": no_votes",
        "import:fastapi.reverse=True)[:5]\n        \n        constituency_breakdown = {\n            \"total_constituencies\": len(constituencies)",
        "import:fastapi.response_model=UserVoteResponse)\nasync def cast_bill_vote(\n    bill_id: str = Query(...",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Cast a user vote on a bill\"\"\"\n    try:\n        # Check if user already voted on this bill\n        existing_vote = db.query(UserVote).filter(\n            UserVote.user_id == vote_data.user_id",
        "import:fastapi.\"no_votes\": 0",
        "import:fastapi.party_preference=vote_data.party_preference",
        "import:fastapi.\"top_opposing_constituencies\": opposing_constituencies\n        }\n        \n        # Calculate demographic breakdown (simplified)\n        party_preferences = {}\n        for vote in all_votes:\n            if vote.party_preference:\n                if vote.party_preference not in party_preferences:\n                    party_preferences[vote.party_preference] = {\"yes\": 0",
        "import:fastapi.\"constituencies_with_votes\": 0",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.demographic_breakdown={\n                    \"age_groups\": {}",
        "import:fastapi.\"abstain\": 0",
        "import:fastapi.1) if total > 0 else 0\n            \n            constituency_stats.append({\n                \"name\": constituency",
        "import:fastapi.response_model=VoteSummaryResponse)\nasync def get_bill_voting_summary(\n    bill_id: str",
        "import:fastapi.\"constituency_spread\": \"Unknown\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"voting_momentum\": \"Unknown\"",
        "import:fastapi.voting_trends=voting_trends\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.reverse=True)[:5]\n        opposing_constituencies = sorted(constituency_stats",
        "import:fastapi.key=lambda x: x[\"yes_percentage\"]",
        "import:fastapi.\"yes_votes\": 0",
        "import:fastapi.UserVote.bill_id == bill_id\n        ).first()\n        \n        if existing_vote:\n            # Update existing vote\n            existing_vote.vote_choice = vote_data.vote_choice\n            existing_vote.reason = vote_data.reason\n            existing_vote.confidence_level = vote_data.confidence_level\n            existing_vote.constituency = vote_data.constituency\n            existing_vote.party_preference = vote_data.party_preference\n            existing_vote.influence_factors = vote_data.influence_factors\n            existing_vote.related_issues = vote_data.related_issues\n            existing_vote.public_visibility = vote_data.public_visibility\n            existing_vote.vote_weight = vote_data.vote_weight\n            existing_vote.device = vote_data.device\n            existing_vote.location = vote_data.location\n            existing_vote.session_id = vote_data.session_id\n            existing_vote.updated_at = datetime.utcnow()\n            \n            db.commit()\n            db.refresh(existing_vote)\n            \n            return UserVoteResponse.from_orm(existing_vote)\n        \n        # Create new vote\n        new_vote = UserVote(\n            user_id=vote_data.user_id",
        "import:fastapi.\"total_votes\": total",
        "import:fastapi.reason=vote_data.reason",
        "import:fastapi.\"no_votes\": stats[\"no\"]",
        "import:fastapi.\"daily_voting\": daily_voting\n        }\n        \n        return VoteSummaryResponse(\n            bill_id=bill_id",
        "import:fastapi.\"total\": 0}\n                \n                constituencies[vote.constituency][vote.vote_choice] += 1\n                constituencies[vote.constituency][\"total\"] += 1\n        \n        # Calculate constituency statistics\n        constituency_stats = []\n        for constituency",
        "import:fastapi.1)",
        "import:fastapi.\"no_percentage\": no_pct\n            })\n        \n        # Sort constituencies by yes percentage and no percentage\n        supporting_constituencies = sorted(constituency_stats",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get user votes for a specific bill\"\"\"\n    try:\n        query = db.query(UserVote).filter(UserVote.bill_id == bill_id)\n        \n        if public_only:\n            query = query.filter(UserVote.public_visibility == 'public')\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        votes = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [UserVoteResponse.from_orm(vote) for vote in votes]\n        \n        return UserVoteListResponse(\n            results=results",
        "function:get_bill_voting_summary",
        "import:fastapi.\"constituencies_with_votes\": len(constituencies)",
        "import:fastapi.voting_trends={\n                    \"peak_voting_time\": \"Unknown\"",
        "import:fastapi.public_visibility=vote_data.public_visibility",
        "import:fastapi.description=\"Bill ID to vote on\")",
        "import:fastapi.1) if total_votes > 0 else 0",
        "import:fastapi.\"top_supporting_constituencies\": []",
        "import:fastapi.\"abstentions\": abstentions",
        "import:fastapi.\"no\": round((stats[\"no\"] / total) * 100",
        "import:fastapi.stats in party_preferences.items():\n            total = stats[\"total\"]\n            party_preferences[party] = {\n                \"yes\": round((stats[\"yes\"] / total) * 100",
        "import:fastapi.description=\"Show only public votes\")",
        "import:fastapi.\"no_percentage\": 0",
        "import:fastapi.\"abstain_percentage\": 0\n                }",
        "import:fastapi.\"constituency_spread\": \"Wide\" if len(constituencies) > 10 else \"Limited\"",
        "import:fastapi.1) if total_votes > 0 else 0\n        }\n        \n        # Calculate constituency breakdown\n        constituencies = {}\n        for vote in all_votes:\n            if vote.constituency:\n                if vote.constituency not in constituencies:\n                    constituencies[vote.constituency] = {\"yes\": 0",
        "import:fastapi.public_only: bool = Query(True",
        "import:fastapi.bill_id=bill_id",
        "import:fastapi.device=vote_data.device",
        "import:fastapi.\"abstentions\": stats[\"abstain\"]",
        "import:fastapi.APIRouter",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get comprehensive voting summary for a bill\"\"\"\n    try:\n        # Get all votes for the bill\n        all_votes = db.query(UserVote).filter(UserVote.bill_id == bill_id).all()\n        \n        if not all_votes:\n            return VoteSummaryResponse(\n                bill_id=bill_id",
        "import:fastapi.detail=f\"Failed to retrieve voting history: {str(e)}\")\n\n@router.get(\"/bill/{bill_id}/voting-summary\""
      ]
    },
    "POST:/cast-vote": {
      "method": "POST",
      "path": "/cast-vote",
      "file": "services/api-gateway/app/api/v1/user-voting.py",
      "line": 13,
      "dependencies": [
        "import:fastapi.VoteSummaryResponse\n\nrouter = APIRouter(prefix=\"/user-voting\"",
        "import:fastapi.UserVoteResponse",
        "import:fastapi.UserVoteListResponse",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.user_voting import UserVote\nfrom app.schemas.user_voting import UserVoteCreate",
        "import:fastapi.Depends",
        "import:fastapi.tags=[\"User Voting\"])",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List"
      ]
    },
    "GET:/bill/{bill_id}/user-votes": {
      "method": "GET",
      "path": "/bill/{bill_id}/user-votes",
      "file": "services/api-gateway/app/api/v1/user-voting.py",
      "line": 77,
      "dependencies": [
        "import:fastapi.vote_weight=vote_data.vote_weight",
        "import:fastapi.response_model=UserVoteResponse)\nasync def cast_bill_vote(\n    bill_id: str = Query(...",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Cast a user vote on a bill\"\"\"\n    try:\n        # Check if user already voted on this bill\n        existing_vote = db.query(UserVote).filter(\n            UserVote.user_id == vote_data.user_id",
        "import:fastapi.vote_data: UserVoteCreate = None",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.party_preference=vote_data.party_preference",
        "import:fastapi.constituency=vote_data.constituency",
        "import:fastapi.UserVoteListResponse",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.user_voting import UserVote\nfrom app.schemas.user_voting import UserVoteCreate",
        "import:fastapi.influence_factors=vote_data.influence_factors",
        "import:fastapi.tags=[\"User Voting\"])\n\n@router.post(\"/cast-vote\"",
        "import:fastapi.public_visibility=vote_data.public_visibility",
        "import:fastapi.vote_date=datetime.utcnow()\n        )\n        \n        db.add(new_vote)\n        db.commit()\n        db.refresh(new_vote)\n        \n        return UserVoteResponse.from_orm(new_vote)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.description=\"Bill ID to vote on\")",
        "import:fastapi.session_id=vote_data.session_id",
        "import:fastapi.Depends",
        "import:fastapi.confidence_level=vote_data.confidence_level",
        "import:fastapi.UserVote.bill_id == bill_id\n        ).first()\n        \n        if existing_vote:\n            # Update existing vote\n            existing_vote.vote_choice = vote_data.vote_choice\n            existing_vote.reason = vote_data.reason\n            existing_vote.confidence_level = vote_data.confidence_level\n            existing_vote.constituency = vote_data.constituency\n            existing_vote.party_preference = vote_data.party_preference\n            existing_vote.influence_factors = vote_data.influence_factors\n            existing_vote.related_issues = vote_data.related_issues\n            existing_vote.public_visibility = vote_data.public_visibility\n            existing_vote.vote_weight = vote_data.vote_weight\n            existing_vote.device = vote_data.device\n            existing_vote.location = vote_data.location\n            existing_vote.session_id = vote_data.session_id\n            existing_vote.updated_at = datetime.utcnow()\n            \n            db.commit()\n            db.refresh(existing_vote)\n            \n            return UserVoteResponse.from_orm(existing_vote)\n        \n        # Create new vote\n        new_vote = UserVote(\n            user_id=vote_data.user_id",
        "import:fastapi.related_issues=vote_data.related_issues",
        "import:fastapi.VoteSummaryResponse\n\nrouter = APIRouter(prefix=\"/user-voting\"",
        "import:fastapi.UserVoteResponse",
        "import:fastapi.reason=vote_data.reason",
        "import:fastapi.bill_id=bill_id",
        "import:fastapi.detail=f\"Failed to cast vote: {str(e)}\")",
        "import:fastapi.location=vote_data.location",
        "import:fastapi.device=vote_data.device",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "function:cast_bill_vote",
        "import:fastapi.vote_choice=vote_data.vote_choice"
      ]
    },
    "GET:/bill/{bill_id}/voting-summary": {
      "method": "GET",
      "path": "/bill/{bill_id}/voting-summary",
      "file": "services/api-gateway/app/api/v1/user-voting.py",
      "line": 145,
      "dependencies": [
        "import:fastapi.detail=f\"Failed to retrieve user votes: {str(e)}\")\n\n@router.get(\"/user/{user_id}/voting-history\"",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.vote_weight=vote_data.vote_weight",
        "import:fastapi.response_model=UserVoteResponse)\nasync def cast_bill_vote(\n    bill_id: str = Query(...",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get user votes for a specific bill\"\"\"\n    try:\n        query = db.query(UserVote).filter(UserVote.bill_id == bill_id)\n        \n        if public_only:\n            query = query.filter(UserVote.public_visibility == 'public')\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        votes = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [UserVoteResponse.from_orm(vote) for vote in votes]\n        \n        return UserVoteListResponse(\n            results=results",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Cast a user vote on a bill\"\"\"\n    try:\n        # Check if user already voted on this bill\n        existing_vote = db.query(UserVote).filter(\n            UserVote.user_id == vote_data.user_id",
        "import:fastapi.total_pages=(total_count + page_size - 1) // page_size\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.vote_data: UserVoteCreate = None",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.party_preference=vote_data.party_preference",
        "import:fastapi.constituency=vote_data.constituency",
        "import:fastapi.UserVoteListResponse",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.user_voting import UserVote\nfrom app.schemas.user_voting import UserVoteCreate",
        "import:fastapi.influence_factors=vote_data.influence_factors",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.response_model=UserVoteListResponse)\nasync def get_bill_user_votes(\n    bill_id: str",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get voting history for a specific user\"\"\"\n    try:\n        query = db.query(UserVote).filter(UserVote.user_id == user_id).order_by(UserVote.vote_date.desc())\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        votes = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [UserVoteResponse.from_orm(vote) for vote in votes]\n        \n        return UserVoteListResponse(\n            results=results",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.tags=[\"User Voting\"])\n\n@router.post(\"/cast-vote\"",
        "import:fastapi.public_visibility=vote_data.public_visibility",
        "import:fastapi.response_model=UserVoteListResponse)\nasync def get_user_voting_history(\n    user_id: str",
        "import:fastapi.vote_date=datetime.utcnow()\n        )\n        \n        db.add(new_vote)\n        db.commit()\n        db.refresh(new_vote)\n        \n        return UserVoteResponse.from_orm(new_vote)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.ge=1",
        "import:fastapi.total_count=total_count",
        "import:fastapi.description=\"Bill ID to vote on\")",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.session_id=vote_data.session_id",
        "import:fastapi.Depends",
        "import:fastapi.le=100",
        "import:fastapi.confidence_level=vote_data.confidence_level",
        "import:fastapi.description=\"Show only public votes\")",
        "import:fastapi.UserVote.bill_id == bill_id\n        ).first()\n        \n        if existing_vote:\n            # Update existing vote\n            existing_vote.vote_choice = vote_data.vote_choice\n            existing_vote.reason = vote_data.reason\n            existing_vote.confidence_level = vote_data.confidence_level\n            existing_vote.constituency = vote_data.constituency\n            existing_vote.party_preference = vote_data.party_preference\n            existing_vote.influence_factors = vote_data.influence_factors\n            existing_vote.related_issues = vote_data.related_issues\n            existing_vote.public_visibility = vote_data.public_visibility\n            existing_vote.vote_weight = vote_data.vote_weight\n            existing_vote.device = vote_data.device\n            existing_vote.location = vote_data.location\n            existing_vote.session_id = vote_data.session_id\n            existing_vote.updated_at = datetime.utcnow()\n            \n            db.commit()\n            db.refresh(existing_vote)\n            \n            return UserVoteResponse.from_orm(existing_vote)\n        \n        # Create new vote\n        new_vote = UserVote(\n            user_id=vote_data.user_id",
        "import:fastapi.related_issues=vote_data.related_issues",
        "import:fastapi.page=page",
        "import:fastapi.VoteSummaryResponse\n\nrouter = APIRouter(prefix=\"/user-voting\"",
        "import:fastapi.UserVoteResponse",
        "import:fastapi.detail=f\"Failed to retrieve voting history: {str(e)}\")",
        "import:fastapi.reason=vote_data.reason",
        "import:fastapi.public_only: bool = Query(True",
        "function:get_user_voting_history",
        "import:fastapi.bill_id=bill_id",
        "import:fastapi.detail=f\"Failed to cast vote: {str(e)}\")\n\n@router.get(\"/bill/{bill_id}/user-votes\"",
        "import:fastapi.location=vote_data.location",
        "import:fastapi.device=vote_data.device",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "import:fastapi.vote_choice=vote_data.vote_choice"
      ]
    },
    "ROUTER:/user-voting": {
      "method": "ROUTER",
      "path": "/user-voting",
      "file": "services/api-gateway/app/api/v1/user-voting.py",
      "line": 11,
      "dependencies": [
        "import:fastapi.UserVoteResponse",
        "import:fastapi.UserVoteListResponse",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.user_voting import UserVote\nfrom app.schemas.user_voting import UserVoteCreate",
        "import:fastapi.Depends",
        "import:fastapi.VoteSummaryResponse\n\nrouter =",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List"
      ]
    },
    "GET:/profiles": {
      "method": "GET",
      "path": "/profiles",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 36,
      "dependencies": [
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.hash_password",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.UserListResponse",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.UserSearchResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Path",
        "import:fastapi.or_",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.UserPreferences",
        "import:fastapi.UserActivity",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.Body",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text"
      ]
    },
    "GET:/profiles/{user_id}": {
      "method": "GET",
      "path": "/profiles/{user_id}",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 114,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.postal_code=user.postal_code",
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.email=user.email",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all users with pagination and filtering.\n    \n    Requires authentication and appropriate permissions.\n    \"\"\"\n    # Build base query\n    query = db.query(User)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    \n    if is_verified is not None:\n        query = query.filter(User.is_verified == is_verified)\n    \n    # Apply search if provided\n    if search:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.language_preference=user.language_preference",
        "import:fastapi.hash_password",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.is_active=user.is_active",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.phone=user.phone",
        "import:fastapi.UserListResponse",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.ge=1",
        "import:fastapi.avatar_url=user.avatar_url",
        "import:fastapi.last_activity=user.last_activity\n        ))\n    \n    return UserListResponse(\n        users=user_responses",
        "import:fastapi.username=user.username",
        "import:fastapi.website=user.website",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=search))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get users\n    users = query.order_by(User.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    user_responses = []\n    for user in users:\n        user_responses.append(UserProfileResponse(\n            id=str(user.id)",
        "import:fastapi.location=user.location",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserSearchResponse",
        "import:fastapi.created_at=user.created_at",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.Path",
        "import:fastapi.bio=user.bio",
        "import:fastapi.last_login=user.last_login",
        "import:fastapi.total=total",
        "import:fastapi.or_",
        "import:fastapi.description=\"Filter by verification status\")",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================\n\n@router.get(\"/profiles\"",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.timezone=user.timezone",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.page=page",
        "import:fastapi.users.username || ' ' || users.full_name || ' ' || COALESCE(users.bio",
        "import:fastapi.UserPreferences",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.UserActivity",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.Body",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.is_verified: Optional[bool] = Query(None",
        "import:fastapi.full_name=user.full_name",
        "function:list_users",
        "import:fastapi.Dict",
        "import:fastapi.updated_at=user.updated_at",
        "import:fastapi.APIRouter",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.is_verified=user.is_verified",
        "import:fastapi.HTTPException",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text"
      ]
    },
    "PUT:/profiles/{user_id}": {
      "method": "PUT",
      "path": "/profiles/{user_id}",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 160,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.check if users are friends\n            raise HTTPException(status_code=403",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.hash_password",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ge=1",
        "import:fastapi.avatar_url=user.avatar_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================\n\n@router.get(\"/profiles\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.updated_at=user.updated_at",
        "import:fastapi.is_verified=user.is_verified",
        "import:fastapi.HTTPException",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.email=user.email",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/profiles/{user_id}\"",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.created_at=user.created_at",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.bio=user.bio",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.detail=\"Profile is friends-only\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.language_preference=user.language_preference",
        "import:fastapi.is_active=user.is_active",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.last_activity=user.last_activity\n        ))\n    \n    return UserListResponse(\n        users=user_responses",
        "import:fastapi.username=user.username",
        "import:fastapi.website=user.website",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.users.username || ' ' || users.full_name || ' ' || COALESCE(users.bio",
        "import:fastapi.UserPreferences",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.is_verified: Optional[bool] = Query(None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all users with pagination and filtering.\n    \n    Requires authentication and appropriate permissions.\n    \"\"\"\n    # Build base query\n    query = db.query(User)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    \n    if is_verified is not None:\n        query = query.filter(User.is_verified == is_verified)\n    \n    # Apply search if provided\n    if search:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.postal_code=user.postal_code",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.last_login=user.last_login",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.phone=user.phone",
        "import:fastapi.UserListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.detail=\"Profile is private\")\n        elif user.privacy_level == \"friends_only\":\n            # In a real implementation",
        "import:fastapi.location=user.location",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=search))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get users\n    users = query.order_by(User.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    user_responses = []\n    for user in users:\n        user_responses.append(UserProfileResponse(\n            id=str(user.id)",
        "import:fastapi.detail=\"User not found\")\n    \n    # Check privacy settings\n    if str(current_user.id) != user_id:\n        if user.privacy_level == \"private\":\n            raise HTTPException(status_code=403",
        "import:fastapi.description=\"Filter by verification status\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.timezone=user.timezone",
        "import:fastapi.response_model=UserProfileResponse)\nasync def get_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.UserActivity",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific user's profile by ID.\n    \n    Users can only view their own profile or public profiles based on privacy settings.\n    \"\"\"\n    # Check if user exists\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.last_activity=user.last_activity\n    )",
        "import:fastapi.APIRouter",
        "function:get_user_profile",
        "import:fastapi.UserSearchResponse"
      ]
    },
    "POST:/profiles/{user_id}/change-password": {
      "method": "POST",
      "path": "/profiles/{user_id}/change-password",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 214,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.check if users are friends\n            raise HTTPException(status_code=403",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.hash_password",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.detail=\"User not found\")\n    \n    # Update profile fields\n    update_data = profile_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.ge=1",
        "import:fastapi.avatar_url=user.avatar_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================\n\n@router.get(\"/profiles\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's profile.\n    \n    Users can only update their own profile.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.updated_at=user.updated_at",
        "import:fastapi.field):\n            setattr(user",
        "import:fastapi.is_verified=user.is_verified",
        "import:fastapi.HTTPException",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.detail=\"Can only update own profile\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.email=user.email",
        "import:fastapi.value)\n    \n    user.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(user)\n    \n    logger.info(f\"User profile updated: {user.username}\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/profiles/{user_id}\"",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.created_at=user.created_at",
        "import:fastapi.Depends",
        "function:update_user_profile",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.bio=user.bio",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.detail=\"Profile is friends-only\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.language_preference=user.language_preference",
        "import:fastapi.is_active=user.is_active",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.last_activity=user.last_activity\n        ))\n    \n    return UserListResponse(\n        users=user_responses",
        "import:fastapi.username=user.username",
        "import:fastapi.website=user.website",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.profile_data: UserUpdateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.users.username || ' ' || users.full_name || ' ' || COALESCE(users.bio",
        "import:fastapi.UserPreferences",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.is_verified: Optional[bool] = Query(None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all users with pagination and filtering.\n    \n    Requires authentication and appropriate permissions.\n    \"\"\"\n    # Build base query\n    query = db.query(User)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    \n    if is_verified is not None:\n        query = query.filter(User.is_verified == is_verified)\n    \n    # Apply search if provided\n    if search:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.put(\"/profiles/{user_id}\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.postal_code=user.postal_code",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.last_login=user.last_login",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.response_model=UserProfileResponse)\nasync def update_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.phone=user.phone",
        "import:fastapi.UserListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.detail=\"Profile is private\")\n        elif user.privacy_level == \"friends_only\":\n            # In a real implementation",
        "import:fastapi.location=user.location",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=search))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get users\n    users = query.order_by(User.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    user_responses = []\n    for user in users:\n        user_responses.append(UserProfileResponse(\n            id=str(user.id)",
        "import:fastapi.detail=\"User not found\")\n    \n    # Check privacy settings\n    if str(current_user.id) != user_id:\n        if user.privacy_level == \"private\":\n            raise HTTPException(status_code=403",
        "import:fastapi.value in update_data.items():\n        if hasattr(user",
        "import:fastapi.description=\"Filter by verification status\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.timezone=user.timezone",
        "import:fastapi.response_model=UserProfileResponse)\nasync def get_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.UserActivity",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific user's profile by ID.\n    \n    Users can only view their own profile or public profiles based on privacy settings.\n    \"\"\"\n    # Check if user exists\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.last_activity=user.last_activity\n    )",
        "import:fastapi.APIRouter",
        "import:fastapi.UserSearchResponse"
      ]
    },
    "GET:/profiles/{user_id}/preferences": {
      "method": "GET",
      "path": "/profiles/{user_id}/preferences",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 252,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.check if users are friends\n            raise HTTPException(status_code=403",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.hash_password",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.user.hashed_password):\n        raise HTTPException(status_code=400",
        "import:fastapi.detail=\"User not found\")\n    \n    # Update profile fields\n    update_data = profile_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.ge=1",
        "import:fastapi.avatar_url=user.avatar_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.detail=\"Current password is incorrect\")\n    \n    # Update password\n    user.hashed_password = hash_password(password_data.new_password)\n    user.updated_at = datetime.utcnow()\n    db.commit()\n    \n    logger.info(f\"Password changed for user: {user.username}\")\n    \n    return {\"message\": \"Password changed successfully\"}\n\n\n# ============================================================================\n# USER PREFERENCES\n# ============================================================================",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================\n\n@router.get(\"/profiles\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's profile.\n    \n    Users can only update their own profile.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.updated_at=user.updated_at",
        "import:fastapi.field):\n            setattr(user",
        "import:fastapi.is_verified=user.is_verified",
        "import:fastapi.HTTPException",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.detail=\"Can only update own profile\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.email=user.email",
        "import:fastapi.value)\n    \n    user.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(user)\n    \n    logger.info(f\"User profile updated: {user.username}\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/profiles/{user_id}\"",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.detail=\"User not found\")\n    \n    # Verify current password\n    if not verify_password(password_data.current_password",
        "import:fastapi.created_at=user.created_at",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.bio=user.bio",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.detail=\"Profile is friends-only\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Change a user's password.\n    \n    Users can only change their own password.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.language_preference=user.language_preference",
        "import:fastapi.is_active=user.is_active",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.last_activity=user.last_activity\n        ))\n    \n    return UserListResponse(\n        users=user_responses",
        "import:fastapi.username=user.username",
        "import:fastapi.website=user.website",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.profile_data: UserUpdateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.users.username || ' ' || users.full_name || ' ' || COALESCE(users.bio",
        "import:fastapi.UserPreferences",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.is_verified: Optional[bool] = Query(None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all users with pagination and filtering.\n    \n    Requires authentication and appropriate permissions.\n    \"\"\"\n    # Build base query\n    query = db.query(User)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    \n    if is_verified is not None:\n        query = query.filter(User.is_verified == is_verified)\n    \n    # Apply search if provided\n    if search:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.put(\"/profiles/{user_id}\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.postal_code=user.postal_code",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.last_login=user.last_login",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.response_model=UserProfileResponse)\nasync def update_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.password_data: PasswordChangeRequest = Body(...)",
        "import:fastapi.phone=user.phone",
        "import:fastapi.UserListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.detail=\"Profile is private\")\n        elif user.privacy_level == \"friends_only\":\n            # In a real implementation",
        "import:fastapi.location=user.location",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=search))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get users\n    users = query.order_by(User.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    user_responses = []\n    for user in users:\n        user_responses.append(UserProfileResponse(\n            id=str(user.id)",
        "import:fastapi.detail=\"User not found\")\n    \n    # Check privacy settings\n    if str(current_user.id) != user_id:\n        if user.privacy_level == \"private\":\n            raise HTTPException(status_code=403",
        "import:fastapi.value in update_data.items():\n        if hasattr(user",
        "function:change_user_password",
        "import:fastapi.description=\"Filter by verification status\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.timezone=user.timezone",
        "import:fastapi.response_model=UserProfileResponse)\nasync def get_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.post(\"/profiles/{user_id}/change-password\")\nasync def change_user_password(\n    user_id: str = Path(...",
        "import:fastapi.UserActivity",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific user's profile by ID.\n    \n    Users can only view their own profile or public profiles based on privacy settings.\n    \"\"\"\n    # Check if user exists\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.UserSearchResponse",
        "import:fastapi.detail=\"Can only change own password\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404"
      ]
    },
    "PUT:/profiles/{user_id}/preferences": {
      "method": "PUT",
      "path": "/profiles/{user_id}/preferences",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 326,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.page_size=page_size",
        "import:fastapi.favorite_topics=json.loads(preferences.favorite_topics) if preferences.favorite_topics else []",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.check if users are friends\n            raise HTTPException(status_code=403",
        "import:fastapi.high_contrast=False",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.screen_reader=False",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.hash_password",
        "import:fastapi.show_analytics=preferences.show_analytics",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.user.hashed_password):\n        raise HTTPException(status_code=400",
        "import:fastapi.detail=\"User not found\")\n    \n    # Update profile fields\n    update_data = profile_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.keyboard_navigation=preferences.keyboard_navigation",
        "import:fastapi.ge=1",
        "import:fastapi.avatar_url=user.avatar_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.screen_reader=preferences.screen_reader",
        "import:fastapi.font_size=\"medium\"",
        "import:fastapi.le=100",
        "import:fastapi.data_collection=True",
        "import:fastapi.response_model=UserPreferencesResponse)\nasync def get_user_preferences(\n    user_id: str = Path(...",
        "import:fastapi.or_",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================\n\n@router.get(\"/profiles\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's profile.\n    \n    Users can only update their own profile.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.favorite_mps=json.dumps([])",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.show_social_features=False",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.updated_at=user.updated_at",
        "import:fastapi.field):\n            setattr(user",
        "import:fastapi.is_verified=user.is_verified",
        "import:fastapi.HTTPException",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a user's preferences.\n    \n    Users can only view their own preferences.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.excluded_topics=json.loads(preferences.excluded_topics) if preferences.excluded_topics else []",
        "import:fastapi.third_party_sharing=preferences.third_party_sharing",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.detail=\"Can only update own profile\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.email=user.email",
        "import:fastapi.value)\n    \n    user.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(user)\n    \n    logger.info(f\"User profile updated: {user.username}\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/profiles/{user_id}\"",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.favorite_parties=json.loads(preferences.favorite_parties) if preferences.favorite_parties else []",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.reduced_motion=False\n        )\n        db.add(preferences)\n        db.commit()\n        db.refresh(preferences)\n    \n    return UserPreferencesResponse(\n        id=str(preferences.id)",
        "import:fastapi.detail=\"User not found\")\n    \n    # Verify current password\n    if not verify_password(password_data.current_password",
        "import:fastapi.created_at=user.created_at",
        "import:fastapi.Depends",
        "import:fastapi.keyboard_navigation=True",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.bio=user.bio",
        "import:fastapi.created_at=preferences.created_at",
        "import:fastapi.high_contrast=preferences.high_contrast",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.detail=\"Profile is friends-only\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.activity_sharing=preferences.activity_sharing",
        "import:fastapi.theme_preference=preferences.theme_preference",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Change a user's password.\n    \n    Users can only change their own password.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.language_preference=user.language_preference",
        "import:fastapi.third_party_sharing=False",
        "import:fastapi.data_collection=preferences.data_collection",
        "import:fastapi.is_active=user.is_active",
        "import:fastapi.profile_visibility=\"public\"",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.detail=\"Can only view own preferences\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.last_activity=user.last_activity\n        ))\n    \n    return UserListResponse(\n        users=user_responses",
        "import:fastapi.username=user.username",
        "import:fastapi.website=user.website",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.show_advanced_features=preferences.show_advanced_features",
        "import:fastapi.profile_data: UserUpdateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.show_social_features=preferences.show_social_features",
        "import:fastapi.total=total",
        "import:fastapi.theme_preference=\"light\"",
        "import:fastapi.activity_sharing=\"friends_only\"",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.users.username || ' ' || users.full_name || ' ' || COALESCE(users.bio",
        "import:fastapi.UserPreferences",
        "function:get_user_preferences",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.is_verified: Optional[bool] = Query(None",
        "import:fastapi.user_id=str(preferences.user_id)",
        "import:fastapi.favorite_parties=json.dumps([])",
        "import:fastapi.favorite_topics=json.dumps([])",
        "import:fastapi.content_difficulty=preferences.content_difficulty",
        "import:fastapi.reduced_motion=preferences.reduced_motion",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all users with pagination and filtering.\n    \n    Requires authentication and appropriate permissions.\n    \"\"\"\n    # Build base query\n    query = db.query(User)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    \n    if is_verified is not None:\n        query = query.filter(User.is_verified == is_verified)\n    \n    # Apply search if provided\n    if search:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.put(\"/profiles/{user_id}\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.postal_code=user.postal_code",
        "import:fastapi.excluded_topics=json.dumps([])",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get or create preferences\n    preferences = db.query(UserPreferences).filter(UserPreferences.user_id == user_id).first()\n    if not preferences:\n        # Create default preferences\n        preferences = UserPreferences(\n            user_id=user_id",
        "import:fastapi.font_size=preferences.font_size",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.show_advanced_features=True",
        "import:fastapi.last_login=user.last_login",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.response_model=UserProfileResponse)\nasync def update_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.password_data: PasswordChangeRequest = Body(...)",
        "import:fastapi.phone=user.phone",
        "import:fastapi.content_difficulty=\"intermediate\"",
        "import:fastapi.UserListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.detail=\"Profile is private\")\n        elif user.privacy_level == \"friends_only\":\n            # In a real implementation",
        "import:fastapi.location=user.location",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=search))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get users\n    users = query.order_by(User.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    user_responses = []\n    for user in users:\n        user_responses.append(UserProfileResponse(\n            id=str(user.id)",
        "import:fastapi.favorite_mps=json.loads(preferences.favorite_mps) if preferences.favorite_mps else []",
        "import:fastapi.detail=\"User not found\")\n    \n    # Check privacy settings\n    if str(current_user.id) != user_id:\n        if user.privacy_level == \"private\":\n            raise HTTPException(status_code=403",
        "import:fastapi.value in update_data.items():\n        if hasattr(user",
        "import:fastapi.description=\"Filter by verification status\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.timezone=user.timezone",
        "import:fastapi.response_model=UserProfileResponse)\nasync def get_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.post(\"/profiles/{user_id}/change-password\")\nasync def change_user_password(\n    user_id: str = Path(...",
        "import:fastapi.updated_at=preferences.updated_at\n    )",
        "import:fastapi.UserActivity",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific user's profile by ID.\n    \n    Users can only view their own profile or public profiles based on privacy settings.\n    \"\"\"\n    # Check if user exists\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.Body",
        "import:fastapi.profile_visibility=preferences.profile_visibility",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"Current password is incorrect\")\n    \n    # Update password\n    user.hashed_password = hash_password(password_data.new_password)\n    user.updated_at = datetime.utcnow()\n    db.commit()\n    \n    logger.info(f\"Password changed for user: {user.username}\")\n    \n    return {\"message\": \"Password changed successfully\"}\n\n\n# ============================================================================\n# USER PREFERENCES\n# ============================================================================\n\n@router.get(\"/profiles/{user_id}/preferences\"",
        "import:fastapi.show_analytics=True",
        "import:fastapi.UserSearchResponse",
        "import:fastapi.detail=\"Can only change own password\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404"
      ]
    },
    "POST:/profiles/{user_id}/activity": {
      "method": "POST",
      "path": "/profiles/{user_id}/activity",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 397,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.page_size=page_size",
        "import:fastapi.favorite_topics=json.loads(preferences.favorite_topics) if preferences.favorite_topics else []",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.check if users are friends\n            raise HTTPException(status_code=403",
        "import:fastapi.high_contrast=False",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.screen_reader=False",
        "import:fastapi.preferences_data: UserPreferencesUpdateRequest = Body(...)",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.hash_password",
        "import:fastapi.show_analytics=preferences.show_analytics",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.user.hashed_password):\n        raise HTTPException(status_code=400",
        "function:update_user_preferences",
        "import:fastapi.detail=\"User not found\")\n    \n    # Update profile fields\n    update_data = profile_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.keyboard_navigation=preferences.keyboard_navigation",
        "import:fastapi.ge=1",
        "import:fastapi.avatar_url=user.avatar_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.screen_reader=preferences.screen_reader",
        "import:fastapi.font_size=\"medium\"",
        "import:fastapi.le=100",
        "import:fastapi.data_collection=True",
        "import:fastapi.response_model=UserPreferencesResponse)\nasync def get_user_preferences(\n    user_id: str = Path(...",
        "import:fastapi.or_",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================\n\n@router.get(\"/profiles\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's profile.\n    \n    Users can only update their own profile.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.favorite_mps=json.dumps([])",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.show_social_features=False",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.updated_at=user.updated_at",
        "import:fastapi.field):\n            setattr(user",
        "import:fastapi.is_verified=user.is_verified",
        "import:fastapi.HTTPException",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a user's preferences.\n    \n    Users can only view their own preferences.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.list):\n                setattr(preferences",
        "import:fastapi.field):\n            if isinstance(value",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.excluded_topics=json.loads(preferences.excluded_topics) if preferences.excluded_topics else []",
        "import:fastapi.third_party_sharing=preferences.third_party_sharing",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.detail=\"Can only update own profile\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.email=user.email",
        "import:fastapi.value)\n    \n    user.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(user)\n    \n    logger.info(f\"User profile updated: {user.username}\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/profiles/{user_id}\"",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.favorite_parties=json.loads(preferences.favorite_parties) if preferences.favorite_parties else []",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.reduced_motion=False\n        )\n        db.add(preferences)\n        db.commit()\n        db.refresh(preferences)\n    \n    return UserPreferencesResponse(\n        id=str(preferences.id)",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get or create preferences\n    preferences = db.query(UserPreferences).filter(UserPreferences.user_id == user_id).first()\n    if not preferences:\n        preferences = UserPreferences(user_id=user_id)\n        db.add(preferences)\n    \n    # Update preferences\n    update_data = preferences_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.detail=\"User not found\")\n    \n    # Verify current password\n    if not verify_password(password_data.current_password",
        "import:fastapi.created_at=user.created_at",
        "import:fastapi.Depends",
        "import:fastapi.keyboard_navigation=True",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.json.dumps(value))\n            else:\n                setattr(preferences",
        "import:fastapi.bio=user.bio",
        "import:fastapi.created_at=preferences.created_at",
        "import:fastapi.high_contrast=preferences.high_contrast",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.detail=\"Profile is friends-only\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.value)\n    \n    preferences.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(preferences)\n    \n    logger.info(f\"User preferences updated: {user.username}\")\n    \n    return UserPreferencesResponse(\n        id=str(preferences.id)",
        "import:fastapi.activity_sharing=preferences.activity_sharing",
        "import:fastapi.theme_preference=preferences.theme_preference",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Change a user's password.\n    \n    Users can only change their own password.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.response_model=UserPreferencesResponse)\nasync def update_user_preferences(\n    user_id: str = Path(...",
        "import:fastapi.language_preference=user.language_preference",
        "import:fastapi.third_party_sharing=False",
        "import:fastapi.data_collection=preferences.data_collection",
        "import:fastapi.is_active=user.is_active",
        "import:fastapi.profile_visibility=\"public\"",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.detail=\"Can only view own preferences\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.last_activity=user.last_activity\n        ))\n    \n    return UserListResponse(\n        users=user_responses",
        "import:fastapi.username=user.username",
        "import:fastapi.website=user.website",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.show_advanced_features=preferences.show_advanced_features",
        "import:fastapi.value in update_data.items():\n        if hasattr(preferences",
        "import:fastapi.profile_data: UserUpdateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's preferences.\n    \n    Users can only update their own preferences.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.Query",
        "import:fastapi.show_social_features=preferences.show_social_features",
        "import:fastapi.total=total",
        "import:fastapi.theme_preference=\"light\"",
        "import:fastapi.activity_sharing=\"friends_only\"",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.users.username || ' ' || users.full_name || ' ' || COALESCE(users.bio",
        "import:fastapi.UserPreferences",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.is_verified: Optional[bool] = Query(None",
        "import:fastapi.user_id=str(preferences.user_id)",
        "import:fastapi.favorite_parties=json.dumps([])",
        "import:fastapi.favorite_topics=json.dumps([])",
        "import:fastapi.content_difficulty=preferences.content_difficulty",
        "import:fastapi.reduced_motion=preferences.reduced_motion",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all users with pagination and filtering.\n    \n    Requires authentication and appropriate permissions.\n    \"\"\"\n    # Build base query\n    query = db.query(User)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    \n    if is_verified is not None:\n        query = query.filter(User.is_verified == is_verified)\n    \n    # Apply search if provided\n    if search:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.put(\"/profiles/{user_id}\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.postal_code=user.postal_code",
        "import:fastapi.excluded_topics=json.dumps([])",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get or create preferences\n    preferences = db.query(UserPreferences).filter(UserPreferences.user_id == user_id).first()\n    if not preferences:\n        # Create default preferences\n        preferences = UserPreferences(\n            user_id=user_id",
        "import:fastapi.font_size=preferences.font_size",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.show_advanced_features=True",
        "import:fastapi.last_login=user.last_login",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.response_model=UserProfileResponse)\nasync def update_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.updated_at=preferences.updated_at\n    )\n\n\n@router.put(\"/profiles/{user_id}/preferences\"",
        "import:fastapi.password_data: PasswordChangeRequest = Body(...)",
        "import:fastapi.phone=user.phone",
        "import:fastapi.content_difficulty=\"intermediate\"",
        "import:fastapi.UserListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.detail=\"Profile is private\")\n        elif user.privacy_level == \"friends_only\":\n            # In a real implementation",
        "import:fastapi.location=user.location",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=search))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get users\n    users = query.order_by(User.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    user_responses = []\n    for user in users:\n        user_responses.append(UserProfileResponse(\n            id=str(user.id)",
        "import:fastapi.favorite_mps=json.loads(preferences.favorite_mps) if preferences.favorite_mps else []",
        "import:fastapi.detail=\"User not found\")\n    \n    # Check privacy settings\n    if str(current_user.id) != user_id:\n        if user.privacy_level == \"private\":\n            raise HTTPException(status_code=403",
        "import:fastapi.value in update_data.items():\n        if hasattr(user",
        "import:fastapi.description=\"Filter by verification status\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.timezone=user.timezone",
        "import:fastapi.response_model=UserProfileResponse)\nasync def get_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.post(\"/profiles/{user_id}/change-password\")\nasync def change_user_password(\n    user_id: str = Path(...",
        "import:fastapi.UserActivity",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific user's profile by ID.\n    \n    Users can only view their own profile or public profiles based on privacy settings.\n    \"\"\"\n    # Check if user exists\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.Body",
        "import:fastapi.profile_visibility=preferences.profile_visibility",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"Current password is incorrect\")\n    \n    # Update password\n    user.hashed_password = hash_password(password_data.new_password)\n    user.updated_at = datetime.utcnow()\n    db.commit()\n    \n    logger.info(f\"Password changed for user: {user.username}\")\n    \n    return {\"message\": \"Password changed successfully\"}\n\n\n# ============================================================================\n# USER PREFERENCES\n# ============================================================================\n\n@router.get(\"/profiles/{user_id}/preferences\"",
        "import:fastapi.show_analytics=True",
        "import:fastapi.detail=\"Can only update own preferences\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=preferences.updated_at\n    )\n\n\n# ============================================================================\n# USER ACTIVITY\n# ============================================================================",
        "import:fastapi.UserSearchResponse",
        "import:fastapi.detail=\"Can only change own password\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404"
      ]
    },
    "GET:/profiles/{user_id}/activity": {
      "method": "GET",
      "path": "/profiles/{user_id}/activity",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 449,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.page_size=page_size",
        "import:fastapi.favorite_topics=json.loads(preferences.favorite_topics) if preferences.favorite_topics else []",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.content_id=activity_data.content_id",
        "import:fastapi.check if users are friends\n            raise HTTPException(status_code=403",
        "import:fastapi.location=activity_data.location",
        "import:fastapi.high_contrast=False",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.screen_reader=False",
        "import:fastapi.preferences_data: UserPreferencesUpdateRequest = Body(...)",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.hash_password",
        "import:fastapi.show_analytics=preferences.show_analytics",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.user.hashed_password):\n        raise HTTPException(status_code=400",
        "import:fastapi.request: Request = None",
        "import:fastapi.detail=\"User not found\")\n    \n    # Update profile fields\n    update_data = profile_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.keyboard_navigation=preferences.keyboard_navigation",
        "import:fastapi.ge=1",
        "import:fastapi.avatar_url=user.avatar_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.screen_reader=preferences.screen_reader",
        "import:fastapi.font_size=\"medium\"",
        "import:fastapi.le=100",
        "import:fastapi.data_collection=True",
        "import:fastapi.response_model=UserPreferencesResponse)\nasync def get_user_preferences(\n    user_id: str = Path(...",
        "import:fastapi.activity_data: UserActivityCreateRequest = Body(...)",
        "import:fastapi.or_",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================\n\n@router.get(\"/profiles\"",
        "import:fastapi.time_spent=activity_data.time_spent",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's profile.\n    \n    Users can only update their own profile.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.favorite_mps=json.dumps([])",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.show_social_features=False",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.updated_at=user.updated_at",
        "import:fastapi.field):\n            setattr(user",
        "import:fastapi.is_verified=user.is_verified",
        "import:fastapi.HTTPException",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a user's preferences.\n    \n    Users can only view their own preferences.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.list):\n                setattr(preferences",
        "import:fastapi.field):\n            if isinstance(value",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.excluded_topics=json.loads(preferences.excluded_topics) if preferences.excluded_topics else []",
        "import:fastapi.third_party_sharing=preferences.third_party_sharing",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.detail=\"Can only update own profile\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.pages_viewed=activity_data.pages_viewed",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.email=user.email",
        "import:fastapi.value)\n    \n    user.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(user)\n    \n    logger.info(f\"User profile updated: {user.username}\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/profiles/{user_id}\"",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.favorite_parties=json.loads(preferences.favorite_parties) if preferences.favorite_parties else []",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.reduced_motion=False\n        )\n        db.add(preferences)\n        db.commit()\n        db.refresh(preferences)\n    \n    return UserPreferencesResponse(\n        id=str(preferences.id)",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get or create preferences\n    preferences = db.query(UserPreferences).filter(UserPreferences.user_id == user_id).first()\n    if not preferences:\n        preferences = UserPreferences(user_id=user_id)\n        db.add(preferences)\n    \n    # Update preferences\n    update_data = preferences_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.detail=\"User not found\")\n    \n    # Verify current password\n    if not verify_password(password_data.current_password",
        "import:fastapi.created_at=user.created_at",
        "import:fastapi.Depends",
        "import:fastapi.keyboard_navigation=True",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.json.dumps(value))\n            else:\n                setattr(preferences",
        "import:fastapi.bio=user.bio",
        "import:fastapi.created_at=preferences.created_at",
        "function:create_user_activity",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.detail=\"Profile is friends-only\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.high_contrast=preferences.high_contrast",
        "import:fastapi.detail=\"Can only create own activity records\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.value)\n    \n    preferences.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(preferences)\n    \n    logger.info(f\"User preferences updated: {user.username}\")\n    \n    return UserPreferencesResponse(\n        id=str(preferences.id)",
        "import:fastapi.activity_sharing=preferences.activity_sharing",
        "import:fastapi.theme_preference=preferences.theme_preference",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Change a user's password.\n    \n    Users can only change their own password.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.response_model=UserPreferencesResponse)\nasync def update_user_preferences(\n    user_id: str = Path(...",
        "import:fastapi.updated_at=preferences.updated_at\n    )\n\n\n# ============================================================================\n# USER ACTIVITY\n# ============================================================================\n\n@router.post(\"/profiles/{user_id}/activity\")\nasync def create_user_activity(\n    user_id: str = Path(...",
        "import:fastapi.language_preference=user.language_preference",
        "import:fastapi.third_party_sharing=False",
        "import:fastapi.data_collection=preferences.data_collection",
        "import:fastapi.is_active=user.is_active",
        "import:fastapi.profile_visibility=\"public\"",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.detail=\"Can only view own preferences\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.browser=activity_data.browser",
        "import:fastapi.last_activity=user.last_activity\n        ))\n    \n    return UserListResponse(\n        users=user_responses",
        "import:fastapi.username=user.username",
        "import:fastapi.website=user.website",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.device=activity_data.device",
        "import:fastapi.show_advanced_features=preferences.show_advanced_features",
        "import:fastapi.value in update_data.items():\n        if hasattr(preferences",
        "import:fastapi.profile_data: UserUpdateRequest = Body(...)",
        "import:fastapi.content_title=activity_data.content_title",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's preferences.\n    \n    Users can only update their own preferences.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.Query",
        "import:fastapi.show_social_features=preferences.show_social_features",
        "import:fastapi.total=total",
        "import:fastapi.theme_preference=\"light\"",
        "import:fastapi.activity_sharing=\"friends_only\"",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.users.username || ' ' || users.full_name || ' ' || COALESCE(users.bio",
        "import:fastapi.UserPreferences",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.is_verified: Optional[bool] = Query(None",
        "import:fastapi.user_id=str(preferences.user_id)",
        "import:fastapi.favorite_parties=json.dumps([])",
        "import:fastapi.favorite_topics=json.dumps([])",
        "import:fastapi.content_difficulty=preferences.content_difficulty",
        "import:fastapi.reduced_motion=preferences.reduced_motion",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all users with pagination and filtering.\n    \n    Requires authentication and appropriate permissions.\n    \"\"\"\n    # Build base query\n    query = db.query(User)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    \n    if is_verified is not None:\n        query = query.filter(User.is_verified == is_verified)\n    \n    # Apply search if provided\n    if search:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a user activity record.\n    \n    Users can only create their own activity records.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.put(\"/profiles/{user_id}\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.postal_code=user.postal_code",
        "import:fastapi.excluded_topics=json.dumps([])",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get or create preferences\n    preferences = db.query(UserPreferences).filter(UserPreferences.user_id == user_id).first()\n    if not preferences:\n        # Create default preferences\n        preferences = UserPreferences(\n            user_id=user_id",
        "import:fastapi.font_size=preferences.font_size",
        "import:fastapi.content_type=activity_data.content_type",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.show_advanced_features=True",
        "import:fastapi.last_login=user.last_login",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.response_model=UserProfileResponse)\nasync def update_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.updated_at=preferences.updated_at\n    )\n\n\n@router.put(\"/profiles/{user_id}/preferences\"",
        "import:fastapi.password_data: PasswordChangeRequest = Body(...)",
        "import:fastapi.phone=user.phone",
        "import:fastapi.activity_date=datetime.utcnow()\n    )\n    \n    db.add(activity)\n    \n    # Update user's last activity\n    user.last_activity = datetime.utcnow()\n    \n    db.commit()\n    db.refresh(activity)\n    \n    logger.info(f\"User activity created: {user.username} - {activity_data.activity_type}\")\n    \n    return {\"message\": \"Activity recorded successfully\"",
        "import:fastapi.content_difficulty=\"intermediate\"",
        "import:fastapi.UserListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.actions_taken=json.dumps(activity_data.actions_taken) if activity_data.actions_taken else None",
        "import:fastapi.detail=\"Profile is private\")\n        elif user.privacy_level == \"friends_only\":\n            # In a real implementation",
        "import:fastapi.location=user.location",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=search))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get users\n    users = query.order_by(User.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    user_responses = []\n    for user in users:\n        user_responses.append(UserProfileResponse(\n            id=str(user.id)",
        "import:fastapi.favorite_mps=json.loads(preferences.favorite_mps) if preferences.favorite_mps else []",
        "import:fastapi.detail=\"User not found\")\n    \n    # Check privacy settings\n    if str(current_user.id) != user_id:\n        if user.privacy_level == \"private\":\n            raise HTTPException(status_code=403",
        "import:fastapi.value in update_data.items():\n        if hasattr(user",
        "import:fastapi.description=\"Filter by verification status\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.timezone=user.timezone",
        "import:fastapi.response_model=UserProfileResponse)\nasync def get_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.post(\"/profiles/{user_id}/change-password\")\nasync def change_user_password(\n    user_id: str = Path(...",
        "import:fastapi.content_summary=activity_data.content_summary",
        "import:fastapi.\"activity_id\": str(activity.id)}",
        "import:fastapi.UserActivity",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific user's profile by ID.\n    \n    Users can only view their own profile or public profiles based on privacy settings.\n    \"\"\"\n    # Check if user exists\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.Body",
        "import:fastapi.activity_type=activity_data.activity_type",
        "import:fastapi.profile_visibility=preferences.profile_visibility",
        "import:fastapi.Dict",
        "import:fastapi.detail=\"User not found\")\n    \n    # Create activity record\n    activity = UserActivity(\n        user_id=user_id",
        "import:fastapi.ip_address=request.client.host if request and request.client else None",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"Current password is incorrect\")\n    \n    # Update password\n    user.hashed_password = hash_password(password_data.new_password)\n    user.updated_at = datetime.utcnow()\n    db.commit()\n    \n    logger.info(f\"Password changed for user: {user.username}\")\n    \n    return {\"message\": \"Password changed successfully\"}\n\n\n# ============================================================================\n# USER PREFERENCES\n# ============================================================================\n\n@router.get(\"/profiles/{user_id}/preferences\"",
        "import:fastapi.show_analytics=True",
        "import:fastapi.detail=\"Can only update own preferences\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.UserSearchResponse",
        "import:fastapi.detail=\"Can only change own password\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404"
      ]
    },
    "GET:/profiles/{user_id}/stats": {
      "method": "GET",
      "path": "/profiles/{user_id}/stats",
      "file": "services/api-gateway/app/api/v1/user_management.py",
      "line": 553,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.page_size=page_size",
        "import:fastapi.activity_date=activity.activity_date",
        "import:fastapi.favorite_topics=json.loads(preferences.favorite_topics) if preferences.favorite_topics else []",
        "import:fastapi.\"activity_id\": str(activity.id)}\n\n\n@router.get(\"/profiles/{user_id}/activity\"",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.content_id=activity_data.content_id",
        "import:fastapi.check if users are friends\n            raise HTTPException(status_code=403",
        "import:fastapi.location=activity_data.location",
        "import:fastapi.high_contrast=False",
        "import:fastapi.UserPreferencesResponse",
        "import:fastapi.screen_reader=False",
        "import:fastapi.preferences_data: UserPreferencesUpdateRequest = Body(...)",
        "import:fastapi.timedelta\nimport math\nimport json\n\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:fastapi.hash_password",
        "import:fastapi.show_analytics=preferences.show_analytics",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.user.hashed_password):\n        raise HTTPException(status_code=400",
        "import:fastapi.request: Request = None",
        "import:fastapi.detail=\"User not found\")\n    \n    # Update profile fields\n    update_data = profile_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.keyboard_navigation=preferences.keyboard_navigation",
        "import:fastapi.ge=1",
        "import:fastapi.avatar_url=user.avatar_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date_to:\n        try:\n            date_to_obj = datetime.strptime(date_to",
        "import:fastapi.device=activity.device",
        "import:fastapi.screen_reader=preferences.screen_reader",
        "import:fastapi.font_size=\"medium\"",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a user's activity history.\n    \n    Users can only view their own activity or public activity based on privacy settings.\n    \"\"\"\n    # Check if user exists\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.le=100",
        "import:fastapi.data_collection=True",
        "import:fastapi.response_model=UserPreferencesResponse)\nasync def get_user_preferences(\n    user_id: str = Path(...",
        "import:fastapi.activity_data: UserActivityCreateRequest = Body(...)",
        "import:fastapi.or_",
        "import:fastapi.OAuthAccount\nfrom app.schemas.user_management import (\n    UserProfileResponse",
        "import:fastapi.verify_password\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# USER PROFILES\n# ============================================================================\n\n@router.get(\"/profiles\"",
        "import:fastapi.time_spent=activity_data.time_spent",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's profile.\n    \n    Users can only update their own profile.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.favorite_mps=json.dumps([])",
        "import:fastapi.user_id=str(activity.user_id)",
        "import:fastapi.ip_address=activity.ip_address",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.show_social_features=False",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.content_summary=activity.content_summary",
        "import:fastapi.updated_at=user.updated_at",
        "import:fastapi.field):\n            setattr(user",
        "import:fastapi.is_verified=user.is_verified",
        "import:fastapi.HTTPException",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a user's preferences.\n    \n    Users can only view their own preferences.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.description=\"Filter by activity type\")",
        "import:fastapi.list):\n                setattr(preferences",
        "import:fastapi.field):\n            if isinstance(value",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.excluded_topics=json.loads(preferences.excluded_topics) if preferences.excluded_topics else []",
        "import:fastapi.third_party_sharing=preferences.third_party_sharing",
        "import:fastapi.description=\"Filter by content type\")",
        "import:fastapi.UserCreateRequest",
        "import:fastapi.content_type: Optional[str] = Query(None",
        "import:fastapi.detail=\"Can only update own profile\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.pages_viewed=activity_data.pages_viewed",
        "import:fastapi.UserActivityListResponse",
        "import:fastapi.email=user.email",
        "import:fastapi.value)\n    \n    user.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(user)\n    \n    logger.info(f\"User profile updated: {user.username}\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.UserStatsResponse",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/profiles/{user_id}\"",
        "import:fastapi.UserUpdateRequest",
        "import:fastapi.related_mps=json.loads(activity.related_mps) if activity.related_mps else []",
        "import:fastapi.favorite_parties=json.loads(preferences.favorite_parties) if preferences.favorite_parties else []",
        "import:fastapi.func",
        "import:fastapi.detail=\"Activity is friends-only\")\n    \n    # Build base query\n    query = db.query(UserActivity).filter(UserActivity.user_id == user_id)\n    \n    # Apply filters\n    if activity_type:\n        query = query.filter(UserActivity.activity_type == activity_type)\n    \n    if content_type:\n        query = query.filter(UserActivity.content_type == content_type)\n    \n    if date_from:\n        try:\n            date_from_obj = datetime.strptime(date_from",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.reduced_motion=False\n        )\n        db.add(preferences)\n        db.commit()\n        db.refresh(preferences)\n    \n    return UserPreferencesResponse(\n        id=str(preferences.id)",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get or create preferences\n    preferences = db.query(UserPreferences).filter(UserPreferences.user_id == user_id).first()\n    if not preferences:\n        preferences = UserPreferences(user_id=user_id)\n        db.add(preferences)\n    \n    # Update preferences\n    update_data = preferences_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.detail=\"User not found\")\n    \n    # Verify current password\n    if not verify_password(password_data.current_password",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(UserActivity.activity_date >= date_from_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.created_at=user.created_at",
        "import:fastapi.Depends",
        "import:fastapi.keyboard_navigation=True",
        "import:fastapi.detail=\"Activity is private\")\n        elif user.privacy_level == \"friends_only\":\n            # In a real implementation",
        "import:fastapi.time_spent=activity.time_spent",
        "function:get_user_activity",
        "import:fastapi.Path",
        "import:fastapi.created_at=activity.created_at\n        ))\n    \n    return UserActivityListResponse(\n        activities=activity_responses",
        "import:fastapi.page=page",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# USER STATISTICS\n# ============================================================================",
        "import:fastapi.json.dumps(value))\n            else:\n                setattr(preferences",
        "import:fastapi.bio=user.bio",
        "import:fastapi.created_at=preferences.created_at",
        "import:fastapi.high_contrast=preferences.high_contrast",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.detail=\"Profile is friends-only\")\n    \n    return UserProfileResponse(\n        id=str(user.id)",
        "import:fastapi.detail=\"Can only create own activity records\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.browser=activity.browser",
        "import:fastapi.value)\n    \n    preferences.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(preferences)\n    \n    logger.info(f\"User preferences updated: {user.username}\")\n    \n    return UserPreferencesResponse(\n        id=str(preferences.id)",
        "import:fastapi.activity_sharing=preferences.activity_sharing",
        "import:fastapi.related_bills=json.loads(activity.related_bills) if activity.related_bills else []",
        "import:fastapi.theme_preference=preferences.theme_preference",
        "import:fastapi.activity_type: Optional[str] = Query(None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Change a user's password.\n    \n    Users can only change their own password.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.response_model=UserPreferencesResponse)\nasync def update_user_preferences(\n    user_id: str = Path(...",
        "import:fastapi.updated_at=preferences.updated_at\n    )\n\n\n# ============================================================================\n# USER ACTIVITY\n# ============================================================================\n\n@router.post(\"/profiles/{user_id}/activity\")\nasync def create_user_activity(\n    user_id: str = Path(...",
        "import:fastapi.language_preference=user.language_preference",
        "import:fastapi.third_party_sharing=False",
        "import:fastapi.data_collection=preferences.data_collection",
        "import:fastapi.response_model=UserActivityListResponse)\nasync def get_user_activity(\n    user_id: str = Path(...",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.is_active=user.is_active",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.profile_visibility=\"public\"",
        "import:fastapi.NotificationPreferencesResponse",
        "import:fastapi.Optional",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.pages_viewed=activity.pages_viewed",
        "import:fastapi.detail=\"Can only view own preferences\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.browser=activity_data.browser",
        "import:fastapi.last_activity=user.last_activity\n        ))\n    \n    return UserListResponse(\n        users=user_responses",
        "import:fastapi.username=user.username",
        "import:fastapi.website=user.website",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.device=activity_data.device",
        "import:fastapi.show_advanced_features=preferences.show_advanced_features",
        "import:fastapi.value in update_data.items():\n        if hasattr(preferences",
        "import:fastapi.profile_data: UserUpdateRequest = Body(...)",
        "import:fastapi.content_title=activity_data.content_title",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a user's preferences.\n    \n    Users can only update their own preferences.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.Query",
        "import:fastapi.show_social_features=preferences.show_social_features",
        "import:fastapi.content_type=activity.content_type",
        "import:fastapi.total=total",
        "import:fastapi.theme_preference=\"light\"",
        "import:fastapi.activity_sharing=\"friends_only\"",
        "import:fastapi.PasswordChangeRequest",
        "import:fastapi.users.username || ' ' || users.full_name || ' ' || COALESCE(users.bio",
        "import:fastapi.UserPreferences",
        "import:fastapi.UserPreferencesUpdateRequest",
        "import:fastapi.is_verified: Optional[bool] = Query(None",
        "import:fastapi.user_id=str(preferences.user_id)",
        "import:fastapi.favorite_parties=json.dumps([])",
        "import:fastapi.activity_type=activity.activity_type",
        "import:fastapi.favorite_topics=json.dumps([])",
        "import:fastapi.content_difficulty=preferences.content_difficulty",
        "import:fastapi.related_committees=json.loads(activity.related_committees) if activity.related_committees else []",
        "import:fastapi.reduced_motion=preferences.reduced_motion",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all users with pagination and filtering.\n    \n    Requires authentication and appropriate permissions.\n    \"\"\"\n    # Build base query\n    query = db.query(User)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(User.is_active == is_active)\n    \n    if is_verified is not None:\n        query = query.filter(User.is_verified == is_verified)\n    \n    # Apply search if provided\n    if search:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.UserActivityResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a user activity record.\n    \n    Users can only create their own activity records.\n    \"\"\"\n    # Check if user exists and is the current user\n    if str(current_user.id) != user_id:\n        raise HTTPException(status_code=403",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(UserActivity.activity_date <= date_to_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.put(\"/profiles/{user_id}\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.postal_code=user.postal_code",
        "import:fastapi.excluded_topics=json.dumps([])",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get or create preferences\n    preferences = db.query(UserPreferences).filter(UserPreferences.user_id == user_id).first()\n    if not preferences:\n        # Create default preferences\n        preferences = UserPreferences(\n            user_id=user_id",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get activities\n    activities = query.order_by(desc(UserActivity.activity_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    activity_responses = []\n    for activity in activities:\n        activity_responses.append(UserActivityResponse(\n            id=str(activity.id)",
        "import:fastapi.font_size=preferences.font_size",
        "import:fastapi.content_type=activity_data.content_type",
        "import:fastapi.UserActivityCreateRequest\n)\nfrom app.api.v1.auth import get_current_user",
        "import:fastapi.show_advanced_features=True",
        "import:fastapi.last_login=user.last_login",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.response_model=UserProfileResponse)\nasync def update_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.updated_at=preferences.updated_at\n    )\n\n\n@router.put(\"/profiles/{user_id}/preferences\"",
        "import:fastapi.password_data: PasswordChangeRequest = Body(...)",
        "import:fastapi.phone=user.phone",
        "import:fastapi.activity_date=datetime.utcnow()\n    )\n    \n    db.add(activity)\n    \n    # Update user's last activity\n    user.last_activity = datetime.utcnow()\n    \n    db.commit()\n    db.refresh(activity)\n    \n    logger.info(f\"User activity created: {user.username} - {activity_data.activity_type}\")\n    \n    return {\"message\": \"Activity recorded successfully\"",
        "import:fastapi.content_difficulty=\"intermediate\"",
        "import:fastapi.UserListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.actions_taken=json.dumps(activity_data.actions_taken) if activity_data.actions_taken else None",
        "import:fastapi.detail=\"Profile is private\")\n        elif user.privacy_level == \"friends_only\":\n            # In a real implementation",
        "import:fastapi.location=user.location",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=search))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get users\n    users = query.order_by(User.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    user_responses = []\n    for user in users:\n        user_responses.append(UserProfileResponse(\n            id=str(user.id)",
        "import:fastapi.location=activity.location",
        "import:fastapi.favorite_mps=json.loads(preferences.favorite_mps) if preferences.favorite_mps else []",
        "import:fastapi.detail=\"User not found\")\n    \n    # Check privacy settings\n    if str(current_user.id) != user_id:\n        if user.privacy_level == \"private\":\n            raise HTTPException(status_code=403",
        "import:fastapi.content_id=activity.content_id",
        "import:fastapi.content_title=activity.content_title",
        "import:fastapi.value in update_data.items():\n        if hasattr(user",
        "import:fastapi.actions_taken=json.loads(activity.actions_taken) if activity.actions_taken else []",
        "import:fastapi.description=\"Filter by verification status\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.timezone=user.timezone",
        "import:fastapi.response_model=UserProfileResponse)\nasync def get_user_profile(\n    user_id: str = Path(...",
        "import:fastapi.last_activity=user.last_activity\n    )\n\n\n@router.post(\"/profiles/{user_id}/change-password\")\nasync def change_user_password(\n    user_id: str = Path(...",
        "import:fastapi.content_summary=activity_data.content_summary",
        "import:fastapi.UserActivity",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific user's profile by ID.\n    \n    Users can only view their own profile or public profiles based on privacy settings.\n    \"\"\"\n    # Check if user exists\n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.Body",
        "import:fastapi.activity_type=activity_data.activity_type",
        "import:fastapi.profile_visibility=preferences.profile_visibility",
        "import:fastapi.Dict",
        "import:fastapi.detail=\"User not found\")\n    \n    # Create activity record\n    activity = UserActivity(\n        user_id=user_id",
        "import:fastapi.ip_address=request.client.host if request and request.client else None",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"Current password is incorrect\")\n    \n    # Update password\n    user.hashed_password = hash_password(password_data.new_password)\n    user.updated_at = datetime.utcnow()\n    db.commit()\n    \n    logger.info(f\"Password changed for user: {user.username}\")\n    \n    return {\"message\": \"Password changed successfully\"}\n\n\n# ============================================================================\n# USER PREFERENCES\n# ============================================================================\n\n@router.get(\"/profiles/{user_id}/preferences\"",
        "import:fastapi.show_analytics=True",
        "import:fastapi.detail=\"Can only update own preferences\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.UserSearchResponse",
        "import:fastapi.detail=\"Can only change own password\")\n    \n    user = db.query(User).filter(User.id == user_id).first()\n    if not user:\n        raise HTTPException(status_code=404"
      ]
    },
    "GET:/search": {
      "method": "GET",
      "path": "/search",
      "file": "services/api-gateway/src/api/v1/feeds.py",
      "line": 227,
      "dependencies": [
        "import:fastapi.link=str(request.url_for('recent_debates_feed'))",
        "import:fastapi.'title': f\"Voted {vote.vote} on {vote.description}\"",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n        \n        # Add items\n        for item in self.items:\n            item_elem = ET.SubElement(channel",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n            ET.SubElement(item_elem",
        "import:fastapi.media_type=\"application/rss+xml\")",
        "import:fastapi.le=100)",
        "import:fastapi.link: str",
        "import:fastapi.'description': f\"Vote #{vote.number}: {vote.description}\"",
        "import:fastapi.'link').text = self.link\n        ET.SubElement(channel",
        "import:fastapi.'title': f\"Said: {statement.topic or 'House statement'}\"",
        "import:fastapi.'lastBuildDate').text = datetime.utcnow().strftime('%a",
        "import:fastapi.mp_slug: str",
        "import:fastapi.%Y') if bill.introduced else 'Unknown'}. \"\n                       f\"Sponsor: {bill.sponsor.name if bill.sponsor else 'Unknown'}\"",
        "import:fastapi.description=activity['description']",
        "import:fastapi.'title').text = self.title\n        ET.SubElement(channel",
        "import:fastapi.Member",
        "import:fastapi.Debate",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"RSS feed for recent debates\"\"\"\n    debates = db.query(Debate).order_by(desc(Debate.date)).limit(limit).all()\n    \n    feed = FeedGenerator(\n        title=\"Recent Debates - OpenParliament.ca\"",
        "import:fastapi.description=\"Recent debates from the House of Commons\"\n    )\n    \n    for debate in debates:\n        feed.add_item(\n            title=debate.h1_en or f\"Debate on {debate.date.strftime('%B %d",
        "import:fastapi.'language').text = 'en-ca'\n        ET.SubElement(channel",
        "import:fastapi.pubdate=activity['date']\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.'link': statement.get_absolute_url()",
        "import:fastapi.pubdate=datetime.combine(debate.date",
        "import:fastapi.Request",
        "import:fastapi.description=f\"Introduced on {bill.introduced.strftime('%B %d",
        "import:fastapi.datetime.min.time())\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.media_type=\"application/rss+xml\")\n\n@router.get(\"/mp/{mp_slug}/activity\")\nasync def mp_activity_feed(\n    request: Request",
        "import:fastapi.'guid').text = item['guid']\n        \n        # Pretty print\n        rough_string = ET.tostring(rss",
        "import:fastapi.description: str",
        "import:fastapi.Committee",
        "import:fastapi.'date': vote.date\n        })\n    \n    # Sort by date and limit\n    activities.sort(key=lambda x: x['date']",
        "import:fastapi.List\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\nfrom sqlalchemy import desc\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    RSS feed for MP statements\n    Direct adaptation of legacy PoliticianStatementFeed\n    \"\"\"\n    # Get MP\n    mp = db.query(Member).filter(Member.slug == mp_slug).first()\n    if not mp:\n        return Response(status_code=404)\n    \n    # Get recent statements\n    statements = db.query(Statement).filter(\n        Statement.member_id == mp.id\n    ).order_by(desc(Statement.time)).limit(limit).all()\n    \n    feed = FeedGenerator(\n        title=f\"Statements by {mp.name} - OpenParliament.ca\"",
        "import:fastapi.link=f\"https://openparliament.ca/politicians/{mp.slug}/\"",
        "import:fastapi.pubdate=statement.time\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.Statement\n\nrouter = APIRouter(prefix=\"/feeds\"",
        "import:fastapi.'date': statement.time\n        })\n    \n    for vote in votes:\n        activities.append({\n            'type': 'vote'",
        "import:fastapi.'guid': guid or link\n        })\n    \n    def generate_rss(self) -> str:\n        \"\"\"Generate RSS 2.0 feed\"\"\"\n        rss = ET.Element('rss'",
        "import:fastapi.tags=[\"feeds\"])\n\nclass FeedGenerator:\n    \"\"\"\n    RSS feed generator based on legacy feed_wrapper pattern\n    \"\"\"\n    def __init__(self",
        "import:fastapi.description=f\"Recent statements in Parliament by {mp.name}\"\n    )\n    \n    for statement in statements:\n        feed.add_item(\n            title=statement.topic or \"House statement\"",
        "import:fastapi.description=statement.text_html()",
        "import:fastapi.media_type=\"application/rss+xml\")\n\n@router.get(\"/mp/{mp_slug}/statements\")\nasync def mp_statements_feed(\n    request: Request",
        "import:fastapi.reverse=True)\n    activities = activities[:limit]\n    \n    # Add to feed\n    for activity in activities:\n        feed.add_item(\n            title=activity['title']",
        "import:fastapi.encoding='str')\n        reparsed = minidom.parseString(rough_string)\n        return reparsed.toprettyxml(indent=\"  \")\n\n@router.get(\"/recent-bills\")\nasync def recent_bills_feed(\n    request: Request",
        "import:fastapi.'channel')\n        \n        # Channel metadata\n        ET.SubElement(channel",
        "import:fastapi.'description': statement.text_html()[:500] + '...'",
        "import:fastapi.Session {debate.session}. \"\n                       f\"{debate.statement_count} statements.\"",
        "import:fastapi.'description': description",
        "import:fastapi.'link': f\"https://openparliament.ca/votes/{vote.id}/\"",
        "import:fastapi.description=\"Recently introduced bills in the Canadian Parliament\"\n    )\n    \n    for bill in bills:\n        feed.add_item(\n            title=f\"Bill {bill.number}: {bill.name}\"",
        "import:fastapi.Query",
        "import:fastapi.'description').text = self.description\n        ET.SubElement(channel",
        "import:fastapi.pubdate=bill.introduced or datetime.utcnow()\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.'link').text = item['link']\n            ET.SubElement(item_elem",
        "import:fastapi.link=statement.get_absolute_url()",
        "import:fastapi.guid: Optional[str] = None):\n        \"\"\"Add an item to the feed\"\"\"\n        self.items.append({\n            'title': title",
        "import:fastapi.'description').text = item['description']\n            ET.SubElement(item_elem",
        "import:fastapi.'pubdate': pubdate",
        "import:fastapi.link=f\"https://openparliament.ca/bills/{bill.session}/{bill.number}/\"",
        "import:fastapi.title: str",
        "import:fastapi.limit: int = Query(20",
        "import:fastapi.link=f\"https://openparliament.ca/debates/{debate.date}/{debate.number}/\"",
        "import:fastapi.link=activity['link']",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    RSS feed for recent bills\n    Based on legacy RSS patterns\n    \"\"\"\n    # Get recent bills\n    bills = db.query(Bill).order_by(desc(Bill.introduced)).limit(limit).all()\n    \n    # Create feed\n    feed = FeedGenerator(\n        title=\"Recent Bills - OpenParliament.ca\"",
        "import:fastapi.link=str(request.url_for('recent_bills_feed'))",
        "import:fastapi.description: str):\n        self.title = title\n        self.link = link\n        self.description = description\n        self.items = []\n    \n    def add_item(self",
        "import:fastapi.'link': link",
        "import:fastapi.Vote",
        "import:fastapi.description=f\"Recent Parliamentary activity by {mp.name}\"\n    )\n    \n    # Get recent statements\n    statements = db.query(Statement).filter(\n        Statement.member_id == mp.id\n    ).order_by(desc(Statement.time)).limit(limit).all()\n    \n    # Get recent votes\n    votes = db.query(Vote).filter(\n        Vote.member_id == mp.id\n    ).order_by(desc(Vote.date)).limit(limit).all()\n    \n    # Combine and sort by date\n    activities = []\n    \n    for statement in statements:\n        activities.append({\n            'type': 'statement'",
        "import:fastapi.description=f\"Parliament {debate.parliament}",
        "import:fastapi.'title').text = item['title']\n            ET.SubElement(item_elem",
        "import:fastapi.media_type=\"application/rss+xml\")\n\n@router.get(\"/recent-debates\")\nasync def recent_debates_feed(\n    request: Request",
        "import:fastapi.version='2.0')\n        channel = ET.SubElement(rss",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    RSS feed for MP activity\n    Based on legacy PoliticianActivityFeed\n    \"\"\"\n    mp = db.query(Member).filter(Member.slug == mp_slug).first()\n    if not mp:\n        return Response(status_code=404)\n    \n    feed = FeedGenerator(\n        title=f\"Activity by {mp.name} - OpenParliament.ca\"",
        "import:fastapi.'pubDate').text = item['pubdate'].strftime('%a",
        "import:fastapi.'item')\n            ET.SubElement(item_elem",
        "import:fastapi.pubdate: datetime",
        "import:fastapi.APIRouter",
        "import:fastapi.%Y')}\"",
        "function:mp_activity_feed"
      ]
    },
    "GET:/status": {
      "method": "GET",
      "path": "/status",
      "file": "services/api-gateway/app/api/v1/websocket.py",
      "line": 423,
      "dependencies": [
        "import:typing.EventPriority.LOW\n            )\n    \n    else:\n        await handle_client_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n    \n    elif message_type == \"get_rooms\":\n        # Send list of rooms the connection is in\n        rooms = list(connection_manager.connection_rooms.get(connection_id",
        "import:typing.\"committees\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.[]))\n        await connection_manager.send_personal_message(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle general client messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"join_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.join_room(connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join debates room\n        connection_manager.join_room(connection_id",
        "import:typing.\"Connected to Bill Updates Service\"",
        "import:typing.\"pong\"",
        "import:typing.message)\n\n\n# REST API endpoints for WebSocket management",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Bill WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/committees\")\nasync def committees_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for committee updates.\n    \n    Automatically joins the 'committees' room for real-time committee notifications.\n    \"\"\"\n    connection_id = f\"committees_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.WebSocketDisconnect",
        "import:typing.data={\"rooms\": rooms}\n            )\n        )\n    \n    else:\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join votes room\n        connection_manager.join_room(connection_id",
        "import:typing.room)\n            await WebSocketService.send_notification(\n                connection_id",
        "import:typing.f\"Unsubscribed from debates for {date}\"",
        "import:typing.\"Connected to Committee Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"leave_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Left room: {room}\"",
        "import:typing.connection_id)\n        \n        # Send welcome message\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.create_notification_event(\n                message=\"\"",
        "import:typing.f\"Unsubscribed from votes for bill {bill_id}\"",
        "function:handle_committee_message",
        "import:typing.EventPriority.HIGH\n                )\n                \n    except Exception as e:\n        logger.error(f\"WebSocket connection error: {e}\")\n    finally:\n        # Clean up connection\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/votes\")\nasync def votes_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for vote updates.\n    \n    Automatically joins the 'votes' room for real-time vote notifications.\n    \"\"\"\n    connection_id = f\"votes_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"Connected to Debate Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.\"Connected to Vote Updates Service\"",
        "import:typing.f\"Subscribed to votes for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_debate_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle debate-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n                )\n            except Exception as e:\n                logger.error(f\"Error handling WebSocket message: {e}\")\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Debate WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/bills\")\nasync def bills_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for bill updates.\n    \n    Automatically joins the 'bills' room for real-time bill notifications.\n    \"\"\"\n    connection_id = f\"bills_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"Connected to Parliamentary Real-time Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Committee WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n# Message Handlers\n\nasync def handle_client_message(connection_id: str",
        "import:typing.f\"Unknown message type: {message_type}\"",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle committee-specific messages\n                await handle_committee_message(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.leave_room(connection_id",
        "import:typing.HTTPException\n\nfrom app.core.websocket import connection_manager",
        "import:typing.create_notification_event\n)\nfrom app.core.redis_service import redis_service",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for committee {committee_id}\"",
        "import:typing.\"votes\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join bills room\n        connection_manager.join_room(connection_id",
        "import:typing.f\"Subscribed to debates for {date}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                logger.info(f\"WebSocket disconnected: {connection_id}\")\n                break\n            except json.JSONDecodeError:\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.f\"Error processing message: {str(e)}\"",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle bill-specific messages\n                await handle_bill_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n\n\nasync def handle_vote_message(connection_id: str",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle vote-specific messages\n                await handle_vote_message(connection_id",
        "import:typing.publish_event\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.websocket(\"/\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    Main WebSocket endpoint for real-time parliamentary data.\n    \n    This endpoint handles:\n    - Connection management\n    - Event broadcasting\n    - Room management\n    - Heartbeat monitoring\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        # Accept the WebSocket connection\n        await connection_manager.connect(websocket",
        "import:typing.Any]):\n    \"\"\"Handle bill-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.Any\nfrom datetime import datetime\nfrom fastapi import APIRouter",
        "import:typing.WebSocketService\nfrom app.core.events import (\n    EventPriority",
        "import:typing.f\"Unsubscribed from updates for bill {bill_id}\"",
        "import:typing.\"debates\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle vote-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.join_room(connection_id",
        "import:typing.message: Dict[str",
        "import:typing.f\"Joined room: {room}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"ping\":\n        # Respond to heartbeat\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Subscribed to updates for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_committee_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle committee-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.Dict",
        "import:typing.\"bills\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.message)\n\n\nasync def handle_bill_message(connection_id: str",
        "import:typing.WebSocket",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Vote WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/debates\")\nasync def debates_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for debate updates.\n    \n    Automatically joins the 'debates' room for real-time debate notifications.\n    \"\"\"\n    connection_id = f\"debates_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.connection_id)\n        \n        # Automatically join committees room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                # Receive message from client\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle different message types\n                await handle_client_message(connection_id",
        "import:typing.\"Invalid JSON message format\"",
        "import:typing.f\"Subscribed to updates for committee {committee_id}\"",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle debate-specific messages\n                await handle_debate_message(connection_id"
      ]
    },
    "POST:/heartbeat/{connection_id}": {
      "method": "POST",
      "path": "/heartbeat/{connection_id}",
      "file": "services/api-gateway/app/api/v1/websocket.py",
      "line": 441,
      "dependencies": [
        "import:typing.EventPriority.LOW\n            )\n    \n    else:\n        await handle_client_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n    \n    elif message_type == \"get_rooms\":\n        # Send list of rooms the connection is in\n        rooms = list(connection_manager.connection_rooms.get(connection_id",
        "import:typing.\"committees\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.[]))\n        await connection_manager.send_personal_message(\n            connection_id",
        "import:typing.\"redis_info\": redis_info",
        "import:typing.Any]):\n    \"\"\"Handle general client messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"join_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.join_room(connection_id",
        "import:typing.detail=\"Failed to get WebSocket status\") from e",
        "import:typing.connection_id)\n        \n        # Automatically join debates room\n        connection_manager.join_room(connection_id",
        "import:typing.\"Connected to Bill Updates Service\"",
        "import:typing.\"pong\"",
        "import:typing.\"timestamp\": datetime.utcnow().isoformat()\n        }\n    except Exception as e:\n        logger.error(f\"Error getting WebSocket status: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Bill WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/committees\")\nasync def committees_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for committee updates.\n    \n    Automatically joins the 'committees' room for real-time committee notifications.\n    \"\"\"\n    connection_id = f\"committees_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.message)\n\n\n# REST API endpoints for WebSocket management\n\n@router.get(\"/status\")\nasync def get_websocket_status():\n    \"\"\"Get WebSocket connection status and statistics.\"\"\"\n    try:\n        stats = connection_manager.get_stats()\n        redis_info = await redis_service.get_redis_info()\n        \n        return {\n            \"status\": \"active\"",
        "import:typing.WebSocketDisconnect",
        "import:typing.data={\"rooms\": rooms}\n            )\n        )\n    \n    else:\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join votes room\n        connection_manager.join_room(connection_id",
        "import:typing.room)\n            await WebSocketService.send_notification(\n                connection_id",
        "import:typing.f\"Unsubscribed from debates for {date}\"",
        "import:typing.\"Connected to Committee Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"leave_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Left room: {room}\"",
        "import:typing.connection_id)\n        \n        # Send welcome message\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.create_notification_event(\n                message=\"\"",
        "import:typing.f\"Unsubscribed from votes for bill {bill_id}\"",
        "import:typing.\"Connected to Debate Updates Service\"",
        "import:typing.EventPriority.HIGH\n                )\n                \n    except Exception as e:\n        logger.error(f\"WebSocket connection error: {e}\")\n    finally:\n        # Clean up connection\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/votes\")\nasync def votes_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for vote updates.\n    \n    Automatically joins the 'votes' room for real-time vote notifications.\n    \"\"\"\n    connection_id = f\"votes_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.\"Connected to Vote Updates Service\"",
        "import:typing.f\"Subscribed to votes for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_debate_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle debate-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n                )\n            except Exception as e:\n                logger.error(f\"Error handling WebSocket message: {e}\")\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Debate WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/bills\")\nasync def bills_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for bill updates.\n    \n    Automatically joins the 'bills' room for real-time bill notifications.\n    \"\"\"\n    connection_id = f\"bills_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"websocket_stats\": stats",
        "import:typing.\"Connected to Parliamentary Real-time Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Committee WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n# Message Handlers\n\nasync def handle_client_message(connection_id: str",
        "import:typing.f\"Unknown message type: {message_type}\"",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle committee-specific messages\n                await handle_committee_message(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.leave_room(connection_id",
        "import:typing.HTTPException\n\nfrom app.core.websocket import connection_manager",
        "import:typing.create_notification_event\n)\nfrom app.core.redis_service import redis_service",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for committee {committee_id}\"",
        "import:typing.\"votes\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join bills room\n        connection_manager.join_room(connection_id",
        "import:typing.f\"Subscribed to debates for {date}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                logger.info(f\"WebSocket disconnected: {connection_id}\")\n                break\n            except json.JSONDecodeError:\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.f\"Error processing message: {str(e)}\"",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle bill-specific messages\n                await handle_bill_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n\n\nasync def handle_vote_message(connection_id: str",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle vote-specific messages\n                await handle_vote_message(connection_id",
        "import:typing.publish_event\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.websocket(\"/\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    Main WebSocket endpoint for real-time parliamentary data.\n    \n    This endpoint handles:\n    - Connection management\n    - Event broadcasting\n    - Room management\n    - Heartbeat monitoring\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        # Accept the WebSocket connection\n        await connection_manager.connect(websocket",
        "import:typing.Any]):\n    \"\"\"Handle bill-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.Any\nfrom datetime import datetime\nfrom fastapi import APIRouter",
        "function:get_websocket_status",
        "import:typing.WebSocketService\nfrom app.core.events import (\n    EventPriority",
        "import:typing.\"debates\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle vote-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.join_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for bill {bill_id}\"",
        "import:typing.message: Dict[str",
        "import:typing.f\"Joined room: {room}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"ping\":\n        # Respond to heartbeat\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Subscribed to updates for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_committee_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle committee-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.Dict",
        "import:typing.\"bills\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.message)\n\n\nasync def handle_bill_message(connection_id: str",
        "import:typing.WebSocket",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Vote WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/debates\")\nasync def debates_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for debate updates.\n    \n    Automatically joins the 'debates' room for real-time debate notifications.\n    \"\"\"\n    connection_id = f\"debates_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.connection_id)\n        \n        # Automatically join committees room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                # Receive message from client\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle different message types\n                await handle_client_message(connection_id",
        "import:typing.\"Invalid JSON message format\"",
        "import:typing.f\"Subscribed to updates for committee {committee_id}\"",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle debate-specific messages\n                await handle_debate_message(connection_id"
      ]
    },
    "GET:/health/{connection_id}": {
      "method": "GET",
      "path": "/health/{connection_id}",
      "file": "services/api-gateway/app/api/v1/websocket.py",
      "line": 452,
      "dependencies": [
        "import:typing.EventPriority.LOW\n        )\n    \n    elif message_type == \"get_rooms\":\n        # Send list of rooms the connection is in\n        rooms = list(connection_manager.connection_rooms.get(connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join debates room\n        connection_manager.join_room(connection_id",
        "import:typing.WebSocketDisconnect",
        "import:typing.connection_id)\n        \n        # Send welcome message\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"Connected to Debate Updates Service\"",
        "import:typing.Any]):\n    \"\"\"Handle debate-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n                )\n            except Exception as e:\n                logger.error(f\"Error handling WebSocket message: {e}\")\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Debate WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/bills\")\nasync def bills_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for bill updates.\n    \n    Automatically joins the 'bills' room for real-time bill notifications.\n    \"\"\"\n    connection_id = f\"bills_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"votes\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Subscribed to debates for {date}\"",
        "import:typing.f\"Error processing message: {str(e)}\"",
        "import:typing.\"debates\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle vote-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.join_room(connection_id",
        "import:typing.f\"Joined room: {room}\"",
        "import:typing.detail=\"Failed to update heartbeat\") from e",
        "import:typing.Dict",
        "import:typing.message)\n\n\nasync def handle_bill_message(connection_id: str",
        "import:typing.room)\n            await WebSocketService.send_notification(\n                connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                # Receive message from client\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle different message types\n                await handle_client_message(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    else:\n        await handle_client_message(connection_id",
        "import:typing.\"committees\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.[]))\n        await connection_manager.send_personal_message(\n            connection_id",
        "import:typing.\"Connected to Bill Updates Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Bill WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/committees\")\nasync def committees_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for committee updates.\n    \n    Automatically joins the 'committees' room for real-time committee notifications.\n    \"\"\"\n    connection_id = f\"committees_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.detail=\"Failed to get WebSocket status\") from e\n\n\n@router.post(\"/heartbeat/{connection_id}\")\nasync def update_connection_heartbeat(connection_id: str):\n    \"\"\"Update heartbeat for a specific WebSocket connection.\"\"\"\n    try:\n        connection_manager.update_heartbeat(connection_id)\n        return {\"status\": \"success\"",
        "import:typing.f\"Unsubscribed from debates for {date}\"",
        "import:typing.connection_id)\n        \n        # Automatically join votes room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.HIGH\n                )\n                \n    except Exception as e:\n        logger.error(f\"WebSocket connection error: {e}\")\n    finally:\n        # Clean up connection\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/votes\")\nasync def votes_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for vote updates.\n    \n    Automatically joins the 'votes' room for real-time vote notifications.\n    \"\"\"\n    connection_id = f\"votes_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.f\"Unknown message type: {message_type}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.leave_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle bill-specific messages\n                await handle_bill_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n\n\nasync def handle_vote_message(connection_id: str",
        "import:typing.publish_event\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.websocket(\"/\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    Main WebSocket endpoint for real-time parliamentary data.\n    \n    This endpoint handles:\n    - Connection management\n    - Event broadcasting\n    - Room management\n    - Heartbeat monitoring\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        # Accept the WebSocket connection\n        await connection_manager.connect(websocket",
        "import:typing.Any]):\n    \"\"\"Handle bill-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"ping\":\n        # Respond to heartbeat\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"bills\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.WebSocket",
        "import:typing.\"Invalid JSON message format\"",
        "import:typing.\"redis_info\": redis_info",
        "import:typing.f\"Subscribed to updates for committee {committee_id}\"",
        "import:typing.Any]):\n    \"\"\"Handle general client messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"join_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.join_room(connection_id",
        "import:typing.\"pong\"",
        "import:typing.message)\n\n\n# REST API endpoints for WebSocket management\n\n@router.get(\"/status\")\nasync def get_websocket_status():\n    \"\"\"Get WebSocket connection status and statistics.\"\"\"\n    try:\n        stats = connection_manager.get_stats()\n        redis_info = await redis_service.get_redis_info()\n        \n        return {\n            \"status\": \"active\"",
        "function:update_connection_heartbeat",
        "import:typing.\"Connected to Committee Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"leave_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.leave_room(connection_id",
        "import:typing.create_notification_event(\n                message=\"\"",
        "import:typing.f\"Unsubscribed from votes for bill {bill_id}\"",
        "import:typing.\"Connected to Vote Updates Service\"",
        "import:typing.\"websocket_stats\": stats",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle committee-specific messages\n                await handle_committee_message(connection_id",
        "import:typing.\"message\": \"Heartbeat updated\"}\n    except Exception as e:\n        logger.error(f\"Error updating heartbeat: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.HTTPException\n\nfrom app.core.websocket import connection_manager",
        "import:typing.create_notification_event\n)\nfrom app.core.redis_service import redis_service",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for committee {committee_id}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                logger.info(f\"WebSocket disconnected: {connection_id}\")\n                break\n            except json.JSONDecodeError:\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle vote-specific messages\n                await handle_vote_message(connection_id",
        "import:typing.Any\nfrom datetime import datetime\nfrom fastapi import APIRouter",
        "import:typing.WebSocketService\nfrom app.core.events import (\n    EventPriority",
        "import:typing.f\"Subscribed to updates for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_committee_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle committee-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.\"timestamp\": datetime.utcnow().isoformat()\n        }\n    except Exception as e:\n        logger.error(f\"Error getting WebSocket status: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.data={\"rooms\": rooms}\n            )\n        )\n    \n    else:\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Left room: {room}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Subscribed to votes for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_debate_message(connection_id: str",
        "import:typing.\"Connected to Parliamentary Real-time Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Committee WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n# Message Handlers\n\nasync def handle_client_message(connection_id: str",
        "import:typing.connection_id)\n        \n        # Automatically join bills room\n        connection_manager.join_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for bill {bill_id}\"",
        "import:typing.message: Dict[str",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Vote WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/debates\")\nasync def debates_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for debate updates.\n    \n    Automatically joins the 'debates' room for real-time debate notifications.\n    \"\"\"\n    connection_id = f\"debates_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.connection_id)\n        \n        # Automatically join committees room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle debate-specific messages\n                await handle_debate_message(connection_id"
      ]
    },
    "POST:/cleanup": {
      "method": "POST",
      "path": "/cleanup",
      "file": "services/api-gateway/app/api/v1/websocket.py",
      "line": 463,
      "dependencies": [
        "import:typing.EventPriority.LOW\n        )\n    \n    elif message_type == \"get_rooms\":\n        # Send list of rooms the connection is in\n        rooms = list(connection_manager.connection_rooms.get(connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join debates room\n        connection_manager.join_room(connection_id",
        "import:typing.WebSocketDisconnect",
        "import:typing.connection_id)\n        \n        # Send welcome message\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"Connected to Debate Updates Service\"",
        "import:typing.Any]):\n    \"\"\"Handle debate-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n                )\n            except Exception as e:\n                logger.error(f\"Error handling WebSocket message: {e}\")\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Debate WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/bills\")\nasync def bills_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for bill updates.\n    \n    Automatically joins the 'bills' room for real-time bill notifications.\n    \"\"\"\n    connection_id = f\"bills_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"votes\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Subscribed to debates for {date}\"",
        "import:typing.f\"Error processing message: {str(e)}\"",
        "import:typing.\"debates\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle vote-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.join_room(connection_id",
        "import:typing.f\"Joined room: {room}\"",
        "import:typing.Dict",
        "import:typing.message)\n\n\nasync def handle_bill_message(connection_id: str",
        "import:typing.room)\n            await WebSocketService.send_notification(\n                connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                # Receive message from client\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle different message types\n                await handle_client_message(connection_id",
        "import:typing.detail=\"Failed to update heartbeat\") from e\n\n\n@router.get(\"/health/{connection_id}\")\nasync def get_connection_health(connection_id: str):\n    \"\"\"Get health information for a specific WebSocket connection.\"\"\"\n    try:\n        health_info = connection_manager.get_connection_health(connection_id)\n        return health_info\n    except Exception as e:\n        logger.error(f\"Error getting connection health: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.EventPriority.LOW\n            )\n    \n    else:\n        await handle_client_message(connection_id",
        "import:typing.\"committees\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.[]))\n        await connection_manager.send_personal_message(\n            connection_id",
        "import:typing.\"Connected to Bill Updates Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Bill WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/committees\")\nasync def committees_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for committee updates.\n    \n    Automatically joins the 'committees' room for real-time committee notifications.\n    \"\"\"\n    connection_id = f\"committees_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.detail=\"Failed to get WebSocket status\") from e\n\n\n@router.post(\"/heartbeat/{connection_id}\")\nasync def update_connection_heartbeat(connection_id: str):\n    \"\"\"Update heartbeat for a specific WebSocket connection.\"\"\"\n    try:\n        connection_manager.update_heartbeat(connection_id)\n        return {\"status\": \"success\"",
        "import:typing.f\"Unsubscribed from debates for {date}\"",
        "import:typing.connection_id)\n        \n        # Automatically join votes room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.HIGH\n                )\n                \n    except Exception as e:\n        logger.error(f\"WebSocket connection error: {e}\")\n    finally:\n        # Clean up connection\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/votes\")\nasync def votes_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for vote updates.\n    \n    Automatically joins the 'votes' room for real-time vote notifications.\n    \"\"\"\n    connection_id = f\"votes_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.f\"Unknown message type: {message_type}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.leave_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle bill-specific messages\n                await handle_bill_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n\n\nasync def handle_vote_message(connection_id: str",
        "import:typing.publish_event\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.websocket(\"/\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    Main WebSocket endpoint for real-time parliamentary data.\n    \n    This endpoint handles:\n    - Connection management\n    - Event broadcasting\n    - Room management\n    - Heartbeat monitoring\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        # Accept the WebSocket connection\n        await connection_manager.connect(websocket",
        "import:typing.Any]):\n    \"\"\"Handle bill-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"ping\":\n        # Respond to heartbeat\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"bills\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.WebSocket",
        "import:typing.\"Invalid JSON message format\"",
        "import:typing.\"redis_info\": redis_info",
        "import:typing.f\"Subscribed to updates for committee {committee_id}\"",
        "import:typing.detail=\"Failed to get connection health\") from e",
        "import:typing.Any]):\n    \"\"\"Handle general client messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"join_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.join_room(connection_id",
        "import:typing.\"pong\"",
        "import:typing.message)\n\n\n# REST API endpoints for WebSocket management\n\n@router.get(\"/status\")\nasync def get_websocket_status():\n    \"\"\"Get WebSocket connection status and statistics.\"\"\"\n    try:\n        stats = connection_manager.get_stats()\n        redis_info = await redis_service.get_redis_info()\n        \n        return {\n            \"status\": \"active\"",
        "import:typing.\"Connected to Committee Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"leave_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.leave_room(connection_id",
        "import:typing.create_notification_event(\n                message=\"\"",
        "import:typing.f\"Unsubscribed from votes for bill {bill_id}\"",
        "import:typing.\"Connected to Vote Updates Service\"",
        "import:typing.\"websocket_stats\": stats",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle committee-specific messages\n                await handle_committee_message(connection_id",
        "import:typing.\"message\": \"Heartbeat updated\"}\n    except Exception as e:\n        logger.error(f\"Error updating heartbeat: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.HTTPException\n\nfrom app.core.websocket import connection_manager",
        "import:typing.create_notification_event\n)\nfrom app.core.redis_service import redis_service",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for committee {committee_id}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                logger.info(f\"WebSocket disconnected: {connection_id}\")\n                break\n            except json.JSONDecodeError:\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle vote-specific messages\n                await handle_vote_message(connection_id",
        "import:typing.Any\nfrom datetime import datetime\nfrom fastapi import APIRouter",
        "import:typing.WebSocketService\nfrom app.core.events import (\n    EventPriority",
        "import:typing.f\"Subscribed to updates for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_committee_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle committee-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.\"timestamp\": datetime.utcnow().isoformat()\n        }\n    except Exception as e:\n        logger.error(f\"Error getting WebSocket status: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.data={\"rooms\": rooms}\n            )\n        )\n    \n    else:\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Left room: {room}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Subscribed to votes for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_debate_message(connection_id: str",
        "import:typing.\"Connected to Parliamentary Real-time Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Committee WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n# Message Handlers\n\nasync def handle_client_message(connection_id: str",
        "import:typing.connection_id)\n        \n        # Automatically join bills room\n        connection_manager.join_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for bill {bill_id}\"",
        "import:typing.message: Dict[str",
        "function:get_connection_health",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Vote WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/debates\")\nasync def debates_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for debate updates.\n    \n    Automatically joins the 'debates' room for real-time debate notifications.\n    \"\"\"\n    connection_id = f\"debates_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.connection_id)\n        \n        # Automatically join committees room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle debate-specific messages\n                await handle_debate_message(connection_id"
      ]
    },
    "GET:/connections/{connection_id}": {
      "method": "GET",
      "path": "/connections/{connection_id}",
      "file": "services/api-gateway/app/api/v1/websocket.py",
      "line": 474,
      "dependencies": [
        "import:typing.EventPriority.LOW\n        )\n    \n    elif message_type == \"get_rooms\":\n        # Send list of rooms the connection is in\n        rooms = list(connection_manager.connection_rooms.get(connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join debates room\n        connection_manager.join_room(connection_id",
        "import:typing.WebSocketDisconnect",
        "import:typing.connection_id)\n        \n        # Send welcome message\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"Connected to Debate Updates Service\"",
        "import:typing.Any]):\n    \"\"\"Handle debate-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n                )\n            except Exception as e:\n                logger.error(f\"Error handling WebSocket message: {e}\")\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Debate WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/bills\")\nasync def bills_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for bill updates.\n    \n    Automatically joins the 'bills' room for real-time bill notifications.\n    \"\"\"\n    connection_id = f\"bills_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"votes\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Subscribed to debates for {date}\"",
        "import:typing.f\"Error processing message: {str(e)}\"",
        "import:typing.\"debates\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle vote-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.join_room(connection_id",
        "import:typing.f\"Joined room: {room}\"",
        "import:typing.Dict",
        "import:typing.message)\n\n\nasync def handle_bill_message(connection_id: str",
        "import:typing.room)\n            await WebSocketService.send_notification(\n                connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                # Receive message from client\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle different message types\n                await handle_client_message(connection_id",
        "import:typing.detail=\"Failed to update heartbeat\") from e\n\n\n@router.get(\"/health/{connection_id}\")\nasync def get_connection_health(connection_id: str):\n    \"\"\"Get health information for a specific WebSocket connection.\"\"\"\n    try:\n        health_info = connection_manager.get_connection_health(connection_id)\n        return health_info\n    except Exception as e:\n        logger.error(f\"Error getting connection health: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.EventPriority.LOW\n            )\n    \n    else:\n        await handle_client_message(connection_id",
        "import:typing.\"committees\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.[]))\n        await connection_manager.send_personal_message(\n            connection_id",
        "import:typing.\"Connected to Bill Updates Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Bill WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/committees\")\nasync def committees_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for committee updates.\n    \n    Automatically joins the 'committees' room for real-time committee notifications.\n    \"\"\"\n    connection_id = f\"committees_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.detail=\"Failed to get WebSocket status\") from e\n\n\n@router.post(\"/heartbeat/{connection_id}\")\nasync def update_connection_heartbeat(connection_id: str):\n    \"\"\"Update heartbeat for a specific WebSocket connection.\"\"\"\n    try:\n        connection_manager.update_heartbeat(connection_id)\n        return {\"status\": \"success\"",
        "import:typing.f\"Unsubscribed from debates for {date}\"",
        "import:typing.connection_id)\n        \n        # Automatically join votes room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.HIGH\n                )\n                \n    except Exception as e:\n        logger.error(f\"WebSocket connection error: {e}\")\n    finally:\n        # Clean up connection\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/votes\")\nasync def votes_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for vote updates.\n    \n    Automatically joins the 'votes' room for real-time vote notifications.\n    \"\"\"\n    connection_id = f\"votes_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.f\"Unknown message type: {message_type}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.leave_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle bill-specific messages\n                await handle_bill_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n\n\nasync def handle_vote_message(connection_id: str",
        "import:typing.publish_event\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.websocket(\"/\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    Main WebSocket endpoint for real-time parliamentary data.\n    \n    This endpoint handles:\n    - Connection management\n    - Event broadcasting\n    - Room management\n    - Heartbeat monitoring\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        # Accept the WebSocket connection\n        await connection_manager.connect(websocket",
        "import:typing.Any]):\n    \"\"\"Handle bill-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"ping\":\n        # Respond to heartbeat\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"bills\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.detail=\"Failed to cleanup connections\") from e",
        "import:typing.WebSocket",
        "import:typing.\"Invalid JSON message format\"",
        "import:typing.\"redis_info\": redis_info",
        "import:typing.f\"Subscribed to updates for committee {committee_id}\"",
        "import:typing.Any]):\n    \"\"\"Handle general client messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"join_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.join_room(connection_id",
        "import:typing.\"pong\"",
        "import:typing.message)\n\n\n# REST API endpoints for WebSocket management\n\n@router.get(\"/status\")\nasync def get_websocket_status():\n    \"\"\"Get WebSocket connection status and statistics.\"\"\"\n    try:\n        stats = connection_manager.get_stats()\n        redis_info = await redis_service.get_redis_info()\n        \n        return {\n            \"status\": \"active\"",
        "import:typing.\"Connected to Committee Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"leave_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.leave_room(connection_id",
        "import:typing.create_notification_event(\n                message=\"\"",
        "import:typing.f\"Unsubscribed from votes for bill {bill_id}\"",
        "import:typing.\"Connected to Vote Updates Service\"",
        "import:typing.\"websocket_stats\": stats",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle committee-specific messages\n                await handle_committee_message(connection_id",
        "import:typing.\"message\": \"Heartbeat updated\"}\n    except Exception as e:\n        logger.error(f\"Error updating heartbeat: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.HTTPException\n\nfrom app.core.websocket import connection_manager",
        "import:typing.create_notification_event\n)\nfrom app.core.redis_service import redis_service",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for committee {committee_id}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                logger.info(f\"WebSocket disconnected: {connection_id}\")\n                break\n            except json.JSONDecodeError:\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle vote-specific messages\n                await handle_vote_message(connection_id",
        "import:typing.Any\nfrom datetime import datetime\nfrom fastapi import APIRouter",
        "import:typing.WebSocketService\nfrom app.core.events import (\n    EventPriority",
        "import:typing.f\"Subscribed to updates for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_committee_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle committee-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.\"cleaned_connections\": cleaned_count}\n    except Exception as e:\n        logger.error(f\"Error cleaning up connections: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.\"timestamp\": datetime.utcnow().isoformat()\n        }\n    except Exception as e:\n        logger.error(f\"Error getting WebSocket status: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.data={\"rooms\": rooms}\n            )\n        )\n    \n    else:\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.detail=\"Failed to get connection health\") from e\n\n\n@router.post(\"/cleanup\")\nasync def cleanup_idle_connections():\n    \"\"\"Clean up idle WebSocket connections.\"\"\"\n    try:\n        cleaned_count = connection_manager.cleanup_idle_connections()\n        return {\"status\": \"success\"",
        "import:typing.f\"Left room: {room}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Subscribed to votes for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_debate_message(connection_id: str",
        "import:typing.\"Connected to Parliamentary Real-time Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Committee WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n# Message Handlers\n\nasync def handle_client_message(connection_id: str",
        "function:cleanup_idle_connections",
        "import:typing.connection_id)\n        \n        # Automatically join bills room\n        connection_manager.join_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for bill {bill_id}\"",
        "import:typing.message: Dict[str",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Vote WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/debates\")\nasync def debates_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for debate updates.\n    \n    Automatically joins the 'debates' room for real-time debate notifications.\n    \"\"\"\n    connection_id = f\"debates_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.connection_id)\n        \n        # Automatically join committees room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle debate-specific messages\n                await handle_debate_message(connection_id"
      ]
    },
    "GET:/rooms/{room}": {
      "method": "GET",
      "path": "/rooms/{room}",
      "file": "services/api-gateway/app/api/v1/websocket.py",
      "line": 484,
      "dependencies": [
        "import:typing.EventPriority.LOW\n        )\n    \n    elif message_type == \"get_rooms\":\n        # Send list of rooms the connection is in\n        rooms = list(connection_manager.connection_rooms.get(connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join debates room\n        connection_manager.join_room(connection_id",
        "import:typing.WebSocketDisconnect",
        "import:typing.connection_id)\n        \n        # Send welcome message\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"Connected to Debate Updates Service\"",
        "import:typing.Any]):\n    \"\"\"Handle debate-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n                )\n            except Exception as e:\n                logger.error(f\"Error handling WebSocket message: {e}\")\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Debate WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/bills\")\nasync def bills_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for bill updates.\n    \n    Automatically joins the 'bills' room for real-time bill notifications.\n    \"\"\"\n    connection_id = f\"bills_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"votes\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Subscribed to debates for {date}\"",
        "import:typing.f\"Error processing message: {str(e)}\"",
        "import:typing.\"debates\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle vote-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.join_room(connection_id",
        "import:typing.f\"Joined room: {room}\"",
        "import:typing.Dict",
        "import:typing.message)\n\n\nasync def handle_bill_message(connection_id: str",
        "import:typing.detail=\"Failed to cleanup connections\") from e\n\n\n@router.get(\"/connections/{connection_id}\")\nasync def get_connection_info(connection_id: str):\n    \"\"\"Get information about a specific WebSocket connection.\"\"\"\n    info = connection_manager.get_connection_info(connection_id)\n    if not info:\n        raise HTTPException(status_code=404",
        "import:typing.room)\n            await WebSocketService.send_notification(\n                connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                # Receive message from client\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle different message types\n                await handle_client_message(connection_id",
        "import:typing.detail=\"Failed to update heartbeat\") from e\n\n\n@router.get(\"/health/{connection_id}\")\nasync def get_connection_health(connection_id: str):\n    \"\"\"Get health information for a specific WebSocket connection.\"\"\"\n    try:\n        health_info = connection_manager.get_connection_health(connection_id)\n        return health_info\n    except Exception as e:\n        logger.error(f\"Error getting connection health: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.EventPriority.LOW\n            )\n    \n    else:\n        await handle_client_message(connection_id",
        "import:typing.\"committees\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.[]))\n        await connection_manager.send_personal_message(\n            connection_id",
        "import:typing.\"Connected to Bill Updates Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Bill WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/committees\")\nasync def committees_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for committee updates.\n    \n    Automatically joins the 'committees' room for real-time committee notifications.\n    \"\"\"\n    connection_id = f\"committees_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.detail=\"Failed to get WebSocket status\") from e\n\n\n@router.post(\"/heartbeat/{connection_id}\")\nasync def update_connection_heartbeat(connection_id: str):\n    \"\"\"Update heartbeat for a specific WebSocket connection.\"\"\"\n    try:\n        connection_manager.update_heartbeat(connection_id)\n        return {\"status\": \"success\"",
        "import:typing.f\"Unsubscribed from debates for {date}\"",
        "import:typing.connection_id)\n        \n        # Automatically join votes room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.HIGH\n                )\n                \n    except Exception as e:\n        logger.error(f\"WebSocket connection error: {e}\")\n    finally:\n        # Clean up connection\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/votes\")\nasync def votes_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for vote updates.\n    \n    Automatically joins the 'votes' room for real-time vote notifications.\n    \"\"\"\n    connection_id = f\"votes_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.f\"Unknown message type: {message_type}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.leave_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle bill-specific messages\n                await handle_bill_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n\n\nasync def handle_vote_message(connection_id: str",
        "import:typing.publish_event\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.websocket(\"/\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    Main WebSocket endpoint for real-time parliamentary data.\n    \n    This endpoint handles:\n    - Connection management\n    - Event broadcasting\n    - Room management\n    - Heartbeat monitoring\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        # Accept the WebSocket connection\n        await connection_manager.connect(websocket",
        "import:typing.Any]):\n    \"\"\"Handle bill-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"ping\":\n        # Respond to heartbeat\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"bills\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.WebSocket",
        "import:typing.\"Invalid JSON message format\"",
        "import:typing.\"redis_info\": redis_info",
        "import:typing.f\"Subscribed to updates for committee {committee_id}\"",
        "import:typing.Any]):\n    \"\"\"Handle general client messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"join_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.join_room(connection_id",
        "import:typing.\"pong\"",
        "import:typing.message)\n\n\n# REST API endpoints for WebSocket management\n\n@router.get(\"/status\")\nasync def get_websocket_status():\n    \"\"\"Get WebSocket connection status and statistics.\"\"\"\n    try:\n        stats = connection_manager.get_stats()\n        redis_info = await redis_service.get_redis_info()\n        \n        return {\n            \"status\": \"active\"",
        "function:get_connection_info",
        "import:typing.\"Connected to Committee Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"leave_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.leave_room(connection_id",
        "import:typing.create_notification_event(\n                message=\"\"",
        "import:typing.f\"Unsubscribed from votes for bill {bill_id}\"",
        "import:typing.\"Connected to Vote Updates Service\"",
        "import:typing.\"websocket_stats\": stats",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle committee-specific messages\n                await handle_committee_message(connection_id",
        "import:typing.\"message\": \"Heartbeat updated\"}\n    except Exception as e:\n        logger.error(f\"Error updating heartbeat: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.HTTPException\n\nfrom app.core.websocket import connection_manager",
        "import:typing.create_notification_event\n)\nfrom app.core.redis_service import redis_service",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for committee {committee_id}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                logger.info(f\"WebSocket disconnected: {connection_id}\")\n                break\n            except json.JSONDecodeError:\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle vote-specific messages\n                await handle_vote_message(connection_id",
        "import:typing.Any\nfrom datetime import datetime\nfrom fastapi import APIRouter",
        "import:typing.WebSocketService\nfrom app.core.events import (\n    EventPriority",
        "import:typing.f\"Subscribed to updates for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_committee_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle committee-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.\"cleaned_connections\": cleaned_count}\n    except Exception as e:\n        logger.error(f\"Error cleaning up connections: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.\"timestamp\": datetime.utcnow().isoformat()\n        }\n    except Exception as e:\n        logger.error(f\"Error getting WebSocket status: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.data={\"rooms\": rooms}\n            )\n        )\n    \n    else:\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.detail=\"Failed to get connection health\") from e\n\n\n@router.post(\"/cleanup\")\nasync def cleanup_idle_connections():\n    \"\"\"Clean up idle WebSocket connections.\"\"\"\n    try:\n        cleaned_count = connection_manager.cleanup_idle_connections()\n        return {\"status\": \"success\"",
        "import:typing.f\"Left room: {room}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Subscribed to votes for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_debate_message(connection_id: str",
        "import:typing.\"Connected to Parliamentary Real-time Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Committee WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n# Message Handlers\n\nasync def handle_client_message(connection_id: str",
        "import:typing.connection_id)\n        \n        # Automatically join bills room\n        connection_manager.join_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for bill {bill_id}\"",
        "import:typing.message: Dict[str",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Vote WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/debates\")\nasync def debates_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for debate updates.\n    \n    Automatically joins the 'debates' room for real-time debate notifications.\n    \"\"\"\n    connection_id = f\"debates_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.connection_id)\n        \n        # Automatically join committees room\n        connection_manager.join_room(connection_id",
        "import:typing.detail=\"Connection not found\")\n    \n    return info",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle debate-specific messages\n                await handle_debate_message(connection_id"
      ]
    },
    "POST:/broadcast": {
      "method": "POST",
      "path": "/broadcast",
      "file": "services/api-gateway/app/api/v1/websocket.py",
      "line": 491,
      "dependencies": [
        "import:typing.EventPriority.LOW\n        )\n    \n    elif message_type == \"get_rooms\":\n        # Send list of rooms the connection is in\n        rooms = list(connection_manager.connection_rooms.get(connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join debates room\n        connection_manager.join_room(connection_id",
        "import:typing.WebSocketDisconnect",
        "import:typing.connection_id)\n        \n        # Send welcome message\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"Connected to Debate Updates Service\"",
        "import:typing.Any]):\n    \"\"\"Handle debate-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n                )\n            except Exception as e:\n                logger.error(f\"Error handling WebSocket message: {e}\")\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Debate WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/bills\")\nasync def bills_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for bill updates.\n    \n    Automatically joins the 'bills' room for real-time bill notifications.\n    \"\"\"\n    connection_id = f\"bills_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"votes\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Subscribed to debates for {date}\"",
        "import:typing.f\"Error processing message: {str(e)}\"",
        "import:typing.\"debates\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle vote-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.join_room(connection_id",
        "import:typing.f\"Joined room: {room}\"",
        "import:typing.Dict",
        "import:typing.message)\n\n\nasync def handle_bill_message(connection_id: str",
        "import:typing.detail=\"Failed to cleanup connections\") from e\n\n\n@router.get(\"/connections/{connection_id}\")\nasync def get_connection_info(connection_id: str):\n    \"\"\"Get information about a specific WebSocket connection.\"\"\"\n    info = connection_manager.get_connection_info(connection_id)\n    if not info:\n        raise HTTPException(status_code=404",
        "import:typing.room)\n            await WebSocketService.send_notification(\n                connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                # Receive message from client\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle different message types\n                await handle_client_message(connection_id",
        "import:typing.detail=\"Failed to update heartbeat\") from e\n\n\n@router.get(\"/health/{connection_id}\")\nasync def get_connection_health(connection_id: str):\n    \"\"\"Get health information for a specific WebSocket connection.\"\"\"\n    try:\n        health_info = connection_manager.get_connection_health(connection_id)\n        return health_info\n    except Exception as e:\n        logger.error(f\"Error getting connection health: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.EventPriority.LOW\n            )\n    \n    else:\n        await handle_client_message(connection_id",
        "import:typing.\"committees\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.[]))\n        await connection_manager.send_personal_message(\n            connection_id",
        "import:typing.\"Connected to Bill Updates Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Bill WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/committees\")\nasync def committees_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for committee updates.\n    \n    Automatically joins the 'committees' room for real-time committee notifications.\n    \"\"\"\n    connection_id = f\"committees_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.detail=\"Failed to get WebSocket status\") from e\n\n\n@router.post(\"/heartbeat/{connection_id}\")\nasync def update_connection_heartbeat(connection_id: str):\n    \"\"\"Update heartbeat for a specific WebSocket connection.\"\"\"\n    try:\n        connection_manager.update_heartbeat(connection_id)\n        return {\"status\": \"success\"",
        "import:typing.f\"Unsubscribed from debates for {date}\"",
        "import:typing.connection_id)\n        \n        # Automatically join votes room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.HIGH\n                )\n                \n    except Exception as e:\n        logger.error(f\"WebSocket connection error: {e}\")\n    finally:\n        # Clean up connection\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/votes\")\nasync def votes_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for vote updates.\n    \n    Automatically joins the 'votes' room for real-time vote notifications.\n    \"\"\"\n    connection_id = f\"votes_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.f\"Unknown message type: {message_type}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.leave_room(connection_id",
        "function:get_room_info",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle bill-specific messages\n                await handle_bill_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n\n\nasync def handle_vote_message(connection_id: str",
        "import:typing.publish_event\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.websocket(\"/\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    Main WebSocket endpoint for real-time parliamentary data.\n    \n    This endpoint handles:\n    - Connection management\n    - Event broadcasting\n    - Room management\n    - Heartbeat monitoring\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        # Accept the WebSocket connection\n        await connection_manager.connect(websocket",
        "import:typing.Any]):\n    \"\"\"Handle bill-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"ping\":\n        # Respond to heartbeat\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"bills\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.WebSocket",
        "import:typing.\"Invalid JSON message format\"",
        "import:typing.\"redis_info\": redis_info",
        "import:typing.f\"Subscribed to updates for committee {committee_id}\"",
        "import:typing.Any]):\n    \"\"\"Handle general client messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"join_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.join_room(connection_id",
        "import:typing.\"pong\"",
        "import:typing.message)\n\n\n# REST API endpoints for WebSocket management\n\n@router.get(\"/status\")\nasync def get_websocket_status():\n    \"\"\"Get WebSocket connection status and statistics.\"\"\"\n    try:\n        stats = connection_manager.get_stats()\n        redis_info = await redis_service.get_redis_info()\n        \n        return {\n            \"status\": \"active\"",
        "import:typing.\"Connected to Committee Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"leave_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.leave_room(connection_id",
        "import:typing.create_notification_event(\n                message=\"\"",
        "import:typing.f\"Unsubscribed from votes for bill {bill_id}\"",
        "import:typing.\"Connected to Vote Updates Service\"",
        "import:typing.\"websocket_stats\": stats",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle committee-specific messages\n                await handle_committee_message(connection_id",
        "import:typing.\"message\": \"Heartbeat updated\"}\n    except Exception as e:\n        logger.error(f\"Error updating heartbeat: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.HTTPException\n\nfrom app.core.websocket import connection_manager",
        "import:typing.create_notification_event\n)\nfrom app.core.redis_service import redis_service",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for committee {committee_id}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                logger.info(f\"WebSocket disconnected: {connection_id}\")\n                break\n            except json.JSONDecodeError:\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle vote-specific messages\n                await handle_vote_message(connection_id",
        "import:typing.Any\nfrom datetime import datetime\nfrom fastapi import APIRouter",
        "import:typing.WebSocketService\nfrom app.core.events import (\n    EventPriority",
        "import:typing.f\"Subscribed to updates for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_committee_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle committee-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.\"cleaned_connections\": cleaned_count}\n    except Exception as e:\n        logger.error(f\"Error cleaning up connections: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.\"timestamp\": datetime.utcnow().isoformat()\n        }\n    except Exception as e:\n        logger.error(f\"Error getting WebSocket status: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.data={\"rooms\": rooms}\n            )\n        )\n    \n    else:\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.detail=\"Failed to get connection health\") from e\n\n\n@router.post(\"/cleanup\")\nasync def cleanup_idle_connections():\n    \"\"\"Clean up idle WebSocket connections.\"\"\"\n    try:\n        cleaned_count = connection_manager.cleanup_idle_connections()\n        return {\"status\": \"success\"",
        "import:typing.f\"Left room: {room}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Subscribed to votes for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_debate_message(connection_id: str",
        "import:typing.\"Connected to Parliamentary Real-time Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Committee WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n# Message Handlers\n\nasync def handle_client_message(connection_id: str",
        "import:typing.connection_id)\n        \n        # Automatically join bills room\n        connection_manager.join_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for bill {bill_id}\"",
        "import:typing.detail=\"Connection not found\")\n    \n    return info\n\n\n@router.get(\"/rooms/{room}\")\nasync def get_room_info(room: str):\n    \"\"\"Get information about a specific room.\"\"\"\n    info = connection_manager.get_room_info(room)\n    return info",
        "import:typing.message: Dict[str",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Vote WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/debates\")\nasync def debates_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for debate updates.\n    \n    Automatically joins the 'debates' room for real-time debate notifications.\n    \"\"\"\n    connection_id = f\"debates_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.connection_id)\n        \n        # Automatically join committees room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle debate-specific messages\n                await handle_debate_message(connection_id"
      ]
    },
    "POST:/notify/{connection_id}": {
      "method": "POST",
      "path": "/notify/{connection_id}",
      "file": "services/api-gateway/app/api/v1/websocket.py",
      "line": 527,
      "dependencies": [
        "import:typing.EventPriority.LOW\n        )\n    \n    elif message_type == \"get_rooms\":\n        # Send list of rooms the connection is in\n        rooms = list(connection_manager.connection_rooms.get(connection_id",
        "import:typing.connection_id)\n        \n        # Automatically join debates room\n        connection_manager.join_room(connection_id",
        "import:typing.WebSocketDisconnect",
        "import:typing.connection_id)\n        \n        # Send welcome message\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"\")\n        priority = message.get(\"priority\"",
        "import:typing.\"Connected to Debate Updates Service\"",
        "import:typing.Any]):\n    \"\"\"Handle debate-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n                )\n            except Exception as e:\n                logger.error(f\"Error handling WebSocket message: {e}\")\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Debate WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/bills\")\nasync def bills_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for bill updates.\n    \n    Automatically joins the 'bills' room for real-time bill notifications.\n    \"\"\"\n    connection_id = f\"bills_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.\"votes\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.f\"Subscribed to debates for {date}\"",
        "import:typing.f\"Error processing message: {str(e)}\"",
        "import:typing.\"debates\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.Any]):\n    \"\"\"Handle vote-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.join_room(connection_id",
        "import:typing.f\"Joined room: {room}\"",
        "import:typing.Dict",
        "import:typing.message)\n\n\nasync def handle_bill_message(connection_id: str",
        "import:typing.detail=\"Failed to cleanup connections\") from e\n\n\n@router.get(\"/connections/{connection_id}\")\nasync def get_connection_info(connection_id: str):\n    \"\"\"Get information about a specific WebSocket connection.\"\"\"\n    info = connection_manager.get_connection_info(connection_id)\n    if not info:\n        raise HTTPException(status_code=404",
        "import:typing.room)\n            await WebSocketService.send_notification(\n                connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                # Receive message from client\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle different message types\n                await handle_client_message(connection_id",
        "import:typing.\"message\": \"Message broadcasted\"}\n        \n    except Exception as e:\n        logger.error(f\"Error broadcasting message: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.detail=\"Failed to update heartbeat\") from e\n\n\n@router.get(\"/health/{connection_id}\")\nasync def get_connection_health(connection_id: str):\n    \"\"\"Get health information for a specific WebSocket connection.\"\"\"\n    try:\n        health_info = connection_manager.get_connection_health(connection_id)\n        return health_info\n    except Exception as e:\n        logger.error(f\"Error getting connection health: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.EventPriority.LOW\n            )\n    \n    else:\n        await handle_client_message(connection_id",
        "import:typing.\"committees\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.[]))\n        await connection_manager.send_personal_message(\n            connection_id",
        "import:typing.\"Connected to Bill Updates Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Bill WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/committees\")\nasync def committees_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for committee updates.\n    \n    Automatically joins the 'committees' room for real-time committee notifications.\n    \"\"\"\n    connection_id = f\"committees_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.detail=\"Failed to get WebSocket status\") from e\n\n\n@router.post(\"/heartbeat/{connection_id}\")\nasync def update_connection_heartbeat(connection_id: str):\n    \"\"\"Update heartbeat for a specific WebSocket connection.\"\"\"\n    try:\n        connection_manager.update_heartbeat(connection_id)\n        return {\"status\": \"success\"",
        "import:typing.f\"Unsubscribed from debates for {date}\"",
        "import:typing.connection_id)\n        \n        # Automatically join votes room\n        connection_manager.join_room(connection_id",
        "import:typing.detail=\"Connection not found\")\n    \n    return info\n\n\n@router.get(\"/rooms/{room}\")\nasync def get_room_info(room: str):\n    \"\"\"Get information about a specific room.\"\"\"\n    info = connection_manager.get_room_info(room)\n    return info\n\n\n@router.post(\"/broadcast\")\nasync def broadcast_message(message: Dict[str",
        "import:typing.event.dict())\n        \n        return {\"status\": \"success\"",
        "import:typing.EventPriority.HIGH\n                )\n                \n    except Exception as e:\n        logger.error(f\"WebSocket connection error: {e}\")\n    finally:\n        # Clean up connection\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/votes\")\nasync def votes_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for vote updates.\n    \n    Automatically joins the 'votes' room for real-time vote notifications.\n    \"\"\"\n    connection_id = f\"votes_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.f\"Unknown message type: {message_type}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}_votes\"\n            connection_manager.leave_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle bill-specific messages\n                await handle_bill_message(connection_id",
        "import:typing.EventPriority.LOW\n        )\n\n\nasync def handle_vote_message(connection_id: str",
        "import:typing.publish_event\n\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\n\n\n@router.websocket(\"/\")\nasync def websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    Main WebSocket endpoint for real-time parliamentary data.\n    \n    This endpoint handles:\n    - Connection management\n    - Event broadcasting\n    - Room management\n    - Heartbeat monitoring\n    \"\"\"\n    connection_id = f\"ws_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        # Accept the WebSocket connection\n        await connection_manager.connect(websocket",
        "import:typing.Any]):\n    \"\"\"Handle bill-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"ping\":\n        # Respond to heartbeat\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.\"bills\")\n        \n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.WebSocket",
        "import:typing.\"Invalid JSON message format\"",
        "import:typing.\"redis_info\": redis_info",
        "import:typing.f\"Subscribed to updates for committee {committee_id}\"",
        "import:typing.event.dict())\n        else:\n            await connection_manager.broadcast_to_all(event)\n            # Also publish to Redis for other instances\n            await publish_event(\"broadcast_all\"",
        "import:typing.Any]):\n    \"\"\"Handle general client messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"join_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.join_room(connection_id",
        "import:typing.\"pong\"",
        "import:typing.message)\n\n\n# REST API endpoints for WebSocket management\n\n@router.get(\"/status\")\nasync def get_websocket_status():\n    \"\"\"Get WebSocket connection status and statistics.\"\"\"\n    try:\n        stats = connection_manager.get_stats()\n        redis_info = await redis_service.get_redis_info()\n        \n        return {\n            \"status\": \"active\"",
        "import:typing.\"Connected to Committee Updates Service\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"leave_room\":\n        room = message.get(\"room\")\n        if room:\n            connection_manager.leave_room(connection_id",
        "import:typing.create_notification_event(\n                message=\"\"",
        "import:typing.f\"Unsubscribed from votes for bill {bill_id}\"",
        "import:typing.\"Connected to Vote Updates Service\"",
        "function:broadcast_message",
        "import:typing.\"websocket_stats\": stats",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle committee-specific messages\n                await handle_committee_message(connection_id",
        "import:typing.\"message\": \"Heartbeat updated\"}\n    except Exception as e:\n        logger.error(f\"Error updating heartbeat: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.HTTPException\n\nfrom app.core.websocket import connection_manager",
        "import:typing.create_notification_event\n)\nfrom app.core.redis_service import redis_service",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_date\":\n        date = message.get(\"date\")\n        if date:\n            room = f\"debate_{date}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Unsubscribed from updates for committee {committee_id}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                logger.info(f\"WebSocket disconnected: {connection_id}\")\n                break\n            except json.JSONDecodeError:\n                await WebSocketService.send_notification(\n                    connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle vote-specific messages\n                await handle_vote_message(connection_id",
        "import:typing.Any\nfrom datetime import datetime\nfrom fastapi import APIRouter",
        "import:typing.WebSocketService\nfrom app.core.events import (\n    EventPriority",
        "import:typing.f\"Subscribed to updates for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_committee_message(connection_id: str",
        "import:typing.Any]):\n    \"\"\"Handle committee-specific messages.\"\"\"\n    message_type = message.get(\"type\")\n    \n    if message_type == \"subscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.join_room(connection_id",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_bill\":\n        bill_id = message.get(\"bill_id\")\n        if bill_id:\n            room = f\"bill_{bill_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.\"cleaned_connections\": cleaned_count}\n    except Exception as e:\n        logger.error(f\"Error cleaning up connections: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.\"normal\")\n        room = message.get(\"room\")\n        \n        # Create notification event\n        event = create_notification_event(\n            message=message_text",
        "import:typing.detail=\"Failed to broadcast message\") from e",
        "import:typing.\"timestamp\": datetime.utcnow().isoformat()\n        }\n    except Exception as e:\n        logger.error(f\"Error getting WebSocket status: {e}\")\n        raise HTTPException(status_code=500",
        "import:typing.data={\"rooms\": rooms}\n            )\n        )\n    \n    else:\n        await WebSocketService.send_notification(\n            connection_id",
        "import:typing.detail=\"Failed to get connection health\") from e\n\n\n@router.post(\"/cleanup\")\nasync def cleanup_idle_connections():\n    \"\"\"Clean up idle WebSocket connections.\"\"\"\n    try:\n        cleaned_count = connection_manager.cleanup_idle_connections()\n        return {\"status\": \"success\"",
        "import:typing.f\"Left room: {room}\"",
        "import:typing.EventPriority.LOW\n            )\n    \n    elif message_type == \"unsubscribe_committee\":\n        committee_id = message.get(\"committee_id\")\n        if committee_id:\n            room = f\"committee_{committee_id}\"\n            connection_manager.leave_room(connection_id",
        "import:typing.f\"Subscribed to votes for bill {bill_id}\"",
        "import:typing.message)\n\n\nasync def handle_debate_message(connection_id: str",
        "import:typing.\"Connected to Parliamentary Real-time Service\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Committee WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n# Message Handlers\n\nasync def handle_client_message(connection_id: str",
        "import:typing.priority=EventPriority(priority)\n        )\n        \n        # Broadcast to room or all connections\n        if room:\n            await connection_manager.broadcast_to_room(room",
        "import:typing.connection_id)\n        \n        # Automatically join bills room\n        connection_manager.join_room(connection_id",
        "import:typing.Any]):\n    \"\"\"\n    Broadcast a message to all WebSocket connections.\n    \n    This endpoint allows external services to broadcast messages\n    to all connected WebSocket clients.\n    \"\"\"\n    try:\n        message_text = message.get(\"message\"",
        "import:typing.f\"Unsubscribed from updates for bill {bill_id}\"",
        "import:typing.message: Dict[str",
        "import:typing.event)\n            # Also publish to Redis for other instances\n            await publish_event(f\"broadcast_{room}\"",
        "import:typing.message)\n                \n            except WebSocketDisconnect:\n                break\n            except Exception as e:\n                logger.error(f\"Vote WebSocket error: {e}\")\n                break\n                \n    finally:\n        connection_manager.disconnect(connection_id)\n\n\n@router.websocket(\"/debates\")\nasync def debates_websocket_endpoint(websocket: WebSocket):\n    \"\"\"\n    WebSocket endpoint specifically for debate updates.\n    \n    Automatically joins the 'debates' room for real-time debate notifications.\n    \"\"\"\n    connection_id = f\"debates_{datetime.utcnow().strftime('%Y%m%d_%H%M%S')}_{id(websocket)}\"\n    \n    try:\n        await connection_manager.connect(websocket",
        "import:typing.connection_id)\n        \n        # Automatically join committees room\n        connection_manager.join_room(connection_id",
        "import:typing.EventPriority.NORMAL\n        )\n        \n        # Main message loop\n        while True:\n            try:\n                data = await websocket.receive_text()\n                message = json.loads(data)\n                \n                # Handle debate-specific messages\n                await handle_debate_message(connection_id"
      ]
    },
    "POST:/feeds": {
      "method": "POST",
      "path": "/feeds",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 42,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.RSSValidationResult",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.RSSFeedPreview",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Path",
        "import:fastapi.or_",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.List",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSSubscription",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.Body",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/feeds": {
      "method": "GET",
      "path": "/feeds",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 100,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.custom_styling=feed.custom_styling",
        "import:fastapi.detail=f\"Feed with name '{feed_data.feed_name}' already exists\"\n        )\n    \n    # Check if feed URL already exists\n    existing_url = db.query(RSSFeed).filter(RSSFeed.feed_url == feed_data.feed_url).first()\n    if existing_url:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "function:create_rss_feed",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def create_rss_feed(\n    feed_data: RSSFeedCreateRequest = Body(...)",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.max_items=feed.max_items",
        "import:fastapi.RSSValidationResult",
        "import:fastapi.subscriber_count=feed.subscriber_count",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.feed_language=feed.feed_language",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.detail=f\"Feed with URL '{feed_data.feed_url}' already exists\"\n        )\n    \n    # Create new feed\n    feed = RSSFeed(**feed_data.dict())\n    db.add(feed)\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed created: {current_user.username} - {feed_data.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.RSSFeedPreview",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.feed_title=feed.feed_title",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.last_error=feed.last_error",
        "import:fastapi.generation_count=feed.generation_count",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.created_at=feed.created_at",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.is_active=feed.is_active",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.feed_description=feed.feed_description",
        "import:fastapi.Path",
        "import:fastapi.last_generated=feed.last_generated",
        "import:fastapi.or_",
        "import:fastapi.filter_criteria=feed.filter_criteria",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds\"",
        "import:fastapi.feed_name=feed.feed_name",
        "import:fastapi.feed_url=feed.feed_url",
        "import:fastapi.List",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed.\n    \n    This creates a new RSS feed configuration for content distribution.\n    \"\"\"\n    # Check if feed name already exists\n    existing_feed = db.query(RSSFeed).filter(RSSFeed.feed_name == feed_data.feed_name).first()\n    if existing_feed:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.feed_type=feed.feed_type",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSSubscription",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.Body",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.is_public=feed.is_public",
        "import:fastapi.updated_at=feed.updated_at\n    )",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.update_frequency_minutes=feed.update_frequency_minutes",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/feeds/{feed_id}": {
      "method": "GET",
      "path": "/feeds/{feed_id}",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 186,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.page_size=page_size",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.get(\"/feeds\"",
        "import:fastapi.max_items=feed.max_items",
        "import:fastapi.feed_language=feed.feed_language",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.feed_title=feed.feed_title",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.ge=1",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.feed_type=feed.feed_type",
        "import:fastapi.RSSSubscription",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.RSSValidationResult",
        "import:fastapi.subscriber_count=feed.subscriber_count",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.updated_at=feed.updated_at\n        ))\n    \n    return RSSFeedListResponse(\n        feeds=feed_responses",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Search in feed name or title\")",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List RSS feeds with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(RSSFeed)\n    \n    # Apply filters\n    if feed_type:\n        query = query.filter(RSSFeed.feed_type == feed_type)\n    \n    if is_active is not None:\n        query = query.filter(RSSFeed.is_active == is_active)\n    \n    if is_public is not None:\n        query = query.filter(RSSFeed.is_public == is_public)\n    \n    if language:\n        query = query.filter(RSSFeed.feed_language == language)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                RSSFeed.feed_name.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.is_public=feed.is_public",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.RSSFeed.feed_title.ilike(search_term)",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.update_frequency_minutes=feed.update_frequency_minutes",
        "import:fastapi.description=\"Filter by feed type\")",
        "import:fastapi.custom_styling=feed.custom_styling",
        "import:fastapi.detail=f\"Feed with name '{feed_data.feed_name}' already exists\"\n        )\n    \n    # Check if feed URL already exists\n    existing_url = db.query(RSSFeed).filter(RSSFeed.feed_url == feed_data.feed_url).first()\n    if existing_url:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.language: Optional[str] = Query(None",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Feed with URL '{feed_data.feed_url}' already exists\"\n        )\n    \n    # Create new feed\n    feed = RSSFeed(**feed_data.dict())\n    db.add(feed)\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed created: {current_user.username} - {feed_data.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.RSSFeedPreview",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.is_active=feed.is_active",
        "import:fastapi.Query",
        "import:fastapi.last_generated=feed.last_generated",
        "import:fastapi.total=total",
        "import:fastapi.feed_name=feed.feed_name",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed.\n    \n    This creates a new RSS feed configuration for content distribution.\n    \"\"\"\n    # Check if feed name already exists\n    existing_feed = db.query(RSSFeed).filter(RSSFeed.feed_name == feed_data.feed_name).first()\n    if existing_feed:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def create_rss_feed(\n    feed_data: RSSFeedCreateRequest = Body(...)",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.feed_type: Optional[FeedTypeEnum] = Query(None",
        "import:fastapi.last_error=feed.last_error",
        "import:fastapi.generation_count=feed.generation_count",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.created_at=feed.created_at",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.RSSFeed.feed_description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get feeds\n    feeds = query.order_by(desc(RSSFeed.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    feed_responses = []\n    for feed in feeds:\n        feed_responses.append(RSSFeedResponse(\n            id=str(feed.id)",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.feed_description=feed.feed_description",
        "import:fastapi.filter_criteria=feed.filter_criteria",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.description=\"Filter by active status\")",
        "function:list_rss_feeds",
        "import:fastapi.feed_url=feed.feed_url",
        "import:fastapi.List",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.description=\"Filter by language\")",
        "import:fastapi.response_model=RSSFeedListResponse)\nasync def list_rss_feeds(\n    page: int = Query(1",
        "import:fastapi.APIRouter"
      ]
    },
    "PUT:/feeds/{feed_id}": {
      "method": "PUT",
      "path": "/feeds/{feed_id}",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 222,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.page_size=page_size",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.get(\"/feeds\"",
        "import:fastapi.max_items=feed.max_items",
        "import:fastapi.feed_language=feed.feed_language",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.feed_title=feed.feed_title",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.ge=1",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.feed_type=feed.feed_type",
        "import:fastapi.RSSSubscription",
        "import:fastapi.updated_at=feed.updated_at\n    )",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.RSSValidationResult",
        "import:fastapi.subscriber_count=feed.subscriber_count",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.updated_at=feed.updated_at\n        ))\n    \n    return RSSFeedListResponse(\n        feeds=feed_responses",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Feed ID\")",
        "import:fastapi.description=\"Search in feed name or title\")",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List RSS feeds with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(RSSFeed)\n    \n    # Apply filters\n    if feed_type:\n        query = query.filter(RSSFeed.feed_type == feed_type)\n    \n    if is_active is not None:\n        query = query.filter(RSSFeed.is_active == is_active)\n    \n    if is_public is not None:\n        query = query.filter(RSSFeed.is_public == is_public)\n    \n    if language:\n        query = query.filter(RSSFeed.feed_language == language)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                RSSFeed.feed_name.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def get_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.is_public=feed.is_public",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.RSSFeed.feed_title.ilike(search_term)",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.update_frequency_minutes=feed.update_frequency_minutes",
        "import:fastapi.description=\"Filter by feed type\")",
        "import:fastapi.custom_styling=feed.custom_styling",
        "import:fastapi.detail=f\"Feed with name '{feed_data.feed_name}' already exists\"\n        )\n    \n    # Check if feed URL already exists\n    existing_url = db.query(RSSFeed).filter(RSSFeed.feed_url == feed_data.feed_url).first()\n    if existing_url:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.language: Optional[str] = Query(None",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Feed with URL '{feed_data.feed_url}' already exists\"\n        )\n    \n    # Create new feed\n    feed = RSSFeed(**feed_data.dict())\n    db.add(feed)\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed created: {current_user.username} - {feed_data.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.RSSFeedPreview",
        "function:get_rss_feed",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.is_active=feed.is_active",
        "import:fastapi.Query",
        "import:fastapi.last_generated=feed.last_generated",
        "import:fastapi.total=total",
        "import:fastapi.feed_name=feed.feed_name",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed.\n    \n    This creates a new RSS feed configuration for content distribution.\n    \"\"\"\n    # Check if feed name already exists\n    existing_feed = db.query(RSSFeed).filter(RSSFeed.feed_name == feed_data.feed_name).first()\n    if existing_feed:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def create_rss_feed(\n    feed_data: RSSFeedCreateRequest = Body(...)",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.feed_type: Optional[FeedTypeEnum] = Query(None",
        "import:fastapi.last_error=feed.last_error",
        "import:fastapi.generation_count=feed.generation_count",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.created_at=feed.created_at",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific RSS feed by ID.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSFeed.feed_description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get feeds\n    feeds = query.order_by(desc(RSSFeed.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    feed_responses = []\n    for feed in feeds:\n        feed_responses.append(RSSFeedResponse(\n            id=str(feed.id)",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.feed_description=feed.feed_description",
        "import:fastapi.filter_criteria=feed.filter_criteria",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.feed_url=feed.feed_url",
        "import:fastapi.List",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/feeds/{feed_id}\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.description=\"Filter by language\")",
        "import:fastapi.response_model=RSSFeedListResponse)\nasync def list_rss_feeds(\n    page: int = Query(1",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)"
      ]
    },
    "DELETE:/feeds/{feed_id}": {
      "method": "DELETE",
      "path": "/feeds/{feed_id}",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 272,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.page_size=page_size",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.get(\"/feeds\"",
        "import:fastapi.max_items=feed.max_items",
        "import:fastapi.value)\n    \n    feed.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed updated: {current_user.username} - {feed.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.feed_language=feed.feed_language",
        "import:fastapi.value in update_data.items():\n        if hasattr(feed",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def update_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.feed_title=feed.feed_title",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.ge=1",
        "import:fastapi.le=100",
        "import:fastapi.field):\n            setattr(feed",
        "import:fastapi.or_",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.feed_type=feed.feed_type",
        "import:fastapi.RSSSubscription",
        "import:fastapi.updated_at=feed.updated_at\n    )",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.RSSValidationResult",
        "import:fastapi.subscriber_count=feed.subscriber_count",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.put(\"/feeds/{feed_id}\"",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.updated_at=feed.updated_at\n        ))\n    \n    return RSSFeedListResponse(\n        feeds=feed_responses",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Feed ID\")",
        "import:fastapi.description=\"Search in feed name or title\")",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List RSS feeds with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(RSSFeed)\n    \n    # Apply filters\n    if feed_type:\n        query = query.filter(RSSFeed.feed_type == feed_type)\n    \n    if is_active is not None:\n        query = query.filter(RSSFeed.is_active == is_active)\n    \n    if is_public is not None:\n        query = query.filter(RSSFeed.is_public == is_public)\n    \n    if language:\n        query = query.filter(RSSFeed.feed_language == language)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                RSSFeed.feed_name.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def get_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.is_public=feed.is_public",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.RSSFeed.feed_title.ilike(search_term)",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.update_frequency_minutes=feed.update_frequency_minutes",
        "import:fastapi.description=\"Filter by feed type\")",
        "import:fastapi.custom_styling=feed.custom_styling",
        "import:fastapi.detail=f\"Feed with name '{feed_data.feed_name}' already exists\"\n        )\n    \n    # Check if feed URL already exists\n    existing_url = db.query(RSSFeed).filter(RSSFeed.feed_url == feed_data.feed_url).first()\n    if existing_url:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.language: Optional[str] = Query(None",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Feed with URL '{feed_data.feed_url}' already exists\"\n        )\n    \n    # Create new feed\n    feed = RSSFeed(**feed_data.dict())\n    db.add(feed)\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed created: {current_user.username} - {feed_data.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.RSSFeedPreview",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.is_active=feed.is_active",
        "import:fastapi.Query",
        "import:fastapi.last_generated=feed.last_generated",
        "import:fastapi.total=total",
        "import:fastapi.feed_name=feed.feed_name",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed.\n    \n    This creates a new RSS feed configuration for content distribution.\n    \"\"\"\n    # Check if feed name already exists\n    existing_feed = db.query(RSSFeed).filter(RSSFeed.feed_name == feed_data.feed_name).first()\n    if existing_feed:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def create_rss_feed(\n    feed_data: RSSFeedCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.feed_type: Optional[FeedTypeEnum] = Query(None",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    # Update feed fields\n    update_data = feed_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.last_error=feed.last_error",
        "import:fastapi.generation_count=feed.generation_count",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.created_at=feed.created_at",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific RSS feed by ID.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSFeed.feed_description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get feeds\n    feeds = query.order_by(desc(RSSFeed.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    feed_responses = []\n    for feed in feeds:\n        feed_responses.append(RSSFeedResponse(\n            id=str(feed.id)",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.feed_description=feed.feed_description",
        "import:fastapi.filter_criteria=feed.filter_criteria",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.description=\"Filter by active status\")",
        "function:update_rss_feed",
        "import:fastapi.List",
        "import:fastapi.feed_url=feed.feed_url",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/feeds/{feed_id}\"",
        "import:fastapi.feed_data: RSSFeedUpdateRequest = Body(...)",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.description=\"Filter by language\")",
        "import:fastapi.response_model=RSSFeedListResponse)\nasync def list_rss_feeds(\n    page: int = Query(1",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)"
      ]
    },
    "GET:/feeds/{feed_id}/generate": {
      "method": "GET",
      "path": "/feeds/{feed_id}/generate",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 299,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.page_size=page_size",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.get(\"/feeds\"",
        "import:fastapi.max_items=feed.max_items",
        "import:fastapi.value)\n    \n    feed.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed updated: {current_user.username} - {feed.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.feed_language=feed.feed_language",
        "import:fastapi.value in update_data.items():\n        if hasattr(feed",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def update_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.feed_title=feed.feed_title",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.ge=1",
        "import:fastapi.le=100",
        "import:fastapi.field):\n            setattr(feed",
        "import:fastapi.or_",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds\"",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    feed_name = feed.feed_name\n    db.delete(feed)\n    db.commit()\n    \n    logger.info(f\"RSS feed deleted: {current_user.username} - {feed_name}\")\n    \n    return {\"message\": f\"RSS feed '{feed_name}' deleted successfully\"}\n\n\n# ============================================================================\n# RSS FEED GENERATION AND XML OUTPUT\n# ============================================================================",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.feed_type=feed.feed_type",
        "import:fastapi.RSSSubscription",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.RSSValidationResult",
        "function:delete_rss_feed",
        "import:fastapi.subscriber_count=feed.subscriber_count",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.put(\"/feeds/{feed_id}\"",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.updated_at=feed.updated_at\n        ))\n    \n    return RSSFeedListResponse(\n        feeds=feed_responses",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Feed ID\")",
        "import:fastapi.description=\"Search in feed name or title\")",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List RSS feeds with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(RSSFeed)\n    \n    # Apply filters\n    if feed_type:\n        query = query.filter(RSSFeed.feed_type == feed_type)\n    \n    if is_active is not None:\n        query = query.filter(RSSFeed.is_active == is_active)\n    \n    if is_public is not None:\n        query = query.filter(RSSFeed.is_public == is_public)\n    \n    if language:\n        query = query.filter(RSSFeed.feed_language == language)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                RSSFeed.feed_name.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def get_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.is_public=feed.is_public",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.RSSFeed.feed_title.ilike(search_term)",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.update_frequency_minutes=feed.update_frequency_minutes",
        "import:fastapi.description=\"Filter by feed type\")",
        "import:fastapi.custom_styling=feed.custom_styling",
        "import:fastapi.detail=f\"Feed with name '{feed_data.feed_name}' already exists\"\n        )\n    \n    # Check if feed URL already exists\n    existing_url = db.query(RSSFeed).filter(RSSFeed.feed_url == feed_data.feed_url).first()\n    if existing_url:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.delete(\"/feeds/{feed_id}\")\nasync def delete_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.language: Optional[str] = Query(None",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Feed with URL '{feed_data.feed_url}' already exists\"\n        )\n    \n    # Create new feed\n    feed = RSSFeed(**feed_data.dict())\n    db.add(feed)\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed created: {current_user.username} - {feed_data.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.RSSFeedPreview",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.is_active=feed.is_active",
        "import:fastapi.Query",
        "import:fastapi.last_generated=feed.last_generated",
        "import:fastapi.total=total",
        "import:fastapi.feed_name=feed.feed_name",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed.\n    \n    This creates a new RSS feed configuration for content distribution.\n    \"\"\"\n    # Check if feed name already exists\n    existing_feed = db.query(RSSFeed).filter(RSSFeed.feed_name == feed_data.feed_name).first()\n    if existing_feed:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def create_rss_feed(\n    feed_data: RSSFeedCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.feed_type: Optional[FeedTypeEnum] = Query(None",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    # Update feed fields\n    update_data = feed_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.last_error=feed.last_error",
        "import:fastapi.generation_count=feed.generation_count",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.created_at=feed.created_at",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific RSS feed by ID.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSFeed.feed_description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get feeds\n    feeds = query.order_by(desc(RSSFeed.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    feed_responses = []\n    for feed in feeds:\n        feed_responses.append(RSSFeedResponse(\n            id=str(feed.id)",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.feed_description=feed.feed_description",
        "import:fastapi.filter_criteria=feed.filter_criteria",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.feed_url=feed.feed_url",
        "import:fastapi.List",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/feeds/{feed_id}\"",
        "import:fastapi.feed_data: RSSFeedUpdateRequest = Body(...)",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.description=\"Filter by language\")",
        "import:fastapi.response_model=RSSFeedListResponse)\nasync def list_rss_feeds(\n    page: int = Query(1",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)"
      ]
    },
    "GET:/feeds/by-name/{feed_name}": {
      "method": "GET",
      "path": "/feeds/by-name/{feed_name}",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 402,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.page_size=page_size",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.get(\"/feeds\"",
        "import:fastapi.max_items=feed.max_items",
        "import:fastapi.media_type=\"application/rss+xml\"\n        )\n        \n    except Exception as e:\n        # Log error\n        error_message = str(e)\n        feed.last_error = error_message\n        db.commit()\n        \n        logger.error(f\"RSS feed generation failed: {feed.feed_name} - {error_message}\")\n        \n        raise HTTPException(\n            status_code=500",
        "import:fastapi.value)\n    \n    feed.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed updated: {current_user.username} - {feed.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.feed_language=feed.feed_language",
        "import:fastapi.value in update_data.items():\n        if hasattr(feed",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def update_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.feed_title=feed.feed_title",
        "import:fastapi.detail=f\"Failed to generate RSS feed: {error_message}\"\n        )",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.ge=1",
        "import:fastapi.le=100",
        "import:fastapi.field):\n            setattr(feed",
        "import:fastapi.or_",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.feed_type=feed.feed_type",
        "import:fastapi.RSSSubscription",
        "import:fastapi.feed)\n        generation_time = (datetime.utcnow() - start_time).total_seconds() * 1000\n        \n        # Cache the generated content\n        content_hash = hashlib.md5(rss_xml.encode()).hexdigest()\n        expires_at = datetime.utcnow() + timedelta(minutes=feed.update_frequency_minutes)\n        \n        # Remove old cache entries\n        db.query(RSSCache).filter(RSSCache.feed_id == feed_id).delete()\n        \n        # Create new cache entry\n        cache_entry = RSSCache(\n            feed_id=feed_id",
        "import:fastapi.feed_id)\n        \n        return PlainTextResponse(\n            content=cached_content.rss_content",
        "function:generate_rss_feed",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.media_type=\"application/rss+xml\"\n        )\n    \n    # Generate new RSS content\n    start_time = datetime.utcnow()\n    \n    try:\n        rss_xml = await _generate_rss_xml(db",
        "import:fastapi.detail=\"RSS feed is not active\")\n    \n    # Check cache first\n    cache_key = f\"rss_feed_{feed_id}\"\n    cached_content = None\n    \n    if not force:\n        cached_content = db.query(RSSCache).filter(\n            and_(\n                RSSCache.feed_id == feed_id",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    if not feed.is_active:\n        raise HTTPException(status_code=400",
        "import:fastapi.RSSValidationResult",
        "import:fastapi.subscriber_count=feed.subscriber_count",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.put(\"/feeds/{feed_id}\"",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.description=\"Force regeneration\")",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    feed_name = feed.feed_name\n    db.delete(feed)\n    db.commit()\n    \n    logger.info(f\"RSS feed deleted: {current_user.username} - {feed_name}\")\n    \n    return {\"message\": f\"RSS feed '{feed_name}' deleted successfully\"}\n\n\n# ============================================================================\n# RSS FEED GENERATION AND XML OUTPUT\n# ============================================================================\n\n@router.get(\"/feeds/{feed_id}/generate\"",
        "import:fastapi.updated_at=feed.updated_at\n        ))\n    \n    return RSSFeedListResponse(\n        feeds=feed_responses",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Feed ID\")",
        "import:fastapi.description=\"Search in feed name or title\")",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.force: bool = Query(False",
        "import:fastapi.expires_at=expires_at",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.RSSCache.cache_key == cache_key",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List RSS feeds with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(RSSFeed)\n    \n    # Apply filters\n    if feed_type:\n        query = query.filter(RSSFeed.feed_type == feed_type)\n    \n    if is_active is not None:\n        query = query.filter(RSSFeed.is_active == is_active)\n    \n    if is_public is not None:\n        query = query.filter(RSSFeed.is_public == is_public)\n    \n    if language:\n        query = query.filter(RSSFeed.feed_language == language)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                RSSFeed.feed_name.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.last_hit=datetime.utcnow()\n        )\n        db.add(cache_entry)\n        \n        # Update feed metadata\n        feed.last_generated = datetime.utcnow()\n        feed.generation_count += 1\n        feed.last_error = None\n        \n        db.commit()\n        \n        # Track analytics\n        _track_feed_access(db",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def get_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.is_public=feed.is_public",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.RSSFeed.feed_title.ilike(search_term)",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.update_frequency_minutes=feed.update_frequency_minutes",
        "import:fastapi.description=\"Filter by feed type\")",
        "import:fastapi.custom_styling=feed.custom_styling",
        "import:fastapi.detail=f\"Feed with name '{feed_data.feed_name}' already exists\"\n        )\n    \n    # Check if feed URL already exists\n    existing_url = db.query(RSSFeed).filter(RSSFeed.feed_url == feed_data.feed_url).first()\n    if existing_url:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.content_hash=content_hash",
        "import:fastapi.feed_id)\n        \n        logger.info(f\"RSS feed generated: {feed.feed_name} - {generation_time:.2f}ms\")\n        \n        return PlainTextResponse(\n            content=rss_xml",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.delete(\"/feeds/{feed_id}\")\nasync def delete_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.language: Optional[str] = Query(None",
        "import:fastapi.RSSCache.expires_at > datetime.utcnow()\n            )\n        ).first()\n    \n    if cached_content:\n        # Update cache hits\n        cached_content.hits += 1\n        cached_content.last_hit = datetime.utcnow()\n        db.commit()\n        \n        # Track analytics\n        _track_feed_access(db",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Feed with URL '{feed_data.feed_url}' already exists\"\n        )\n    \n    # Create new feed\n    feed = RSSFeed(**feed_data.dict())\n    db.add(feed)\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed created: {current_user.username} - {feed_data.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.RSSFeedPreview",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_class=PlainTextResponse)\nasync def generate_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.is_active=feed.is_active",
        "import:fastapi.Query",
        "import:fastapi.last_generated=feed.last_generated",
        "import:fastapi.total=total",
        "import:fastapi.rss_content=rss_xml",
        "import:fastapi.feed_name=feed.feed_name",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed.\n    \n    This creates a new RSS feed configuration for content distribution.\n    \"\"\"\n    # Check if feed name already exists\n    existing_feed = db.query(RSSFeed).filter(RSSFeed.feed_name == feed_data.feed_name).first()\n    if existing_feed:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def create_rss_feed(\n    feed_data: RSSFeedCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.hits=1",
        "import:fastapi.item_count=len(rss_xml.split('<item>'))",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.cache_key=cache_key",
        "import:fastapi.feed_type: Optional[FeedTypeEnum] = Query(None",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    # Update feed fields\n    update_data = feed_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.last_error=feed.last_error",
        "import:fastapi.generation_count=feed.generation_count",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.created_at=feed.created_at",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific RSS feed by ID.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSFeed.feed_description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get feeds\n    feeds = query.order_by(desc(RSSFeed.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    feed_responses = []\n    for feed in feeds:\n        feed_responses.append(RSSFeedResponse(\n            id=str(feed.id)",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.feed_description=feed.feed_description",
        "import:fastapi.filter_criteria=feed.filter_criteria",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.feed_url=feed.feed_url",
        "import:fastapi.List",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/feeds/{feed_id}\"",
        "import:fastapi.feed_data: RSSFeedUpdateRequest = Body(...)",
        "import:fastapi.generation_time_ms=int(generation_time)",
        "import:fastapi.Body",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Generate RSS XML for a specific feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.Dict",
        "import:fastapi.description=\"Filter by language\")",
        "import:fastapi.response_model=RSSFeedListResponse)\nasync def list_rss_feeds(\n    page: int = Query(1",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)"
      ]
    },
    "POST:/feeds/{feed_id}/items": {
      "method": "POST",
      "path": "/feeds/{feed_id}/items",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 428,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.page_size=page_size",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.get(\"/feeds\"",
        "import:fastapi.max_items=feed.max_items",
        "import:fastapi.media_type=\"application/rss+xml\"\n        )\n        \n    except Exception as e:\n        # Log error\n        error_message = str(e)\n        feed.last_error = error_message\n        db.commit()\n        \n        logger.error(f\"RSS feed generation failed: {feed.feed_name} - {error_message}\")\n        \n        raise HTTPException(\n            status_code=500",
        "import:fastapi.value)\n    \n    feed.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed updated: {current_user.username} - {feed.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.feed_language=feed.feed_language",
        "import:fastapi.value in update_data.items():\n        if hasattr(feed",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def update_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.feed_title=feed.feed_title",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.ge=1",
        "function:get_rss_feed_by_name",
        "import:fastapi.RSSFeed.is_active == True",
        "import:fastapi.le=100",
        "import:fastapi.field):\n            setattr(feed",
        "import:fastapi.or_",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.feed_type=feed.feed_type",
        "import:fastapi.RSSSubscription",
        "import:fastapi.feed)\n        generation_time = (datetime.utcnow() - start_time).total_seconds() * 1000\n        \n        # Cache the generated content\n        content_hash = hashlib.md5(rss_xml.encode()).hexdigest()\n        expires_at = datetime.utcnow() + timedelta(minutes=feed.update_frequency_minutes)\n        \n        # Remove old cache entries\n        db.query(RSSCache).filter(RSSCache.feed_id == feed_id).delete()\n        \n        # Create new cache entry\n        cache_entry = RSSCache(\n            feed_id=feed_id",
        "import:fastapi.feed_id)\n        \n        return PlainTextResponse(\n            content=cached_content.rss_content",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.media_type=\"application/rss+xml\"\n        )\n    \n    # Generate new RSS content\n    start_time = datetime.utcnow()\n    \n    try:\n        rss_xml = await _generate_rss_xml(db",
        "import:fastapi.detail=\"RSS feed is not active\")\n    \n    # Check cache first\n    cache_key = f\"rss_feed_{feed_id}\"\n    cached_content = None\n    \n    if not force:\n        cached_content = db.query(RSSCache).filter(\n            and_(\n                RSSCache.feed_id == feed_id",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    if not feed.is_active:\n        raise HTTPException(status_code=400",
        "import:fastapi.RSSValidationResult",
        "import:fastapi.subscriber_count=feed.subscriber_count",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.put(\"/feeds/{feed_id}\"",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.description=\"Force regeneration\")",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    feed_name = feed.feed_name\n    db.delete(feed)\n    db.commit()\n    \n    logger.info(f\"RSS feed deleted: {current_user.username} - {feed_name}\")\n    \n    return {\"message\": f\"RSS feed '{feed_name}' deleted successfully\"}\n\n\n# ============================================================================\n# RSS FEED GENERATION AND XML OUTPUT\n# ============================================================================\n\n@router.get(\"/feeds/{feed_id}/generate\"",
        "import:fastapi.updated_at=feed.updated_at\n        ))\n    \n    return RSSFeedListResponse(\n        feeds=feed_responses",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Feed ID\")",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    return await generate_rss_feed(str(feed.id)",
        "import:fastapi.description=\"Search in feed name or title\")",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.force: bool = Query(False",
        "import:fastapi.expires_at=expires_at",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.RSSCache.cache_key == cache_key",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List RSS feeds with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(RSSFeed)\n    \n    # Apply filters\n    if feed_type:\n        query = query.filter(RSSFeed.feed_type == feed_type)\n    \n    if is_active is not None:\n        query = query.filter(RSSFeed.is_active == is_active)\n    \n    if is_public is not None:\n        query = query.filter(RSSFeed.is_public == is_public)\n    \n    if language:\n        query = query.filter(RSSFeed.feed_language == language)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                RSSFeed.feed_name.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.last_hit=datetime.utcnow()\n        )\n        db.add(cache_entry)\n        \n        # Update feed metadata\n        feed.last_generated = datetime.utcnow()\n        feed.generation_count += 1\n        feed.last_error = None\n        \n        db.commit()\n        \n        # Track analytics\n        _track_feed_access(db",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def get_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.is_public=feed.is_public",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.db)\n\n\n# ============================================================================\n# RSS FEED ITEMS MANAGEMENT\n# ============================================================================",
        "import:fastapi.RSSFeed.feed_title.ilike(search_term)",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.update_frequency_minutes=feed.update_frequency_minutes",
        "import:fastapi.description=\"Filter by feed type\")",
        "import:fastapi.custom_styling=feed.custom_styling",
        "import:fastapi.detail=f\"Feed with name '{feed_data.feed_name}' already exists\"\n        )\n    \n    # Check if feed URL already exists\n    existing_url = db.query(RSSFeed).filter(RSSFeed.feed_url == feed_data.feed_url).first()\n    if existing_url:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.content_hash=content_hash",
        "import:fastapi.feed_id)\n        \n        logger.info(f\"RSS feed generated: {feed.feed_name} - {generation_time:.2f}ms\")\n        \n        return PlainTextResponse(\n            content=rss_xml",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.delete(\"/feeds/{feed_id}\")\nasync def delete_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.language: Optional[str] = Query(None",
        "import:fastapi.RSSCache.expires_at > datetime.utcnow()\n            )\n        ).first()\n    \n    if cached_content:\n        # Update cache hits\n        cached_content.hits += 1\n        cached_content.last_hit = datetime.utcnow()\n        db.commit()\n        \n        # Track analytics\n        _track_feed_access(db",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Feed with URL '{feed_data.feed_url}' already exists\"\n        )\n    \n    # Create new feed\n    feed = RSSFeed(**feed_data.dict())\n    db.add(feed)\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed created: {current_user.username} - {feed_data.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.RSSFeedPreview",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_class=PlainTextResponse)\nasync def generate_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.is_active=feed.is_active",
        "import:fastapi.Query",
        "import:fastapi.last_generated=feed.last_generated",
        "import:fastapi.total=total",
        "import:fastapi.rss_content=rss_xml",
        "import:fastapi.feed_name=feed.feed_name",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed.\n    \n    This creates a new RSS feed configuration for content distribution.\n    \"\"\"\n    # Check if feed name already exists\n    existing_feed = db.query(RSSFeed).filter(RSSFeed.feed_name == feed_data.feed_name).first()\n    if existing_feed:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def create_rss_feed(\n    feed_data: RSSFeedCreateRequest = Body(...)",
        "import:fastapi.response_class=PlainTextResponse)\nasync def get_rss_feed_by_name(\n    feed_name: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.hits=1",
        "import:fastapi.item_count=len(rss_xml.split('<item>'))",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.cache_key=cache_key",
        "import:fastapi.feed_type: Optional[FeedTypeEnum] = Query(None",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    # Update feed fields\n    update_data = feed_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.last_error=feed.last_error",
        "import:fastapi.generation_count=feed.generation_count",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.False",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.created_at=feed.created_at",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific RSS feed by ID.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSFeed.feed_description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get feeds\n    feeds = query.order_by(desc(RSSFeed.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    feed_responses = []\n    for feed in feeds:\n        feed_responses.append(RSSFeedResponse(\n            id=str(feed.id)",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.feed_description=feed.feed_description",
        "import:fastapi.filter_criteria=feed.filter_criteria",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.description=\"Feed name\")",
        "import:fastapi.feed_url=feed.feed_url",
        "import:fastapi.List",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/feeds/{feed_id}\"",
        "import:fastapi.feed_data: RSSFeedUpdateRequest = Body(...)",
        "import:fastapi.generation_time_ms=int(generation_time)",
        "import:fastapi.Body",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Generate RSS XML for a specific feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.Dict",
        "import:fastapi.description=\"Filter by language\")",
        "import:fastapi.response_model=RSSFeedListResponse)\nasync def list_rss_feeds(\n    page: int = Query(1",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.detail=f\"Failed to generate RSS feed: {error_message}\"\n        )\n\n\n@router.get(\"/feeds/by-name/{feed_name}\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get RSS XML by feed name (for direct RSS client access).\n    \"\"\"\n    feed = db.query(RSSFeed).filter(\n        and_(\n            RSSFeed.feed_name == feed_name",
        "import:fastapi.RSSFeed.is_public == True\n        )\n    ).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404"
      ]
    },
    "GET:/feeds/{feed_id}/statistics": {
      "method": "GET",
      "path": "/feeds/{feed_id}/statistics",
      "file": "services/api-gateway/app/api/v1/rss_feeds.py",
      "line": 492,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed item.\n    \"\"\"\n    # Verify feed exists\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size=page_size",
        "import:fastapi.item_title=item.item_title",
        "import:fastapi.RSSFeedItemUpdateRequest",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.get(\"/feeds\"",
        "import:fastapi.max_items=feed.max_items",
        "import:fastapi.media_type=\"application/rss+xml\"\n        )\n        \n    except Exception as e:\n        # Log error\n        error_message = str(e)\n        feed.last_error = error_message\n        db.commit()\n        \n        logger.error(f\"RSS feed generation failed: {feed.feed_name} - {error_message}\")\n        \n        raise HTTPException(\n            status_code=500",
        "import:fastapi.value)\n    \n    feed.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed updated: {current_user.username} - {feed.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.view_count=item.view_count",
        "import:fastapi.feed_language=feed.feed_language",
        "import:fastapi.item_summary=item.item_summary",
        "import:fastapi.value in update_data.items():\n        if hasattr(feed",
        "import:fastapi.RSSFeedItemResponse",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def update_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.created_at=item.created_at",
        "import:fastapi.RSSCacheStatus",
        "import:fastapi.item_description=item.item_description",
        "import:fastapi.feed_title=feed.feed_title",
        "import:fastapi.RSSFeedItemCreateRequest",
        "import:fastapi.RSSSubscriptionCreateRequest",
        "import:fastapi.RSSCache\nfrom app.models.parliamentary_entities import ParliamentaryEntity\nfrom app.schemas.rss_feeds import (\n    RSSFeedResponse",
        "import:fastapi.ge=1",
        "import:fastapi.item_data: RSSFeedItemCreateRequest = Body(...)",
        "import:fastapi.item_pub_date=item.item_pub_date",
        "import:fastapi.RSSFeed.is_active == True",
        "function:create_rss_feed_item",
        "import:fastapi.item_category=item.item_category",
        "import:fastapi.le=100",
        "import:fastapi.field):\n            setattr(feed",
        "import:fastapi.or_",
        "import:fastapi.ContentTypeEnum\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# RSS FEED MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.feed_type=feed.feed_type",
        "import:fastapi.RSSSubscription",
        "import:fastapi.feed)\n        generation_time = (datetime.utcnow() - start_time).total_seconds() * 1000\n        \n        # Cache the generated content\n        content_hash = hashlib.md5(rss_xml.encode()).hexdigest()\n        expires_at = datetime.utcnow() + timedelta(minutes=feed.update_frequency_minutes)\n        \n        # Remove old cache entries\n        db.query(RSSCache).filter(RSSCache.feed_id == feed_id).delete()\n        \n        # Create new cache entry\n        cache_entry = RSSCache(\n            feed_id=feed_id",
        "import:fastapi.feed_id)\n        \n        return PlainTextResponse(\n            content=cached_content.rss_content",
        "import:fastapi.RSSSubscriptionResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.media_type=\"application/rss+xml\"\n        )\n    \n    # Generate new RSS content\n    start_time = datetime.utcnow()\n    \n    try:\n        rss_xml = await _generate_rss_xml(db",
        "import:fastapi.detail=\"RSS feed is not active\")\n    \n    # Check cache first\n    cache_key = f\"rss_feed_{feed_id}\"\n    cached_content = None\n    \n    if not force:\n        cached_content = db.query(RSSCache).filter(\n            and_(\n                RSSCache.feed_id == feed_id",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.db)\n\n\n# ============================================================================\n# RSS FEED ITEMS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/feeds/{feed_id}/items\"",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    if not feed.is_active:\n        raise HTTPException(status_code=400",
        "import:fastapi.RSSValidationResult",
        "import:fastapi.subscriber_count=feed.subscriber_count",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.put(\"/feeds/{feed_id}\"",
        "import:fastapi.is_featured=item.is_featured",
        "import:fastapi.RSSFeedStatistics",
        "import:fastapi.description=\"Force regeneration\")",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    feed_name = feed.feed_name\n    db.delete(feed)\n    db.commit()\n    \n    logger.info(f\"RSS feed deleted: {current_user.username} - {feed_name}\")\n    \n    return {\"message\": f\"RSS feed '{feed_name}' deleted successfully\"}\n\n\n# ============================================================================\n# RSS FEED GENERATION AND XML OUTPUT\n# ============================================================================\n\n@router.get(\"/feeds/{feed_id}/generate\"",
        "import:fastapi.updated_at=feed.updated_at\n        ))\n    \n    return RSSFeedListResponse(\n        feeds=feed_responses",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Feed ID\")",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    return await generate_rss_feed(str(feed.id)",
        "import:fastapi.content_id=item.content_id",
        "import:fastapi.description=\"Search in feed name or title\")",
        "import:fastapi.RSSAnalyticsResponse",
        "import:fastapi.force: bool = Query(False",
        "import:fastapi.expires_at=expires_at",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.RSSCache.cache_key == cache_key",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List RSS feeds with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(RSSFeed)\n    \n    # Apply filters\n    if feed_type:\n        query = query.filter(RSSFeed.feed_type == feed_type)\n    \n    if is_active is not None:\n        query = query.filter(RSSFeed.is_active == is_active)\n    \n    if is_public is not None:\n        query = query.filter(RSSFeed.is_public == is_public)\n    \n    if language:\n        query = query.filter(RSSFeed.feed_language == language)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                RSSFeed.feed_name.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.last_hit=datetime.utcnow()\n        )\n        db.add(cache_entry)\n        \n        # Update feed metadata\n        feed.last_generated = datetime.utcnow()\n        feed.generation_count += 1\n        feed.last_error = None\n        \n        db.commit()\n        \n        # Track analytics\n        _track_feed_access(db",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def get_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.content_type=item.content_type",
        "import:fastapi.RSSFeedUpdateRequest",
        "import:fastapi.RSSFeedItemListResponse",
        "import:fastapi.is_public=feed.is_public",
        "import:fastapi.RSSAnalyticsListResponse",
        "import:fastapi.detail=f\"Feed item with GUID '{item_data.item_guid}' already exists\"\n        )\n    \n    # Create new item\n    item = RSSFeedItem(**item_data.dict())\n    item.feed_id = feed_id\n    db.add(item)\n    db.commit()\n    db.refresh(item)\n    \n    # Invalidate cache for this feed\n    _invalidate_feed_cache(db",
        "import:fastapi.RSSFeed.feed_title.ilike(search_term)",
        "import:fastapi.RSSAnalytics",
        "import:fastapi.update_frequency_minutes=feed.update_frequency_minutes",
        "import:fastapi.description=\"Filter by feed type\")",
        "import:fastapi.custom_styling=feed.custom_styling",
        "import:fastapi.detail=f\"Feed with name '{feed_data.feed_name}' already exists\"\n        )\n    \n    # Check if feed URL already exists\n    existing_url = db.query(RSSFeed).filter(RSSFeed.feed_url == feed_data.feed_url).first()\n    if existing_url:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.content_hash=content_hash",
        "import:fastapi.feed_id)\n        \n        logger.info(f\"RSS feed generated: {feed.feed_name} - {generation_time:.2f}ms\")\n        \n        return PlainTextResponse(\n            content=rss_xml",
        "import:fastapi.updated_at=feed.updated_at\n    )\n\n\n@router.delete(\"/feeds/{feed_id}\")\nasync def delete_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.language: Optional[str] = Query(None",
        "import:fastapi.RSSCache.expires_at > datetime.utcnow()\n            )\n        ).first()\n    \n    if cached_content:\n        # Update cache hits\n        cached_content.hits += 1\n        cached_content.last_hit = datetime.utcnow()\n        db.commit()\n        \n        # Track analytics\n        _track_feed_access(db",
        "import:fastapi.feed_id)\n    \n    logger.info(f\"RSS feed item created: {current_user.username} - {item_data.item_title}\")\n    \n    return RSSFeedItemResponse(\n        id=str(item.id)",
        "import:fastapi.Response\nfrom fastapi.responses import PlainTextResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Feed with URL '{feed_data.feed_url}' already exists\"\n        )\n    \n    # Create new feed\n    feed = RSSFeed(**feed_data.dict())\n    db.add(feed)\n    db.commit()\n    db.refresh(feed)\n    \n    logger.info(f\"RSS feed created: {current_user.username} - {feed_data.feed_name}\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.RSSFeedPreview",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_class=PlainTextResponse)\nasync def generate_rss_feed(\n    feed_id: str = Path(...",
        "import:fastapi.item_metadata=item.item_metadata",
        "import:fastapi.is_active=feed.is_active",
        "import:fastapi.Query",
        "import:fastapi.last_generated=feed.last_generated",
        "import:fastapi.total=total",
        "import:fastapi.rss_content=rss_xml",
        "import:fastapi.feed_name=feed.feed_name",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new RSS feed.\n    \n    This creates a new RSS feed configuration for content distribution.\n    \"\"\"\n    # Check if feed name already exists\n    existing_feed = db.query(RSSFeed).filter(RSSFeed.feed_name == feed_data.feed_name).first()\n    if existing_feed:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.feed_id=str(item.feed_id)",
        "import:fastapi.item_link=item.item_link",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.response_model=RSSFeedResponse)\nasync def create_rss_feed(\n    feed_data: RSSFeedCreateRequest = Body(...)",
        "import:fastapi.response_model=RSSFeedItemResponse)\nasync def create_rss_feed_item(\n    feed_id: str = Path(...",
        "import:fastapi.response_class=PlainTextResponse)\nasync def get_rss_feed_by_name(\n    feed_name: str = Path(...",
        "import:fastapi.item_guid=item.item_guid",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an RSS feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSSystemStatistics",
        "import:fastapi.hits=1",
        "import:fastapi.item_count=len(rss_xml.split('<item>'))",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport xml.etree.ElementTree as ET\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.rss_feeds import RSSFeed",
        "import:fastapi.RSSFeedCreateRequest",
        "import:fastapi.RSSFeedGenerateRequest",
        "import:fastapi.cache_key=cache_key",
        "import:fastapi.feed_type: Optional[FeedTypeEnum] = Query(None",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    # Update feed fields\n    update_data = feed_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.last_error=feed.last_error",
        "import:fastapi.generation_count=feed.generation_count",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.updated_at=item.updated_at\n    )\n\n\n# ============================================================================\n# RSS ANALYTICS AND STATISTICS\n# ============================================================================",
        "import:fastapi.False",
        "import:fastapi.FeedTypeEnum",
        "import:fastapi.created_at=feed.created_at",
        "import:fastapi.RSSFeedListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific RSS feed by ID.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.RSSFeed.feed_description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get feeds\n    feeds = query.order_by(desc(RSSFeed.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    feed_responses = []\n    for feed in feeds:\n        feed_responses.append(RSSFeedResponse(\n            id=str(feed.id)",
        "import:fastapi.RSSSubscriptionListResponse",
        "import:fastapi.feed_description=feed.feed_description",
        "import:fastapi.item_content=item.item_content",
        "import:fastapi.filter_criteria=feed.filter_criteria",
        "import:fastapi.RSSFeedItem",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.description=\"Feed name\")",
        "import:fastapi.feed_url=feed.feed_url",
        "import:fastapi.List",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/feeds/{feed_id}\"",
        "import:fastapi.feed_data: RSSFeedUpdateRequest = Body(...)",
        "import:fastapi.generation_time_ms=int(generation_time)",
        "import:fastapi.Body",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Generate RSS XML for a specific feed.\n    \"\"\"\n    feed = db.query(RSSFeed).filter(RSSFeed.id == feed_id).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404",
        "import:fastapi.Dict",
        "import:fastapi.description=\"Filter by language\")",
        "import:fastapi.response_model=RSSFeedListResponse)\nasync def list_rss_feeds(\n    page: int = Query(1",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    return RSSFeedResponse(\n        id=str(feed.id)",
        "import:fastapi.detail=\"RSS feed not found\")\n    \n    # Check if item GUID already exists\n    existing_item = db.query(RSSFeedItem).filter(\n        RSSFeedItem.item_guid == item_data.item_guid\n    ).first()\n    \n    if existing_item:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.detail=f\"Failed to generate RSS feed: {error_message}\"\n        )\n\n\n@router.get(\"/feeds/by-name/{feed_name}\"",
        "import:fastapi.item_author=item.item_author",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get RSS XML by feed name (for direct RSS client access).\n    \"\"\"\n    feed = db.query(RSSFeed).filter(\n        and_(\n            RSSFeed.feed_name == feed_name",
        "import:fastapi.RSSFeed.is_public == True\n        )\n    ).first()\n    \n    if not feed:\n        raise HTTPException(status_code=404"
      ]
    },
    "GET:/statistics": {
      "method": "GET",
      "path": "/statistics",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 714,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.created_at=visualization.created_at",
        "import:fastapi.\"expires_at\": cached_data.expires_at",
        "import:fastapi.page_size=page_size",
        "import:fastapi.layout_config=dashboard.layout_config",
        "import:fastapi.viz_data: DashboardVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=dashboard.is_public",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.usedforsecurity=False).hexdigest()\n        config_hash = hashlib.md5(json.dumps(visualization.configuration",
        "import:fastapi.last_generated=visualization.last_generated",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "function:add_visualization_to_dashboard",
        "import:fastapi.description=\"Dashboard ID\")",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/dashboards/{dashboard_id}\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List data visualizations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(DataVisualization)\n    \n    # Apply filters\n    if visualization_type_id:\n        query = query.filter(DataVisualization.visualization_type_id == visualization_type_id)\n    \n    if data_source:\n        query = query.filter(DataVisualization.data_source == data_source)\n    \n    if is_public is not None:\n        query = query.filter(DataVisualization.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(DataVisualization.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(DataVisualization.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                DataVisualization.title.ilike(search_term)",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.refresh_interval=dashboard_viz.refresh_interval",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new data visualization.\n    \"\"\"\n    # Verify visualization type exists\n    viz_type = db.query(VisualizationType).filter(\n        VisualizationType.id == viz_data.visualization_type_id\n    ).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.created_by=visualization.created_by",
        "import:fastapi.updated_at=visualization.updated_at\n        ))\n    \n    return DataVisualizationListResponse(\n        visualizations=viz_responses",
        "import:fastapi.config_hash=config_hash",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.view_count=dashboard.view_count",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.request_data: VisualizationDataRequest = Body(...)",
        "import:fastapi.visualization_id)\n        \n        logger.info(f\"Visualization data generated: {visualization.title} - {generation_time:.2f}ms\")\n        \n        return {\n            \"visualization_id\": visualization_id",
        "import:fastapi.\"expires_at\": expires_at",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def get_data_visualization(\n    visualization_id: str = Path(...",
        "import:fastapi.le=100",
        "import:fastapi.dashboard_id=str(dashboard_viz.dashboard_id)",
        "import:fastapi.is_featured=visualization.is_featured",
        "import:fastapi.or_",
        "import:fastapi.description=\"Filter by featured status\")",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n# ============================================================================\n# DASHBOARD MANAGEMENT\n# ============================================================================\n\n@router.post(\"/dashboards\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.\"cache_key\": cached_data.cache_key",
        "import:fastapi.\"generation_time_ms\": int(generation_time)\n        }\n        \n    except Exception as e:\n        # Log error\n        error_message = str(e)\n        logger.error(f\"Visualization generation failed: {visualization.title} - {error_message}\")\n        \n        raise HTTPException(\n            status_code=500",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific data visualization by ID.\n    \"\"\"\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by data source\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific dashboard by ID.\n    \"\"\"\n    dashboard = db.query(Dashboard).filter(Dashboard.id == dashboard_id).first()\n    \n    if not dashboard:\n        raise HTTPException(status_code=404",
        "import:fastapi.data_source=visualization.data_source",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List dashboards with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Dashboard)\n    \n    # Apply filters\n    if theme:\n        query = query.filter(Dashboard.theme == theme)\n    \n    if is_public is not None:\n        query = query.filter(Dashboard.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(Dashboard.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(Dashboard.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Dashboard.title.ilike(search_term)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Generate data for a specific visualization.\n    \"\"\"\n    # Get visualization\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"data\": generated_data",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    # Create new visualization\n    visualization = DataVisualization(**viz_data.dict())\n    visualization.created_by = current_user.username\n    db.add(visualization)\n    db.commit()\n    db.refresh(visualization)\n    \n    logger.info(f\"Data visualization created: {current_user.username} - {viz_data.title}\")\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.view_count=visualization.view_count",
        "import:fastapi.HTTPException",
        "import:fastapi.custom_config=dashboard_viz.custom_config",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.tags=dashboard.tags",
        "import:fastapi.detail=\"Dashboard not found\")\n    \n    # Verify visualization exists\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == viz_data.visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n@router.get(\"/visualizations\"",
        "import:fastapi.response_model=DashboardResponse)\nasync def get_dashboard(\n    dashboard_id: str = Path(...",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.tags=visualization.tags",
        "import:fastapi.Dashboard.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get dashboards\n    dashboards = query.order_by(desc(Dashboard.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    dashboard_responses = []\n    for dashboard in dashboards:\n        dashboard_responses.append(DashboardResponse(\n            id=str(dashboard.id)",
        "import:fastapi.created_by=dashboard.created_by",
        "import:fastapi.description=dashboard.description",
        "import:fastapi.visualization_type_id: Optional[str] = Query(None",
        "import:fastapi.cache_key=visualization.cache_key",
        "import:fastapi.response_model=DashboardResponse)\nasync def create_dashboard(\n    dashboard_data: DashboardCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.request_data.custom_filters\n        )\n        \n        generation_time = (datetime.utcnow() - start_time).total_seconds() * 1000\n        \n        # Cache the generated data\n        data_hash = hashlib.md5(json.dumps(generated_data",
        "import:fastapi.data_size=len(json.dumps(generated_data))",
        "import:fastapi.description=\"Filter by creator\")",
        "import:fastapi.description=\"Visualization ID\")",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.visualization_id)\n            \n            return {\n                \"visualization_id\": visualization_id",
        "import:fastapi.position_x=dashboard_viz.position_x",
        "import:fastapi.visualization",
        "import:fastapi.expires_at=expires_at",
        "import:fastapi.Depends",
        "import:fastapi.is_featured=dashboard.is_featured",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.title=dashboard.title",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.generated_data=generated_data",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.detail=f\"Failed to generate visualization data: {error_message}\"\n        )\n\n\n# ============================================================================\n# DASHBOARD VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/dashboards/{dashboard_id}/visualizations\"",
        "import:fastapi.\"generation_time_ms\": cached_data.generation_time_ms\n            }\n    \n    # Generate new data\n    start_time = datetime.utcnow()\n    \n    try:\n        # Generate visualization data based on type and source\n        generated_data = await _generate_visualization_data(\n            db",
        "import:fastapi.VisualizationCache",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def create_data_visualization(\n    viz_data: DataVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=visualization.is_public",
        "import:fastapi.height=dashboard_viz.height",
        "import:fastapi.title=visualization.title",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.created_at=dashboard_viz.created_at",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.response_model=DataVisualizationListResponse)\nasync def list_data_visualizations(\n    page: int = Query(1",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.updated_at=dashboard.updated_at\n        ))\n    \n    return DashboardListResponse(\n        dashboards=dashboard_responses",
        "import:fastapi.\"cache_key\": cache_key",
        "import:fastapi.visualization_id=str(dashboard_viz.visualization_id)",
        "import:fastapi.\"is_cached\": False",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.refresh_interval=dashboard.refresh_interval",
        "import:fastapi.generation_time_ms=visualization.generation_time_ms",
        "import:fastapi.detail=\"Visualization not found\")\n    \n    # Check if visualization is already in dashboard\n    existing_viz = db.query(DashboardVisualization).filter(\n        and_(\n            DashboardVisualization.dashboard_id == dashboard_id",
        "import:fastapi.created_by: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.created_at=dashboard.created_at",
        "import:fastapi.data_source: Optional[DataSourceEnum] = Query(None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Add a visualization to a dashboard.\n    \"\"\"\n    # Verify dashboard exists\n    dashboard = db.query(Dashboard).filter(Dashboard.id == dashboard_id).first()\n    if not dashboard:\n        raise HTTPException(status_code=404",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.last_accessed=dashboard.last_accessed",
        "import:fastapi.is_visible=dashboard_viz.is_visible",
        "import:fastapi.updated_at=dashboard.updated_at\n    )\n\n\n@router.get(\"/dashboards\"",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/visualizations\"",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.title_override=dashboard_viz.title_override",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/visualizations/{visualization_id}\"",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.\"is_cached\": True",
        "import:fastapi.updated_at=dashboard_viz.updated_at\n    )\n\n\n# ============================================================================\n# STATISTICS AND ANALYTICS\n# ============================================================================",
        "import:fastapi.detail=\"Visualization is already in this dashboard\"\n        )\n    \n    # Create dashboard visualization\n    dashboard_viz = DashboardVisualization(**viz_data.dict())\n    dashboard_viz.dashboard_id = dashboard_id\n    db.add(dashboard_viz)\n    db.commit()\n    db.refresh(dashboard_viz)\n    \n    logger.info(f\"Visualization added to dashboard: {current_user.username} - {visualization.title}\")\n    \n    return DashboardVisualizationResponse(\n        id=str(dashboard_viz.id)",
        "import:fastapi.\"data\": cached_data.generated_data",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=\"Visualization not found\")\n    \n    # Check cache first\n    if not request_data.force_regenerate:\n        cached_data = db.query(VisualizationCache).filter(\n            and_(\n                VisualizationCache.visualization_id == visualization_id",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.usedforsecurity=False).hexdigest()\n        cache_key = f\"viz_{visualization_id}_{data_hash}_{config_hash}\"\n        expires_at = datetime.utcnow() + timedelta(hours=1)  # Cache for 1 hour\n        \n        # Remove old cache entries\n        db.query(VisualizationCache).filter(\n            VisualizationCache.visualization_id == visualization_id\n        ).delete()\n        \n        # Create new cache entry\n        cache_entry = VisualizationCache(\n            visualization_id=visualization_id",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.theme=dashboard.theme",
        "import:fastapi.response_model=DashboardVisualizationResponse)\nasync def add_visualization_to_dashboard(\n    dashboard_id: str = Path(...",
        "import:fastapi.theme: Optional[ThemeEnum] = Query(None",
        "import:fastapi.data_query=visualization.data_query",
        "import:fastapi.hits=1",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.detail=\"Dashboard not found\")\n    \n    # Update last accessed and view count\n    dashboard.last_accessed = datetime.utcnow()\n    dashboard.view_count += 1\n    db.commit()\n    \n    return DashboardResponse(\n        id=str(dashboard.id)",
        "import:fastapi.updated_at=dashboard.updated_at\n    )\n\n\n# ============================================================================\n# VISUALIZATION DATA GENERATION\n# ============================================================================\n\n@router.post(\"/visualizations/{visualization_id}/generate\")\nasync def generate_visualization_data(\n    visualization_id: str = Path(...",
        "import:fastapi.is_featured: Optional[bool] = Query(None",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=\"Data visualization not found\")\n    \n    # Increment view count\n    visualization.view_count += 1\n    db.commit()\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.sort_keys=True).encode()",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.width=dashboard_viz.width",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.cache_key=cache_key",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Search in titles and descriptions\")",
        "import:fastapi.DashboardVisualization.visualization_id == viz_data.visualization_id\n        )\n    ).first()\n    \n    if existing_viz:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.data_hash=data_hash",
        "import:fastapi.description=\"Filter by theme\")",
        "import:fastapi.response_model=DashboardListResponse)\nasync def list_dashboards(\n    page: int = Query(1",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.configuration=visualization.configuration",
        "import:fastapi.description=\"Filter by visualization type ID\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new dashboard.\n    \"\"\"\n    # Create new dashboard\n    dashboard = Dashboard(**dashboard_data.dict())\n    dashboard.created_by = current_user.username\n    db.add(dashboard)\n    db.commit()\n    db.refresh(dashboard)\n    \n    logger.info(f\"Dashboard created: {current_user.username} - {dashboard_data.title}\")\n    \n    return DashboardResponse(\n        id=str(dashboard.id)",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.last_hit=datetime.utcnow()\n        )\n        db.add(cache_entry)\n        \n        # Update visualization metadata\n        visualization.last_generated = datetime.utcnow()\n        visualization.generation_time_ms = int(generation_time)\n        visualization.cache_key = cache_key\n        visualization.cache_expires = expires_at\n        \n        db.commit()\n        \n        # Track analytics\n        _track_visualization_access(db",
        "import:fastapi.visualization_type_id=str(visualization.visualization_type_id)",
        "import:fastapi.description=visualization.description",
        "import:fastapi.Dashboard",
        "import:fastapi.VisualizationCache.expires_at > datetime.utcnow()\n            )\n        ).first()\n        \n        if cached_data:\n            # Update cache hits\n            cached_data.hits += 1\n            cached_data.last_hit = datetime.utcnow()\n            db.commit()\n            \n            # Track analytics\n            _track_visualization_access(db",
        "import:fastapi.generation_time_ms=int(generation_time)",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.cache_expires=visualization.cache_expires",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.position_y=dashboard_viz.position_y",
        "import:fastapi.DataVisualization.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get visualizations\n    visualizations = query.order_by(desc(DataVisualization.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    viz_responses = []\n    for visualization in visualizations:\n        viz_responses.append(DataVisualizationResponse(\n            id=str(visualization.id)"
      ]
    },
    "GET:/user/{user_id}/saved-items": {
      "method": "GET",
      "path": "/user/{user_id}/saved-items",
      "file": "services/api-gateway/app/api/v1/saved_items.py",
      "line": 18,
      "dependencies": [
        "import:fastapi.Riding\n\nrouter = APIRouter()",
        "import:fastapi.Party",
        "import:fastapi.List",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Dict",
        "import:fastapi.ElectedMember",
        "import:fastapi.VoteQuestion",
        "import:fastapi.APIRouter",
        "import:fastapi.Politician",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional"
      ]
    },
    "POST:/user/{user_id}/save-item": {
      "method": "POST",
      "path": "/user/{user_id}/save-item",
      "file": "services/api-gateway/app/api/v1/saved_items.py",
      "line": 197,
      "dependencies": [
        "function:get_user_saved_items",
        "import:fastapi.\"introduced_date\": \"2025-01-10\"\n            }",
        "import:fastapi.\"last_updated\": \"2025-01-13T16:45:00Z\"\n        }",
        "import:fastapi.\"low\": len([item for item in filtered_items if item[\"priority\"] == \"low\"])\n            }\n        }\n    }",
        "import:fastapi.\"content_type\": \"bill\"",
        "import:fastapi.\"analysis\"",
        "import:fastapi.\"constituency\"",
        "import:fastapi.\"last_updated\": \"2025-01-12T09:15:00Z\"\n        }",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": len([item for item in filtered_items if item[\"content_type\"] == \"bill\"])",
        "import:fastapi.\"content_type\": \"vote\"",
        "import:fastapi.\"notes\": \"Interesting voting patterns on environmental bills\"",
        "import:fastapi.\"notes\": \"Important vote showing party divisions on environment\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"content_title\": \"Environmental Protection Act\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n        }",
        "import:fastapi.\"yes_votes\": 245",
        "import:fastapi.Politician",
        "import:fastapi.\"content_summary\": \"Second reading vote on Environmental Protection Act\"",
        "import:fastapi.ge=1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get user's saved items and bookmarks.\n    \"\"\"\n    # For now",
        "import:fastapi.description=\"Type of content to filter\")",
        "import:fastapi.\"saved_date\": \"2025-01-11T11:30:00Z\"",
        "import:fastapi.\"medium\": len([item for item in filtered_items if item[\"priority\"] == \"medium\"])",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.\"no_votes\": 93\n            }",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"content_summary\": \"Bill C-123 on environmental protection and climate action\"",
        "import:fastapi.\"Pollution Control\"]\n            }",
        "import:fastapi.\"by_priority\": {\n                \"high\": len([item for item in filtered_items if item[\"priority\"] == \"high\"])",
        "import:fastapi.le=100",
        "import:fastapi.\"focus_areas\": [\"Climate Change\"",
        "import:fastapi.\"tags\": tags",
        "import:fastapi.\"content_title\": \"Hon. Member Johnson\"",
        "import:fastapi.\"content_type\": \"debate\"",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"party_positions\"]",
        "import:fastapi.\"study\"]",
        "import:fastapi.\"committees\": len([item for item in filtered_items if item[\"content_type\"] == \"committee\"])",
        "import:fastapi.\"votes\": len([item for item in filtered_items if item[\"content_type\"] == \"vote\"])",
        "import:fastapi.content_type: Optional[str] = Query(None",
        "import:fastapi.\"voting\"",
        "import:fastapi.\"content_summary\": \"Parliamentary debate on government environmental initiatives\"",
        "import:fastapi.\"committee_memberships\": [\"Environment\"",
        "import:fastapi.\"policy\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/user/{user_id}/saved-items\")\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\"content_metadata\": {\n                \"committee_type\": \"Standing\"",
        "import:fastapi.\"content_metadata\": {\n                \"vote_date\": \"2025-01-13\"",
        "import:fastapi.\"legislation\"",
        "import:fastapi.\"tags\": [\"vote\"",
        "import:fastapi.\"content_id\": \"456\"",
        "import:fastapi.\"important\"]",
        "import:fastapi.\"content_id\": \"101\"",
        "import:fastapi.\"summary\": {\n            \"total_saved_items\": total",
        "import:fastapi.\"content_title\": \"Vote on Bill C-123\"",
        "import:fastapi.Depends",
        "import:fastapi.\"result\": \"Passed\"",
        "import:fastapi.\"tags\": [\"mp\"",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"last_updated\": \"2025-01-11T11:30:00Z\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_items = mock_saved_items\n    \n    if content_type:\n        filtered_items = [\n            item for item in filtered_items\n            if item[\"content_type\"] == content_type\n        ]\n    \n    if tags:\n        tag_list = [tag.strip().lower() for tag in tags.split(\"",
        "import:fastapi.Party",
        "import:fastapi.\"saved_date\": \"2025-01-12T09:15:00Z\"",
        "import:fastapi.description=\"Comma-separated tags to filter by\")",
        "import:fastapi.\"content_url\": \"/mps/456\"",
        "import:fastapi.\"content_id\": \"202\"",
        "import:fastapi.\"government\"",
        "import:fastapi.\"participants\": 15\n            }",
        "import:fastapi.\"content_url\": \"/bills/123\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"tags\": [\"committee\"",
        "import:fastapi.\"party\": \"Green\"",
        "import:fastapi.\"Health\"]\n            }",
        "import:fastapi.\"saved_date\": \"2025-01-13T16:45:00Z\"",
        "import:fastapi.\"content_url\": \"/committees/101\"",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"priority\": \"low\"",
        "import:fastapi.\"last_updated\": \"2025-01-14T14:20:00Z\"\n        }",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"content_id\": \"789\"",
        "import:fastapi.\"reminder_date\": \"2025-01-20T00:00:00Z\"",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.this would come from user bookmarks database\n    mock_saved_items = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"notes\": \"Good overview of government environmental priorities\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"duration\": \"2 hours 15 minutes\"",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }",
        "import:fastapi.Query",
        "import:fastapi.\"Biodiversity\"",
        "import:fastapi.\"priority\": \"high\"",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"sponsor\": \"Hon. Member Smith\"",
        "import:fastapi.{\n            \"id\": \"5\"",
        "import:fastapi.\"content_type\": \"mp\"",
        "import:fastapi.\"filters_applied\": {\n            \"content_type\": content_type",
        "import:fastapi.\"environment\"",
        "import:fastapi.\"content_summary\": \"Committee studying environmental legislation and policy\"",
        "import:fastapi.\"content_id\": \"123\"",
        "import:fastapi.\"total_votes\": 338",
        "import:fastapi.\"mps\": len([item for item in filtered_items if item[\"content_type\"] == \"mp\"])",
        "import:fastapi.\"tags\": [\"debate\"",
        "import:fastapi.\"reminder_date\": \"2025-02-01T00:00:00Z\"",
        "import:fastapi.\"notes\": \"Key committee for environmental policy development\"",
        "import:fastapi.\"content_type\": \"committee\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"notes\": \"Key bill to track for environmental policy\"",
        "import:fastapi.\"debate_type\": \"Government Orders\"",
        "import:fastapi.\"tags\": [\"environment\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\")]\n        filtered_items = [\n            item for item in filtered_items\n            if any(tag in [t.lower() for t in item[\"tags\"]] for tag in tag_list)\n        ]\n    \n    # Apply pagination\n    total = len(filtered_items)\n    offset = (page - 1) * page_size\n    paginated_items = filtered_items[offset:offset + page_size]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"research\"]",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"policy\"]",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.\"content_title\": \"Standing Committee on Environment\"",
        "import:fastapi.\"climate\"",
        "import:fastapi.\"debates\": len([item for item in filtered_items if item[\"content_type\"] == \"debate\"])\n            }",
        "import:fastapi.\"content_summary\": \"MP profile and voting record for Hon. Member Johnson\"",
        "import:fastapi.\"saved_date\": \"2025-01-14T14:20:00Z\"",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"reminder_date\": None",
        "import:fastapi.\"content_title\": \"Debate on Environmental Policy\"",
        "import:fastapi.\"results\": paginated_items",
        "import:fastapi.\"content_url\": \"/debates/202\"",
        "import:fastapi.{\n            \"id\": \"4\"",
        "import:fastapi.\"chair\": \"Hon. Member Davis\"",
        "import:fastapi.\"content_metadata\": {\n                \"debate_date\": \"2025-01-11\"",
        "import:fastapi.List",
        "import:fastapi.\"content_metadata\": {\n                \"constituency\": \"Vancouver Centre\"",
        "import:fastapi.create mock saved items data\n    # In a full implementation",
        "import:fastapi.\"experience\": \"2nd term\"",
        "import:fastapi.Dict",
        "import:fastapi.\"content_url\": \"/votes/789\"",
        "import:fastapi.\"saved_date\": \"2025-01-15T10:30:00Z\"",
        "import:fastapi.APIRouter",
        "import:fastapi.\"content_metadata\": {\n                \"bill_number\": \"C-123\"",
        "import:fastapi.\"status\": \"Second Reading\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "PUT:/user/{user_id}/saved-items/{item_id}": {
      "method": "PUT",
      "path": "/user/{user_id}/saved-items/{item_id}",
      "file": "services/api-gateway/app/api/v1/saved_items.py",
      "line": 238,
      "dependencies": [
        "import:fastapi.\"saved_item\": saved_item\n    }",
        "import:fastapi.\"introduced_date\": \"2025-01-10\"\n            }",
        "import:fastapi.\"last_updated\": \"2025-01-13T16:45:00Z\"\n        }",
        "import:fastapi.\"low\": len([item for item in filtered_items if item[\"priority\"] == \"low\"])\n            }\n        }\n    }\n\n\n@router.post(\"/user/{user_id}/save-item\")\nasync def save_item(\n    user_id: str",
        "import:fastapi.\"notes\": content_data.get(\"notes\"",
        "import:fastapi.\"content_type\": \"bill\"",
        "import:fastapi.\"analysis\"",
        "import:fastapi.\"priority\": content_data.get(\"priority\"",
        "import:fastapi.\"constituency\"",
        "import:fastapi.\"last_updated\": \"2025-01-12T09:15:00Z\"\n        }",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": len([item for item in filtered_items if item[\"content_type\"] == \"bill\"])",
        "import:fastapi.\"content_type\": \"vote\"",
        "import:fastapi.\"notes\": \"Interesting voting patterns on environmental bills\"",
        "import:fastapi.\"notes\": \"Important vote showing party divisions on environment\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"content_title\": \"Environmental Protection Act\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n        }",
        "import:fastapi.\"yes_votes\": 245",
        "import:fastapi.Politician",
        "import:fastapi.\"content_summary\": \"Second reading vote on Environmental Protection Act\"",
        "import:fastapi.ge=1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get user's saved items and bookmarks.\n    \"\"\"\n    # For now",
        "import:fastapi.description=\"Type of content to filter\")",
        "import:fastapi.\"saved_date\": \"2025-01-11T11:30:00Z\"",
        "import:fastapi.\"medium\": len([item for item in filtered_items if item[\"priority\"] == \"medium\"])",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.\"no_votes\": 93\n            }",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Save a new item to user's bookmarks.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"content_type\"",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"content_summary\": \"Bill C-123 on environmental protection and climate action\"",
        "import:fastapi.\"Pollution Control\"]\n            }",
        "import:fastapi.\"by_priority\": {\n                \"high\": len([item for item in filtered_items if item[\"priority\"] == \"high\"])",
        "import:fastapi.le=100",
        "import:fastapi.\"focus_areas\": [\"Climate Change\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.\"tags\": tags",
        "import:fastapi.[])",
        "import:fastapi.this would save to the database\n    saved_item = {\n        \"id\": \"new-item-id\"",
        "import:fastapi.\"content_title\": \"Hon. Member Johnson\"",
        "import:fastapi.\"content_type\": \"debate\"",
        "import:fastapi.return success response\n    # In a full implementation",
        "function:save_item",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"party_positions\"]",
        "import:fastapi.\"content_title\": content_data[\"content_title\"]",
        "import:fastapi.description=\"Content to save\")",
        "import:fastapi.\"reminder_date\": content_data.get(\"reminder_date\")",
        "import:fastapi.\"study\"]",
        "import:fastapi.\"committees\": len([item for item in filtered_items if item[\"content_type\"] == \"committee\"])",
        "import:fastapi.\"votes\": len([item for item in filtered_items if item[\"content_type\"] == \"vote\"])",
        "import:fastapi.content_type: Optional[str] = Query(None",
        "import:fastapi.\"voting\"",
        "import:fastapi.\"content_summary\": \"Parliamentary debate on government environmental initiatives\"",
        "import:fastapi.\"committee_memberships\": [\"Environment\"",
        "import:fastapi.\"policy\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/user/{user_id}/saved-items\")\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\"content_metadata\": {\n                \"committee_type\": \"Standing\"",
        "import:fastapi.\"content_metadata\": {\n                \"vote_date\": \"2025-01-13\"",
        "import:fastapi.\"legislation\"",
        "import:fastapi.\"tags\": [\"vote\"",
        "import:fastapi.\"content_id\": \"456\"",
        "import:fastapi.\"important\"]",
        "import:fastapi.\"content_type\": content_data[\"content_type\"]",
        "import:fastapi.\"content_id\": \"101\"",
        "import:fastapi.\"summary\": {\n            \"total_saved_items\": total",
        "import:fastapi.\"content_title\": \"Vote on Bill C-123\"",
        "import:fastapi.\"content_id\"",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.Depends",
        "import:fastapi.\"result\": \"Passed\"",
        "import:fastapi.\"\")",
        "import:fastapi.\"tags\": [\"mp\"",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"last_updated\": \"2025-01-11T11:30:00Z\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_items = mock_saved_items\n    \n    if content_type:\n        filtered_items = [\n            item for item in filtered_items\n            if item[\"content_type\"] == content_type\n        ]\n    \n    if tags:\n        tag_list = [tag.strip().lower() for tag in tags.split(\"",
        "import:fastapi.Party",
        "import:fastapi.\"saved_date\": \"2025-01-12T09:15:00Z\"",
        "import:fastapi.description=\"Comma-separated tags to filter by\")",
        "import:fastapi.\"content_url\": \"/mps/456\"",
        "import:fastapi.\"content_id\": \"202\"",
        "import:fastapi.\"government\"",
        "import:fastapi.\"participants\": 15\n            }",
        "import:fastapi.\"content_url\": \"/bills/123\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"tags\": [\"committee\"",
        "import:fastapi.\"party\": \"Green\"",
        "import:fastapi.\"Health\"]\n            }",
        "import:fastapi.\"saved_date\": \"2025-01-13T16:45:00Z\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"content_url\": \"/committees/101\"",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"priority\": \"low\"",
        "import:fastapi.\"last_updated\": \"2025-01-14T14:20:00Z\"\n        }",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"content_id\": \"789\"",
        "import:fastapi.\"reminder_date\": \"2025-01-20T00:00:00Z\"",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.this would come from user bookmarks database\n    mock_saved_items = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"tags\": content_data.get(\"tags\"",
        "import:fastapi.\"notes\": \"Good overview of government environmental priorities\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"duration\": \"2 hours 15 minutes\"",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }",
        "import:fastapi.\"content_id\": content_data[\"content_id\"]",
        "import:fastapi.Query",
        "import:fastapi.\"Biodiversity\"",
        "import:fastapi.\"priority\": \"high\"",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"sponsor\": \"Hon. Member Smith\"",
        "import:fastapi.{\n            \"id\": \"5\"",
        "import:fastapi.\"content_type\": \"mp\"",
        "import:fastapi.\"filters_applied\": {\n            \"content_type\": content_type",
        "import:fastapi.\"environment\"",
        "import:fastapi.\"content_summary\": \"Committee studying environmental legislation and policy\"",
        "import:fastapi.\"content_id\": \"123\"",
        "import:fastapi.\"total_votes\": 338",
        "import:fastapi.\"mps\": len([item for item in filtered_items if item[\"content_type\"] == \"mp\"])",
        "import:fastapi.\"tags\": [\"debate\"",
        "import:fastapi.\"reminder_date\": \"2025-02-01T00:00:00Z\"",
        "import:fastapi.\"notes\": \"Key committee for environmental policy development\"",
        "import:fastapi.\"content_type\": \"committee\"",
        "import:fastapi.\"message\": \"Item saved successfully\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"notes\": \"Key bill to track for environmental policy\"",
        "import:fastapi.\"debate_type\": \"Government Orders\"",
        "import:fastapi.\"tags\": [\"environment\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\")]\n        filtered_items = [\n            item for item in filtered_items\n            if any(tag in [t.lower() for t in item[\"tags\"]] for tag in tag_list)\n        ]\n    \n    # Apply pagination\n    total = len(filtered_items)\n    offset = (page - 1) * page_size\n    paginated_items = filtered_items[offset:offset + page_size]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"research\"]",
        "import:fastapi.\"medium\")",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"policy\"]",
        "import:fastapi.\"content_summary\": content_data.get(\"content_summary\"",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.\"content_url\": content_data.get(\"content_url\"",
        "import:fastapi.\"content_title\": \"Standing Committee on Environment\"",
        "import:fastapi.\"climate\"",
        "import:fastapi.{})",
        "import:fastapi.\"debates\": len([item for item in filtered_items if item[\"content_type\"] == \"debate\"])\n            }",
        "import:fastapi.\"content_summary\": \"MP profile and voting record for Hon. Member Johnson\"",
        "import:fastapi.\"saved_date\": \"2025-01-14T14:20:00Z\"",
        "import:fastapi.VoteQuestion",
        "import:fastapi.content_data: Dict[str",
        "import:fastapi.\"reminder_date\": None",
        "import:fastapi.\"content_title\": \"Debate on Environmental Policy\"",
        "import:fastapi.\"results\": paginated_items",
        "import:fastapi.\"content_url\": \"/debates/202\"",
        "import:fastapi.{\n            \"id\": \"4\"",
        "import:fastapi.\"chair\": \"Hon. Member Davis\"",
        "import:fastapi.\"content_metadata\": {\n                \"debate_date\": \"2025-01-11\"",
        "import:fastapi.\"content_metadata\": content_data.get(\"content_metadata\"",
        "import:fastapi.List",
        "import:fastapi.\"content_metadata\": {\n                \"constituency\": \"Vancouver Centre\"",
        "import:fastapi.create mock saved items data\n    # In a full implementation",
        "import:fastapi.\"experience\": \"2nd term\"",
        "import:fastapi.Dict",
        "import:fastapi.\"content_url\": \"/votes/789\"",
        "import:fastapi.\"saved_date\": \"2025-01-15T10:30:00Z\"",
        "import:fastapi.APIRouter",
        "import:fastapi.\"content_metadata\": {\n                \"bill_number\": \"C-123\"",
        "import:fastapi.\"content_title\"]\n    for field in required_fields:\n        if field not in content_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"status\": \"Second Reading\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "DELETE:/user/{user_id}/saved-items/{item_id}": {
      "method": "DELETE",
      "path": "/user/{user_id}/saved-items/{item_id}",
      "file": "services/api-gateway/app/api/v1/saved_items.py",
      "line": 269,
      "dependencies": [
        "import:fastapi.\"introduced_date\": \"2025-01-10\"\n            }",
        "import:fastapi.\"last_updated\": \"2025-01-13T16:45:00Z\"\n        }",
        "import:fastapi.\"low\": len([item for item in filtered_items if item[\"priority\"] == \"low\"])\n            }\n        }\n    }\n\n\n@router.post(\"/user/{user_id}/save-item\")\nasync def save_item(\n    user_id: str",
        "import:fastapi.\"notes\": content_data.get(\"notes\"",
        "import:fastapi.\"content_type\": \"bill\"",
        "import:fastapi.\"analysis\"",
        "import:fastapi.\"priority\": content_data.get(\"priority\"",
        "import:fastapi.\"constituency\"",
        "import:fastapi.\"last_updated\": \"2025-01-12T09:15:00Z\"\n        }",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": len([item for item in filtered_items if item[\"content_type\"] == \"bill\"])",
        "import:fastapi.\"content_type\": \"vote\"",
        "import:fastapi.\"notes\": \"Interesting voting patterns on environmental bills\"",
        "import:fastapi.\"saved_item\": saved_item\n    }\n\n\n@router.put(\"/user/{user_id}/saved-items/{item_id}\")\nasync def update_saved_item(\n    user_id: str",
        "import:fastapi.\"notes\": \"Important vote showing party divisions on environment\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"content_title\": \"Environmental Protection Act\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n        }",
        "import:fastapi.\"yes_votes\": 245",
        "import:fastapi.Politician",
        "import:fastapi.\"content_summary\": \"Second reading vote on Environmental Protection Act\"",
        "import:fastapi.ge=1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get user's saved items and bookmarks.\n    \"\"\"\n    # For now",
        "import:fastapi.description=\"Type of content to filter\")",
        "import:fastapi.\"saved_date\": \"2025-01-11T11:30:00Z\"",
        "import:fastapi.\"medium\": len([item for item in filtered_items if item[\"priority\"] == \"medium\"])",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.\"no_votes\": 93\n            }",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Save a new item to user's bookmarks.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"content_type\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update a saved item (tags",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"content_summary\": \"Bill C-123 on environmental protection and climate action\"",
        "import:fastapi.\"Pollution Control\"]\n            }",
        "import:fastapi.\"by_priority\": {\n                \"high\": len([item for item in filtered_items if item[\"priority\"] == \"high\"])",
        "import:fastapi.le=100",
        "import:fastapi.\"focus_areas\": [\"Climate Change\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.\"tags\": tags",
        "import:fastapi.[])",
        "import:fastapi.this would save to the database\n    saved_item = {\n        \"id\": \"new-item-id\"",
        "import:fastapi.\"content_title\": \"Hon. Member Johnson\"",
        "import:fastapi.\"content_type\": \"debate\"",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"party_positions\"]",
        "import:fastapi.\"content_title\": content_data[\"content_title\"]",
        "import:fastapi.description=\"Content to save\")",
        "import:fastapi.\"reminder_date\": content_data.get(\"reminder_date\")",
        "import:fastapi.description=\"Updated item data\")",
        "import:fastapi.\"study\"]",
        "import:fastapi.\"committees\": len([item for item in filtered_items if item[\"content_type\"] == \"committee\"])",
        "import:fastapi.\"votes\": len([item for item in filtered_items if item[\"content_type\"] == \"vote\"])",
        "import:fastapi.content_type: Optional[str] = Query(None",
        "import:fastapi.\"voting\"",
        "import:fastapi.\"content_summary\": \"Parliamentary debate on government environmental initiatives\"",
        "import:fastapi.\"committee_memberships\": [\"Environment\"",
        "import:fastapi.\"policy\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/user/{user_id}/saved-items\")\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\"reminder_date\"]\n    invalid_fields = [field for field in update_data.keys() if field not in allowed_fields]\n    \n    if invalid_fields:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.\"content_metadata\": {\n                \"committee_type\": \"Standing\"",
        "import:fastapi.\"content_metadata\": {\n                \"vote_date\": \"2025-01-13\"",
        "import:fastapi.\"legislation\"",
        "import:fastapi.\"tags\": [\"vote\"",
        "import:fastapi.\"content_id\": \"456\"",
        "import:fastapi.\"important\"]",
        "import:fastapi.\"content_type\": content_data[\"content_type\"]",
        "import:fastapi.\"content_id\": \"101\"",
        "import:fastapi.\"summary\": {\n            \"total_saved_items\": total",
        "import:fastapi.\"content_title\": \"Vote on Bill C-123\"",
        "import:fastapi.\"content_id\"",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.Depends",
        "import:fastapi.\"result\": \"Passed\"",
        "import:fastapi.\"\")",
        "import:fastapi.\"tags\": [\"mp\"",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"last_updated\": \"2025-01-11T11:30:00Z\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_items = mock_saved_items\n    \n    if content_type:\n        filtered_items = [\n            item for item in filtered_items\n            if item[\"content_type\"] == content_type\n        ]\n    \n    if tags:\n        tag_list = [tag.strip().lower() for tag in tags.split(\"",
        "import:fastapi.Party",
        "import:fastapi.notes",
        "import:fastapi.detail=f\"Invalid fields for update: {'",
        "import:fastapi.\"saved_date\": \"2025-01-12T09:15:00Z\"",
        "import:fastapi.description=\"Comma-separated tags to filter by\")",
        "import:fastapi.\"content_url\": \"/mps/456\"",
        "import:fastapi.\"content_id\": \"202\"",
        "import:fastapi.\"government\"",
        "import:fastapi.\"participants\": 15\n            }",
        "import:fastapi.\"item_id\": item_id",
        "import:fastapi.priority",
        "import:fastapi.\"content_url\": \"/bills/123\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"tags\": [\"committee\"",
        "import:fastapi.\"party\": \"Green\"",
        "import:fastapi.\"Health\"]\n            }",
        "import:fastapi.item_id: str",
        "import:fastapi.\"saved_date\": \"2025-01-13T16:45:00Z\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"content_url\": \"/committees/101\"",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"priority\": \"low\"",
        "import:fastapi.\"last_updated\": \"2025-01-14T14:20:00Z\"\n        }",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"content_id\": \"789\"",
        "import:fastapi.\"reminder_date\": \"2025-01-20T00:00:00Z\"",
        "import:fastapi.'.join(invalid_fields)}\"\n        )\n    \n    # For now",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.this would come from user bookmarks database\n    mock_saved_items = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"tags\": content_data.get(\"tags\"",
        "import:fastapi.update_data: Dict[str",
        "import:fastapi.\"updated_fields\": list(update_data.keys())",
        "import:fastapi.\"notes\": \"Good overview of government environmental priorities\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"duration\": \"2 hours 15 minutes\"",
        "function:update_saved_item",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }",
        "import:fastapi.\"content_id\": content_data[\"content_id\"]",
        "import:fastapi.Query",
        "import:fastapi.\"Biodiversity\"",
        "import:fastapi.\"priority\": \"high\"",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"sponsor\": \"Hon. Member Smith\"",
        "import:fastapi.this would update the database\n    return {\n        \"success\": True",
        "import:fastapi.{\n            \"id\": \"5\"",
        "import:fastapi.\"content_type\": \"mp\"",
        "import:fastapi.\"filters_applied\": {\n            \"content_type\": content_type",
        "import:fastapi.\"environment\"",
        "import:fastapi.\"content_summary\": \"Committee studying environmental legislation and policy\"",
        "import:fastapi.\"content_id\": \"123\"",
        "import:fastapi.\"total_votes\": 338",
        "import:fastapi.\"mps\": len([item for item in filtered_items if item[\"content_type\"] == \"mp\"])",
        "import:fastapi.\"tags\": [\"debate\"",
        "import:fastapi.\"reminder_date\": \"2025-02-01T00:00:00Z\"",
        "import:fastapi.\"notes\": \"Key committee for environmental policy development\"",
        "import:fastapi.\"content_type\": \"committee\"",
        "import:fastapi.\"message\": \"Item saved successfully\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"notes\": \"Key bill to track for environmental policy\"",
        "import:fastapi.\"debate_type\": \"Government Orders\"",
        "import:fastapi.\"tags\": [\"environment\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\")]\n        filtered_items = [\n            item for item in filtered_items\n            if any(tag in [t.lower() for t in item[\"tags\"]] for tag in tag_list)\n        ]\n    \n    # Apply pagination\n    total = len(filtered_items)\n    offset = (page - 1) * page_size\n    paginated_items = filtered_items[offset:offset + page_size]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"research\"]",
        "import:fastapi.\"medium\")",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"policy\"]",
        "import:fastapi.\"content_summary\": content_data.get(\"content_summary\"",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.\"content_url\": content_data.get(\"content_url\"",
        "import:fastapi.\"content_title\": \"Standing Committee on Environment\"",
        "import:fastapi.\"climate\"",
        "import:fastapi.\"updated_at\": \"2025-01-15T10:30:00Z\"\n    }",
        "import:fastapi.{})",
        "import:fastapi.\"debates\": len([item for item in filtered_items if item[\"content_type\"] == \"debate\"])\n            }",
        "import:fastapi.\"priority\"",
        "import:fastapi.\"message\": \"Item updated successfully\"",
        "import:fastapi.\"content_summary\": \"MP profile and voting record for Hon. Member Johnson\"",
        "import:fastapi.\"saved_date\": \"2025-01-14T14:20:00Z\"",
        "import:fastapi.VoteQuestion",
        "import:fastapi.content_data: Dict[str",
        "import:fastapi.\"reminder_date\": None",
        "import:fastapi.\"content_title\": \"Debate on Environmental Policy\"",
        "import:fastapi.\"results\": paginated_items",
        "import:fastapi.\"content_url\": \"/debates/202\"",
        "import:fastapi.{\n            \"id\": \"4\"",
        "import:fastapi.\"chair\": \"Hon. Member Davis\"",
        "import:fastapi.\"content_metadata\": {\n                \"debate_date\": \"2025-01-11\"",
        "import:fastapi.\"content_metadata\": content_data.get(\"content_metadata\"",
        "import:fastapi.List",
        "import:fastapi.\"notes\"",
        "import:fastapi.\"content_metadata\": {\n                \"constituency\": \"Vancouver Centre\"",
        "import:fastapi.create mock saved items data\n    # In a full implementation",
        "import:fastapi.\"experience\": \"2nd term\"",
        "import:fastapi.Dict",
        "import:fastapi.\"content_url\": \"/votes/789\"",
        "import:fastapi.\"saved_date\": \"2025-01-15T10:30:00Z\"",
        "import:fastapi.APIRouter",
        "import:fastapi.\"content_metadata\": {\n                \"bill_number\": \"C-123\"",
        "import:fastapi.\"content_title\"]\n    for field in required_fields:\n        if field not in content_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.etc.).\n    \"\"\"\n    # Validate update data\n    allowed_fields = [\"tags\"",
        "import:fastapi.\"status\": \"Second Reading\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/user/{user_id}/saved-items/tags": {
      "method": "GET",
      "path": "/user/{user_id}/saved-items/tags",
      "file": "services/api-gateway/app/api/v1/saved_items.py",
      "line": 288,
      "dependencies": [
        "import:fastapi.\"introduced_date\": \"2025-01-10\"\n            }",
        "import:fastapi.\"last_updated\": \"2025-01-13T16:45:00Z\"\n        }",
        "import:fastapi.\"low\": len([item for item in filtered_items if item[\"priority\"] == \"low\"])\n            }\n        }\n    }\n\n\n@router.post(\"/user/{user_id}/save-item\")\nasync def save_item(\n    user_id: str",
        "import:fastapi.\"notes\": content_data.get(\"notes\"",
        "import:fastapi.\"content_type\": \"bill\"",
        "import:fastapi.\"analysis\"",
        "import:fastapi.\"priority\": content_data.get(\"priority\"",
        "import:fastapi.\"constituency\"",
        "import:fastapi.\"last_updated\": \"2025-01-12T09:15:00Z\"\n        }",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": len([item for item in filtered_items if item[\"content_type\"] == \"bill\"])",
        "import:fastapi.\"content_type\": \"vote\"",
        "import:fastapi.\"notes\": \"Interesting voting patterns on environmental bills\"",
        "import:fastapi.\"saved_item\": saved_item\n    }\n\n\n@router.put(\"/user/{user_id}/saved-items/{item_id}\")\nasync def update_saved_item(\n    user_id: str",
        "import:fastapi.\"notes\": \"Important vote showing party divisions on environment\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"content_title\": \"Environmental Protection Act\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n        }",
        "import:fastapi.\"yes_votes\": 245",
        "import:fastapi.Politician",
        "import:fastapi.\"content_summary\": \"Second reading vote on Environmental Protection Act\"",
        "import:fastapi.ge=1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get user's saved items and bookmarks.\n    \"\"\"\n    # For now",
        "import:fastapi.description=\"Type of content to filter\")",
        "import:fastapi.\"saved_date\": \"2025-01-11T11:30:00Z\"",
        "import:fastapi.\"medium\": len([item for item in filtered_items if item[\"priority\"] == \"medium\"])",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.\"no_votes\": 93\n            }",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Save a new item to user's bookmarks.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"content_type\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update a saved item (tags",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"content_summary\": \"Bill C-123 on environmental protection and climate action\"",
        "import:fastapi.\"Pollution Control\"]\n            }",
        "import:fastapi.\"by_priority\": {\n                \"high\": len([item for item in filtered_items if item[\"priority\"] == \"high\"])",
        "import:fastapi.le=100",
        "import:fastapi.\"focus_areas\": [\"Climate Change\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.\"tags\": tags",
        "import:fastapi.[])",
        "import:fastapi.this would save to the database\n    saved_item = {\n        \"id\": \"new-item-id\"",
        "import:fastapi.\"content_title\": \"Hon. Member Johnson\"",
        "import:fastapi.\"content_type\": \"debate\"",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"party_positions\"]",
        "import:fastapi.\"content_title\": content_data[\"content_title\"]",
        "import:fastapi.description=\"Content to save\")",
        "import:fastapi.\"reminder_date\": content_data.get(\"reminder_date\")",
        "import:fastapi.description=\"Updated item data\")",
        "import:fastapi.\"study\"]",
        "import:fastapi.\"updated_at\": \"2025-01-15T10:30:00Z\"\n    }\n\n\n@router.delete(\"/user/{user_id}/saved-items/{item_id}\")\nasync def delete_saved_item(\n    user_id: str",
        "import:fastapi.\"committees\": len([item for item in filtered_items if item[\"content_type\"] == \"committee\"])",
        "import:fastapi.\"votes\": len([item for item in filtered_items if item[\"content_type\"] == \"vote\"])",
        "import:fastapi.content_type: Optional[str] = Query(None",
        "import:fastapi.\"voting\"",
        "import:fastapi.\"content_summary\": \"Parliamentary debate on government environmental initiatives\"",
        "import:fastapi.\"committee_memberships\": [\"Environment\"",
        "import:fastapi.\"policy\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/user/{user_id}/saved-items\")\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\"reminder_date\"]\n    invalid_fields = [field for field in update_data.keys() if field not in allowed_fields]\n    \n    if invalid_fields:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.\"content_metadata\": {\n                \"committee_type\": \"Standing\"",
        "import:fastapi.\"message\": \"Item removed successfully\"",
        "import:fastapi.\"content_metadata\": {\n                \"vote_date\": \"2025-01-13\"",
        "import:fastapi.\"legislation\"",
        "import:fastapi.\"tags\": [\"vote\"",
        "import:fastapi.\"content_id\": \"456\"",
        "import:fastapi.\"important\"]",
        "import:fastapi.\"content_type\": content_data[\"content_type\"]",
        "import:fastapi.\"content_id\": \"101\"",
        "import:fastapi.\"summary\": {\n            \"total_saved_items\": total",
        "import:fastapi.\"content_title\": \"Vote on Bill C-123\"",
        "import:fastapi.\"content_id\"",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.Depends",
        "import:fastapi.\"result\": \"Passed\"",
        "import:fastapi.\"\")",
        "import:fastapi.\"tags\": [\"mp\"",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"last_updated\": \"2025-01-11T11:30:00Z\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_items = mock_saved_items\n    \n    if content_type:\n        filtered_items = [\n            item for item in filtered_items\n            if item[\"content_type\"] == content_type\n        ]\n    \n    if tags:\n        tag_list = [tag.strip().lower() for tag in tags.split(\"",
        "import:fastapi.Party",
        "import:fastapi.notes",
        "import:fastapi.detail=f\"Invalid fields for update: {'",
        "import:fastapi.\"saved_date\": \"2025-01-12T09:15:00Z\"",
        "import:fastapi.description=\"Comma-separated tags to filter by\")",
        "import:fastapi.\"content_url\": \"/mps/456\"",
        "import:fastapi.\"content_id\": \"202\"",
        "import:fastapi.\"government\"",
        "import:fastapi.\"participants\": 15\n            }",
        "import:fastapi.\"item_id\": item_id",
        "import:fastapi.priority",
        "import:fastapi.\"deleted_at\": \"2025-01-15T10:30:00Z\"\n    }",
        "import:fastapi.\"content_url\": \"/bills/123\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"tags\": [\"committee\"",
        "import:fastapi.\"party\": \"Green\"",
        "import:fastapi.\"Health\"]\n            }",
        "import:fastapi.item_id: str",
        "import:fastapi.\"saved_date\": \"2025-01-13T16:45:00Z\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"content_url\": \"/committees/101\"",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"priority\": \"low\"",
        "import:fastapi.\"last_updated\": \"2025-01-14T14:20:00Z\"\n        }",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"content_id\": \"789\"",
        "import:fastapi.\"reminder_date\": \"2025-01-20T00:00:00Z\"",
        "import:fastapi.'.join(invalid_fields)}\"\n        )\n    \n    # For now",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.this would come from user bookmarks database\n    mock_saved_items = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.this would delete from the database\n    return {\n        \"success\": True",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"tags\": content_data.get(\"tags\"",
        "import:fastapi.update_data: Dict[str",
        "import:fastapi.\"updated_fields\": list(update_data.keys())",
        "import:fastapi.\"notes\": \"Good overview of government environmental priorities\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"duration\": \"2 hours 15 minutes\"",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }",
        "import:fastapi.\"content_id\": content_data[\"content_id\"]",
        "import:fastapi.Query",
        "import:fastapi.\"Biodiversity\"",
        "import:fastapi.\"priority\": \"high\"",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"sponsor\": \"Hon. Member Smith\"",
        "import:fastapi.this would update the database\n    return {\n        \"success\": True",
        "import:fastapi.{\n            \"id\": \"5\"",
        "import:fastapi.\"content_type\": \"mp\"",
        "import:fastapi.\"filters_applied\": {\n            \"content_type\": content_type",
        "import:fastapi.\"environment\"",
        "import:fastapi.\"content_summary\": \"Committee studying environmental legislation and policy\"",
        "import:fastapi.\"content_id\": \"123\"",
        "import:fastapi.\"total_votes\": 338",
        "import:fastapi.\"mps\": len([item for item in filtered_items if item[\"content_type\"] == \"mp\"])",
        "import:fastapi.\"tags\": [\"debate\"",
        "import:fastapi.\"reminder_date\": \"2025-02-01T00:00:00Z\"",
        "import:fastapi.\"notes\": \"Key committee for environmental policy development\"",
        "import:fastapi.\"content_type\": \"committee\"",
        "import:fastapi.\"message\": \"Item saved successfully\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"notes\": \"Key bill to track for environmental policy\"",
        "import:fastapi.\"debate_type\": \"Government Orders\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Remove an item from user's saved items.\n    \"\"\"\n    # For now",
        "import:fastapi.\"tags\": [\"environment\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\")]\n        filtered_items = [\n            item for item in filtered_items\n            if any(tag in [t.lower() for t in item[\"tags\"]] for tag in tag_list)\n        ]\n    \n    # Apply pagination\n    total = len(filtered_items)\n    offset = (page - 1) * page_size\n    paginated_items = filtered_items[offset:offset + page_size]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"research\"]",
        "import:fastapi.\"medium\")",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"policy\"]",
        "import:fastapi.\"content_summary\": content_data.get(\"content_summary\"",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.{\n            \"id\": \"3\"",
        "function:delete_saved_item",
        "import:fastapi.\"content_url\": content_data.get(\"content_url\"",
        "import:fastapi.\"content_title\": \"Standing Committee on Environment\"",
        "import:fastapi.\"climate\"",
        "import:fastapi.{})",
        "import:fastapi.\"debates\": len([item for item in filtered_items if item[\"content_type\"] == \"debate\"])\n            }",
        "import:fastapi.\"priority\"",
        "import:fastapi.\"message\": \"Item updated successfully\"",
        "import:fastapi.\"content_summary\": \"MP profile and voting record for Hon. Member Johnson\"",
        "import:fastapi.\"saved_date\": \"2025-01-14T14:20:00Z\"",
        "import:fastapi.VoteQuestion",
        "import:fastapi.content_data: Dict[str",
        "import:fastapi.\"reminder_date\": None",
        "import:fastapi.\"content_title\": \"Debate on Environmental Policy\"",
        "import:fastapi.\"results\": paginated_items",
        "import:fastapi.\"content_url\": \"/debates/202\"",
        "import:fastapi.{\n            \"id\": \"4\"",
        "import:fastapi.\"chair\": \"Hon. Member Davis\"",
        "import:fastapi.\"content_metadata\": {\n                \"debate_date\": \"2025-01-11\"",
        "import:fastapi.\"content_metadata\": content_data.get(\"content_metadata\"",
        "import:fastapi.List",
        "import:fastapi.\"notes\"",
        "import:fastapi.\"content_metadata\": {\n                \"constituency\": \"Vancouver Centre\"",
        "import:fastapi.create mock saved items data\n    # In a full implementation",
        "import:fastapi.\"experience\": \"2nd term\"",
        "import:fastapi.Dict",
        "import:fastapi.\"content_url\": \"/votes/789\"",
        "import:fastapi.\"saved_date\": \"2025-01-15T10:30:00Z\"",
        "import:fastapi.APIRouter",
        "import:fastapi.\"content_metadata\": {\n                \"bill_number\": \"C-123\"",
        "import:fastapi.\"content_title\"]\n    for field in required_fields:\n        if field not in content_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.etc.).\n    \"\"\"\n    # Validate update data\n    allowed_fields = [\"tags\"",
        "import:fastapi.\"status\": \"Second Reading\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/user/{user_id}/saved-items/search": {
      "method": "GET",
      "path": "/user/{user_id}/saved-items/search",
      "file": "services/api-gateway/app/api/v1/saved_items.py",
      "line": 323,
      "dependencies": [
        "import:fastapi.\"introduced_date\": \"2025-01-10\"\n            }",
        "import:fastapi.\"last_updated\": \"2025-01-13T16:45:00Z\"\n        }",
        "import:fastapi.\"low\": len([item for item in filtered_items if item[\"priority\"] == \"low\"])\n            }\n        }\n    }\n\n\n@router.post(\"/user/{user_id}/save-item\")\nasync def save_item(\n    user_id: str",
        "import:fastapi.{\"tag\": \"committee\"",
        "import:fastapi.\"notes\": content_data.get(\"notes\"",
        "import:fastapi.\"content_type\": \"bill\"",
        "import:fastapi.\"analysis\"",
        "import:fastapi.\"priority\": content_data.get(\"priority\"",
        "import:fastapi.\"constituency\"",
        "import:fastapi.\"last_updated\": \"2025-01-12T09:15:00Z\"\n        }",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": len([item for item in filtered_items if item[\"content_type\"] == \"bill\"])",
        "import:fastapi.\"content_type\": \"vote\"",
        "import:fastapi.\"notes\": \"Interesting voting patterns on environmental bills\"",
        "import:fastapi.\"saved_item\": saved_item\n    }\n\n\n@router.put(\"/user/{user_id}/saved-items/{item_id}\")\nasync def update_saved_item(\n    user_id: str",
        "import:fastapi.\"notes\": \"Important vote showing party divisions on environment\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"content_title\": \"Environmental Protection Act\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n        }",
        "import:fastapi.\"yes_votes\": 245",
        "import:fastapi.Politician",
        "import:fastapi.\"content_summary\": \"Second reading vote on Environmental Protection Act\"",
        "import:fastapi.{\"tag\": \"policy\"",
        "import:fastapi.ge=1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get user's saved items and bookmarks.\n    \"\"\"\n    # For now",
        "import:fastapi.description=\"Type of content to filter\")",
        "import:fastapi.\"saved_date\": \"2025-01-11T11:30:00Z\"",
        "import:fastapi.\"medium\": len([item for item in filtered_items if item[\"priority\"] == \"medium\"])",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.\"no_votes\": 93\n            }",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Save a new item to user's bookmarks.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"content_type\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update a saved item (tags",
        "import:fastapi.\"last_used\": \"2025-01-11T11:30:00Z\"}\n    ]\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"content_summary\": \"Bill C-123 on environmental protection and climate action\"",
        "import:fastapi.\"Pollution Control\"]\n            }",
        "import:fastapi.\"by_priority\": {\n                \"high\": len([item for item in filtered_items if item[\"priority\"] == \"high\"])",
        "import:fastapi.le=100",
        "import:fastapi.\"deleted_at\": \"2025-01-15T10:30:00Z\"\n    }\n\n\n@router.get(\"/user/{user_id}/saved-items/tags\")\nasync def get_user_tags(\n    user_id: str",
        "import:fastapi.\"focus_areas\": [\"Climate Change\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.{\"tag\": \"legislation\"",
        "import:fastapi.\"tags\": tags",
        "import:fastapi.[])",
        "import:fastapi.this would save to the database\n    saved_item = {\n        \"id\": \"new-item-id\"",
        "import:fastapi.\"count\": 8",
        "import:fastapi.\"content_title\": \"Hon. Member Johnson\"",
        "import:fastapi.\"content_type\": \"debate\"",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.{\"tag\": \"government\"",
        "import:fastapi.\"most_used_tags\": [tag[\"tag\"] for tag in sorted(mock_tags",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"party_positions\"]",
        "import:fastapi.\"content_title\": content_data[\"content_title\"]",
        "import:fastapi.description=\"Content to save\")",
        "import:fastapi.\"reminder_date\": content_data.get(\"reminder_date\")",
        "import:fastapi.description=\"Updated item data\")",
        "import:fastapi.\"study\"]",
        "import:fastapi.\"updated_at\": \"2025-01-15T10:30:00Z\"\n    }\n\n\n@router.delete(\"/user/{user_id}/saved-items/{item_id}\")\nasync def delete_saved_item(\n    user_id: str",
        "import:fastapi.\"committees\": len([item for item in filtered_items if item[\"content_type\"] == \"committee\"])",
        "import:fastapi.\"votes\": len([item for item in filtered_items if item[\"content_type\"] == \"vote\"])",
        "import:fastapi.content_type: Optional[str] = Query(None",
        "import:fastapi.\"voting\"",
        "import:fastapi.\"content_summary\": \"Parliamentary debate on government environmental initiatives\"",
        "import:fastapi.\"committee_memberships\": [\"Environment\"",
        "import:fastapi.\"policy\"",
        "import:fastapi.\"count\": 3",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/user/{user_id}/saved-items\")\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\"total_tags\": len(mock_tags)",
        "import:fastapi.\"reminder_date\"]\n    invalid_fields = [field for field in update_data.keys() if field not in allowed_fields]\n    \n    if invalid_fields:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.{\"tag\": \"voting\"",
        "import:fastapi.{\"tag\": \"study\"",
        "import:fastapi.\"content_metadata\": {\n                \"committee_type\": \"Standing\"",
        "import:fastapi.\"message\": \"Item removed successfully\"",
        "import:fastapi.\"content_metadata\": {\n                \"vote_date\": \"2025-01-13\"",
        "import:fastapi.\"legislation\"",
        "import:fastapi.{\"tag\": \"analysis\"",
        "import:fastapi.\"tags\": [\"vote\"",
        "import:fastapi.\"content_id\": \"456\"",
        "import:fastapi.\"important\"]",
        "import:fastapi.\"content_type\": content_data[\"content_type\"]",
        "import:fastapi.\"content_id\": \"101\"",
        "import:fastapi.\"summary\": {\n            \"total_saved_items\": total",
        "import:fastapi.\"content_title\": \"Vote on Bill C-123\"",
        "import:fastapi.\"last_used\": \"2025-01-15T10:30:00Z\"}",
        "import:fastapi.\"content_id\"",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.Depends",
        "import:fastapi.\"last_used\": \"2025-01-13T16:45:00Z\"}",
        "import:fastapi.\"result\": \"Passed\"",
        "import:fastapi.\"\")",
        "import:fastapi.\"tags\": [\"mp\"",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.create mock tags data\n    # In a full implementation",
        "import:fastapi.\"last_updated\": \"2025-01-11T11:30:00Z\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_items = mock_saved_items\n    \n    if content_type:\n        filtered_items = [\n            item for item in filtered_items\n            if item[\"content_type\"] == content_type\n        ]\n    \n    if tags:\n        tag_list = [tag.strip().lower() for tag in tags.split(\"",
        "import:fastapi.Party",
        "import:fastapi.notes",
        "import:fastapi.detail=f\"Invalid fields for update: {'",
        "import:fastapi.\"saved_date\": \"2025-01-12T09:15:00Z\"",
        "import:fastapi.description=\"Comma-separated tags to filter by\")",
        "import:fastapi.\"content_url\": \"/mps/456\"",
        "import:fastapi.\"content_id\": \"202\"",
        "import:fastapi.\"government\"",
        "import:fastapi.\"participants\": 15\n            }",
        "import:fastapi.\"item_id\": item_id",
        "import:fastapi.priority",
        "import:fastapi.\"tags\": mock_tags",
        "import:fastapi.\"content_url\": \"/bills/123\"",
        "import:fastapi.\"last_used\": \"2025-01-11T11:30:00Z\"}",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"tags\": [\"committee\"",
        "import:fastapi.\"party\": \"Green\"",
        "import:fastapi.\"Health\"]\n            }",
        "import:fastapi.item_id: str",
        "import:fastapi.\"saved_date\": \"2025-01-13T16:45:00Z\"",
        "import:fastapi.\"last_updated\": \"2025-01-15T10:30:00Z\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"last_used\": \"2025-01-14T14:20:00Z\"}",
        "import:fastapi.\"content_url\": \"/committees/101\"",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"priority\": \"low\"",
        "import:fastapi.\"last_updated\": \"2025-01-14T14:20:00Z\"\n        }",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"content_id\": \"789\"",
        "import:fastapi.\"reminder_date\": \"2025-01-20T00:00:00Z\"",
        "import:fastapi.'.join(invalid_fields)}\"\n        )\n    \n    # For now",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.this would come from user bookmarks database\n    mock_saved_items = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.this would delete from the database\n    return {\n        \"success\": True",
        "import:fastapi.key=lambda x: x[\"count\"]",
        "import:fastapi.{\"tag\": \"climate\"",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"tags\": content_data.get(\"tags\"",
        "import:fastapi.update_data: Dict[str",
        "import:fastapi.\"updated_fields\": list(update_data.keys())",
        "import:fastapi.\"notes\": \"Good overview of government environmental priorities\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"duration\": \"2 hours 15 minutes\"",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }",
        "import:fastapi.\"content_id\": content_data[\"content_id\"]",
        "import:fastapi.Query",
        "import:fastapi.\"Biodiversity\"",
        "import:fastapi.{\"tag\": \"research\"",
        "import:fastapi.\"priority\": \"high\"",
        "import:fastapi.\"count\": 1",
        "import:fastapi.\"count\": 5",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"sponsor\": \"Hon. Member Smith\"",
        "import:fastapi.this would update the database\n    return {\n        \"success\": True",
        "import:fastapi.{\n            \"id\": \"5\"",
        "import:fastapi.\"content_type\": \"mp\"",
        "import:fastapi.\"filters_applied\": {\n            \"content_type\": content_type",
        "import:fastapi.\"environment\"",
        "import:fastapi.{\"tag\": \"mp\"",
        "import:fastapi.\"content_summary\": \"Committee studying environmental legislation and policy\"",
        "import:fastapi.\"content_id\": \"123\"",
        "import:fastapi.\"total_votes\": 338",
        "import:fastapi.\"last_used\": \"2025-01-12T09:15:00Z\"}",
        "import:fastapi.\"mps\": len([item for item in filtered_items if item[\"content_type\"] == \"mp\"])",
        "import:fastapi.\"tags\": [\"debate\"",
        "import:fastapi.\"reminder_date\": \"2025-02-01T00:00:00Z\"",
        "import:fastapi.\"notes\": \"Key committee for environmental policy development\"",
        "import:fastapi.\"content_type\": \"committee\"",
        "import:fastapi.\"message\": \"Item saved successfully\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"notes\": \"Key bill to track for environmental policy\"",
        "import:fastapi.\"debate_type\": \"Government Orders\"",
        "function:get_user_tags",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Remove an item from user's saved items.\n    \"\"\"\n    # For now",
        "import:fastapi.\"tags\": [\"environment\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\")]\n        filtered_items = [\n            item for item in filtered_items\n            if any(tag in [t.lower() for t in item[\"tags\"]] for tag in tag_list)\n        ]\n    \n    # Apply pagination\n    total = len(filtered_items)\n    offset = (page - 1) * page_size\n    paginated_items = filtered_items[offset:offset + page_size]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"research\"]",
        "import:fastapi.\"medium\")",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"policy\"]",
        "import:fastapi.\"content_summary\": content_data.get(\"content_summary\"",
        "import:fastapi.{\"tag\": \"constituency\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get all tags used by the user across their saved items.\n    \"\"\"\n    # For now",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.reverse=True)[:5]]\n    }",
        "import:fastapi.\"content_url\": content_data.get(\"content_url\"",
        "import:fastapi.\"content_title\": \"Standing Committee on Environment\"",
        "import:fastapi.\"climate\"",
        "import:fastapi.{})",
        "import:fastapi.\"debates\": len([item for item in filtered_items if item[\"content_type\"] == \"debate\"])\n            }",
        "import:fastapi.\"priority\"",
        "import:fastapi.this would aggregate from the database\n    mock_tags = [\n        {\"tag\": \"environment\"",
        "import:fastapi.\"message\": \"Item updated successfully\"",
        "import:fastapi.{\"tag\": \"party_positions\"",
        "import:fastapi.\"content_summary\": \"MP profile and voting record for Hon. Member Johnson\"",
        "import:fastapi.\"saved_date\": \"2025-01-14T14:20:00Z\"",
        "import:fastapi.VoteQuestion",
        "import:fastapi.content_data: Dict[str",
        "import:fastapi.\"reminder_date\": None",
        "import:fastapi.\"content_title\": \"Debate on Environmental Policy\"",
        "import:fastapi.\"results\": paginated_items",
        "import:fastapi.\"content_url\": \"/debates/202\"",
        "import:fastapi.{\"tag\": \"important\"",
        "import:fastapi.{\n            \"id\": \"4\"",
        "import:fastapi.\"count\": 2",
        "import:fastapi.\"chair\": \"Hon. Member Davis\"",
        "import:fastapi.\"content_metadata\": {\n                \"debate_date\": \"2025-01-11\"",
        "import:fastapi.\"count\": 4",
        "import:fastapi.\"content_metadata\": content_data.get(\"content_metadata\"",
        "import:fastapi.List",
        "import:fastapi.\"notes\"",
        "import:fastapi.\"content_metadata\": {\n                \"constituency\": \"Vancouver Centre\"",
        "import:fastapi.create mock saved items data\n    # In a full implementation",
        "import:fastapi.\"experience\": \"2nd term\"",
        "import:fastapi.Dict",
        "import:fastapi.\"content_url\": \"/votes/789\"",
        "import:fastapi.\"saved_date\": \"2025-01-15T10:30:00Z\"",
        "import:fastapi.APIRouter",
        "import:fastapi.\"content_metadata\": {\n                \"bill_number\": \"C-123\"",
        "import:fastapi.\"content_title\"]\n    for field in required_fields:\n        if field not in content_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.etc.).\n    \"\"\"\n    # Validate update data\n    allowed_fields = [\"tags\"",
        "import:fastapi.\"count\": 6",
        "import:fastapi.\"status\": \"Second Reading\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/{year}/{month}/{day}/": {
      "method": "GET",
      "path": "/{year}/{month}/{day}/",
      "file": "services/api-gateway/app/api/v1/debates.py",
      "line": 115,
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/speeches/": {
      "method": "GET",
      "path": "/speeches/",
      "file": "services/api-gateway/app/api/v1/debates.py",
      "line": 163,
      "dependencies": [
        "function:get_debate_detail",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.detail=\"Invalid date\")\n    \n    # Get all votes for this date\n    votes = db.query(Vote).filter(\n        and_(\n            Vote.vote_date >= datetime.combine(debate_date",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.number=day",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/votes/{vote.id}/\"\n        ))\n    \n    return DebateDetailResponse(\n        id=f\"{year}-{month:02d}-{day:02d}\"",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.day: int",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.content=vote.vote_type",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.statement_count=len(votes)",
        "import:fastapi.and_",
        "import:fastapi.votes=vote_summaries\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific House debate by date.\n    \"\"\"\n    \n    try:\n        debate_date = date(year",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{year}/{month}/{day}/\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.detail=\"No debate found for this date\")\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        vote_summaries.append(SpeechSummary(\n            id=str(vote.id)",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateDetailResponse)\nasync def get_debate_detail(\n    year: int",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.month: int",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.day)\n    except ValueError:\n        raise HTTPException(status_code=400",
        "import:fastapi.bill_id=str(vote.bill_id) if vote.bill_id else None",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.date=debate_date.isoformat()",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.datetime.max.time())\n        )\n    ).order_by(Vote.vote_date).all()\n    \n    if not votes:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.month",
        "import:fastapi.HTTPException",
        "import:fastapi.speaker_name=f\"Vote on {vote.bill.title if vote.bill else 'Unknown Bill'}\"",
        "import:fastapi.time=vote.vote_date"
      ]
    },
    "GET:/speeches/{speech_id}/": {
      "method": "GET",
      "path": "/speeches/{speech_id}/",
      "file": "services/api-gateway/app/api/v1/debates.py",
      "line": 261,
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.response_model=SpeechListResponse)\nasync def list_speeches(\n    politician: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.description=\"Politician name filter\")",
        "import:fastapi.detail=\"No debate found for this date\")\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        vote_summaries.append(SpeechSummary(\n            id=str(vote.id)",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List speeches/statements with comprehensive filtering.\n    \n    Based on legacy SpeechesView functionality.\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Statement).join(Politician",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.date=debate_date.isoformat()",
        "import:fastapi.DebateDetail",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if politician:\n        query = query.filter(Politician.name.ilike(f\"%{politician}%\"))\n    \n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.HTTPException",
        "import:fastapi.speaker_name=f\"Vote on {vote.bill.title if vote.bill else 'Unknown Bill'}\"",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.SpeechSummary",
        "import:fastapi.number=day",
        "function:list_speeches",
        "import:fastapi.Bill.number == bill_number)\n            )\n    \n    if mentioned_politician:\n        # Search for statements that mention a specific politician\n        # This searches in the statement content for politician names\n        query = query.filter(\n            Statement.content_en.ilike(f\"%{mentioned_politician}%\") |\n            Statement.content_fr.ilike(f\"%{mentioned_politician}%\")\n        )\n    \n    # Order by time descending (most recent first)\n    query = query.order_by(desc(Statement.time))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    statements = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    speeches = []\n    for stmt in statements:\n        # Choose content based on language preference\n        content = stmt.content_fr if lang == \"fr\" and stmt.content_fr else stmt.content_en\n        text_preview = content[:200] + \"...\" if content and len(content) > 200 else (content or \"No content available\")\n        \n        speeches.append(SpeechSummary(\n            id=str(stmt.id)",
        "import:fastapi.url=f\"/api/v1/debates/speeches/{stmt.id}/\"\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.content=vote.vote_type",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific House debate by date.\n    \"\"\"\n    \n    try:\n        debate_date = date(year",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.'45-1')\")",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.bill_id=str(vote.bill_id) if vote.bill_id else None",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(Statement.time >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Statement.politician_id == Politician.id",
        "import:fastapi.votes=vote_summaries\n    )\n\n\n@router.get(\"/speeches/\"",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.datetime.max.time())\n        )\n    ).order_by(Vote.vote_date).all()\n    \n    if not votes:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.1)\n            query = query.join(Bill",
        "import:fastapi.month",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.time=stmt.time",
        "import:fastapi.url=f\"/api/v1/votes/{vote.id}/\"\n        ))\n    \n    return DebateDetailResponse(\n        id=f\"{year}-{month:02d}-{day:02d}\"",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.day: int",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.description=\"Mentioned politician filter\")",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.statement_count=len(votes)",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(Statement.time <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.bill_mentioned=str(stmt.bill_debated_id) if stmt.bill_debated_id else None",
        "import:fastapi.pages=total_pages\n    )\n    \n    return SpeechListResponse(\n        speeches=speeches",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Statement.bill_id == Bill.id",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.isouter=True).filter(\n                and_(Bill.session_id == session_id",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.date=stmt.time.date() if stmt.time else None",
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.text_preview=text_preview",
        "import:fastapi.detail=\"Invalid date\")\n    \n    # Get all votes for this date\n    votes = db.query(Vote).filter(\n        and_(\n            Vote.vote_date >= datetime.combine(debate_date",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.politician_name=stmt.politician.name if stmt.politician else \"Unknown\"",
        "import:fastapi.mentioned_politician: Optional[str] = Query(None",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{year}/{month}/{day}/\"",
        "import:fastapi.response_model=DebateDetailResponse)\nasync def get_debate_detail(\n    year: int",
        "import:fastapi.month: int",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.APIRouter",
        "import:fastapi.day)\n    except ValueError:\n        raise HTTPException(status_code=400",
        "import:fastapi.time=vote.vote_date"
      ]
    },
    "GET:/{date}/statements": {
      "method": "GET",
      "path": "/{date}/statements",
      "file": "services/api-gateway/app/api/v1/debates.py",
      "line": 296,
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.h1_en=statement.h1_en",
        "import:fastapi.h2_en=statement.h2_en",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/speeches/{speech_id}/\"",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.response_model=SpeechListResponse)\nasync def list_speeches(\n    politician: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.description=\"Politician name filter\")",
        "import:fastapi.detail=\"No debate found for this date\")\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        vote_summaries.append(SpeechSummary(\n            id=str(vote.id)",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.detail=\"Speech not found\")\n    \n    speech_detail = SpeechDetail(\n        id=str(statement.id)",
        "import:fastapi.date=statement.time.date() if statement.time else None",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.time=statement.time",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List speeches/statements with comprehensive filtering.\n    \n    Based on legacy SpeechesView functionality.\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Statement).join(Politician",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "function:get_speech_detail",
        "import:fastapi.DebateDetail",
        "import:fastapi.date=debate_date.isoformat()",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if politician:\n        query = query.filter(Politician.name.ilike(f\"%{politician}%\"))\n    \n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.sequence=statement.sequence\n    )\n    \n    return SpeechDetailResponse(speech=speech_detail)",
        "import:fastapi.HTTPException",
        "import:fastapi.speaker_name=f\"Vote on {vote.bill.title if vote.bill else 'Unknown Bill'}\"",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.text_en=statement.content_en or \"No content available\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.SpeechSummary",
        "import:fastapi.number=day",
        "import:fastapi.Bill.number == bill_number)\n            )\n    \n    if mentioned_politician:\n        # Search for statements that mention a specific politician\n        # This searches in the statement content for politician names\n        query = query.filter(\n            Statement.content_en.ilike(f\"%{mentioned_politician}%\") |\n            Statement.content_fr.ilike(f\"%{mentioned_politician}%\")\n        )\n    \n    # Order by time descending (most recent first)\n    query = query.order_by(desc(Statement.time))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    statements = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    speeches = []\n    for stmt in statements:\n        # Choose content based on language preference\n        content = stmt.content_fr if lang == \"fr\" and stmt.content_fr else stmt.content_en\n        text_preview = content[:200] + \"...\" if content and len(content) > 200 else (content or \"No content available\")\n        \n        speeches.append(SpeechSummary(\n            id=str(stmt.id)",
        "import:fastapi.h1_fr=statement.h1_fr",
        "import:fastapi.url=f\"/api/v1/debates/speeches/{stmt.id}/\"\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.response_model=SpeechDetailResponse)\nasync def get_speech_detail(\n    speech_id: int",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.content=vote.vote_type",
        "import:fastapi.and_",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific House debate by date.\n    \"\"\"\n    \n    try:\n        debate_date = date(year",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.h2_fr=statement.h2_fr",
        "import:fastapi.'45-1')\")",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.bill_id=str(vote.bill_id) if vote.bill_id else None",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(Statement.time >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Statement.politician_id == Politician.id",
        "import:fastapi.votes=vote_summaries\n    )\n\n\n@router.get(\"/speeches/\"",
        "import:fastapi.bill_mentioned=str(statement.bill_debated_id) if statement.bill_debated_id else None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific speech/statement.\n    \"\"\"\n    \n    statement = db.query(Statement).filter(Statement.id == speech_id).first()\n    \n    if not statement:\n        raise HTTPException(status_code=404",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.datetime.max.time())\n        )\n    ).order_by(Vote.vote_date).all()\n    \n    if not votes:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.1)\n            query = query.join(Bill",
        "import:fastapi.month",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.time=stmt.time",
        "import:fastapi.constituency=statement.member.riding.name_en if statement.member and statement.member.riding else None",
        "import:fastapi.politician_name=statement.politician.name if statement.politician else \"Unknown\"",
        "import:fastapi.url=f\"/api/v1/votes/{vote.id}/\"\n        ))\n    \n    return DebateDetailResponse(\n        id=f\"{year}-{month:02d}-{day:02d}\"",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.day: int",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.description=\"Mentioned politician filter\")",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.statement_count=len(votes)",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(Statement.time <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.bill_mentioned=str(stmt.bill_debated_id) if stmt.bill_debated_id else None",
        "import:fastapi.pages=total_pages\n    )\n    \n    return SpeechListResponse(\n        speeches=speeches",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Statement.bill_id == Bill.id",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.isouter=True).filter(\n                and_(Bill.session_id == session_id",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.date=stmt.time.date() if stmt.time else None",
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.text_preview=text_preview",
        "import:fastapi.detail=\"Invalid date\")\n    \n    # Get all votes for this date\n    votes = db.query(Vote).filter(\n        and_(\n            Vote.vote_date >= datetime.combine(debate_date",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.politician_name=stmt.politician.name if stmt.politician else \"Unknown\"",
        "import:fastapi.mentioned_politician: Optional[str] = Query(None",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{year}/{month}/{day}/\"",
        "import:fastapi.response_model=DebateDetailResponse)\nasync def get_debate_detail(\n    year: int",
        "import:fastapi.month: int",
        "import:fastapi.text_fr=statement.content_fr",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.party_name=statement.member.party.name_en if statement.member and statement.member.party else None",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.APIRouter",
        "import:fastapi.day)\n    except ValueError:\n        raise HTTPException(status_code=400",
        "import:fastapi.sitting_id=statement.sequence",
        "import:fastapi.time=vote.vote_date"
      ]
    },
    "GET:/{session_id}/{vote_number}": {
      "method": "GET",
      "path": "/{session_id}/{vote_number}",
      "file": "services/api-gateway/app/api/v1/votes.py",
      "line": 147,
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    "GET:/ballots/": {
      "method": "GET",
      "path": "/ballots/",
      "file": "services/api-gateway/app/api/v1/votes.py",
      "line": 209,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.parties_yea=parties_y",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.Vote.number == vote_number\n    ).first()\n    \n    if not vote:\n        raise HTTPException(status_code=404",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.le=100",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.number=vote.number",
        "import:fastapi.HTTPException",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{session_id}/{vote_number}\"",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.response_model=VoteDetailResponse)\nasync def get_vote_detail(\n    session_id: str",
        "import:fastapi.parties_nay=parties_n\n    )\n    \n    return VoteDetailResponse(vote=vote_detail)",
        "import:fastapi.\"bill_title\": vote.bill.name_en",
        "import:fastapi.VoteListResponse",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "function:get_vote_detail",
        "import:fastapi.bill_title=vote.bill.name_en",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.VoteDetail",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.vote_number: int",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific vote.\n    \"\"\"\n    \n    vote = db.query(Vote).join(Bill).filter(\n        Bill.session_id == session_id",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.detail=\"Vote not found\")\n    \n    # Get bill info\n    bill_info = {\n        \"bill_number\": vote.bill.number",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.VoteBallot",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.Member.vote == 'Nay'\n    ).count()\n    \n    # Get party votes\n    party_votes = db.query(Party).filter(\n        Party.votequestion_id == vote.id\n    ).all()\n    \n    parties_y = [pv.party.name_en for pv in party_votes if pv.vote == 'Y']\n    parties_n = [pv.party.name_en for pv in party_votes if pv.vote == 'N']\n    \n    vote_detail = VoteDetail(\n        vote_id=str(vote.id)",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.\"session\": vote.bill.session_id\n    }\n    \n    # Get vote totals\n    yea_total = db.query(Member).filter(\n        Member.votequestion_id == vote.id",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.MPVotePosition",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.Member.vote == 'Yea'\n    ).count()\n    \n    nay_total = db.query(Member).filter(\n        Member.votequestion_id == vote.id",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.result=vote.result",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Search query for bill title or description\")"
      ]
    },
    "GET:/{session_id}/{vote_number}/analysis": {
      "method": "GET",
      "path": "/{session_id}/{vote_number}/analysis",
      "file": "services/api-gateway/app/api/v1/votes.py",
      "line": 339,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.constituency_impact=\"Regional interests\" if not voted_with_party else None\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.parties_yea=parties_y",
        "import:fastapi.vote_number = vote.split('/'",
        "import:fastapi.parties_nay=parties_n\n    )\n    \n    return VoteDetailResponse(vote=vote_detail)\n\n\n@router.get(\"/ballots/\"",
        "import:fastapi.description=\"Politician filter\")",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db.func.count(Vote.id)\n    ).group_by(Vote.result).all()\n    \n    # Get votes by session\n    session_counts = db.query(\n        Bill.session_id",
        "import:fastapi.description=\"Vote filter (e.g.",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.Vote.number == vote_number\n    ).first()\n    \n    if not vote:\n        raise HTTPException(status_code=404",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.le=100",
        "import:fastapi.\"45-1/34\")\n        if '/' in vote:\n            session_id",
        "import:fastapi.# Would come from actual whip data\n            dissent_reason=\"Policy disagreement\" if not voted_with_party else None",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.voted_with_government=voted_with_government",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.# Enhanced MP position analysis\n            party_position=party_position",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get individual vote ballots (how each MP voted).\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Member).join(Vote).join(Bill)\n    \n    # Apply filters\n    if vote:\n        # Parse vote filter (e.g.",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.party_name=ballot.member.party.name_en",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.number=vote.number",
        "import:fastapi.HTTPException",
        "import:fastapi.'Y']:\n            voted_with_party = False\n        elif party_position in ['N'",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteBallotsResponse(\n        ballots=ballot_list",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{session_id}/{vote_number}\"",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.response_model=VoteDetailResponse)\nasync def get_vote_detail(\n    session_id: str",
        "import:fastapi.'N']\n        \n        ballot_list.append(VoteBallot(\n            ballot_id=str(ballot.id)",
        "import:fastapi.1)\n            query = query.filter(\n                Bill.session_id == session_id",
        "import:fastapi.\"bill_title\": vote.bill.name_en",
        "import:fastapi.Party.party_id == ballot.member.party_id\n        ).first()\n        \n        party_position = party_vote.vote if party_vote else \"Unknown\"\n        \n        # Determine if MP voted with party\n        voted_with_party = True\n        if party_position in ['Y'",
        "import:fastapi.'Y'] if government_position == 'Yea' else ballot.vote in ['Nay'",
        "import:fastapi.voted_with_party=voted_with_party",
        "import:fastapi.VoteListResponse",
        "import:fastapi.'45-1')\")",
        "import:fastapi.'N']:\n            voted_with_party = False\n        \n        # Determine government position (simplified)\n        vote_question = db.query(Vote).filter(Vote.id == ballot.votequestion_id).first()\n        government_position = 'Yea' if vote_question and vote_question.result in ['Y'",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.bill_title=vote.bill.name_en",
        "import:fastapi.count in result_counts}",
        "import:fastapi.constituency=ballot.member.riding.name_en",
        "import:fastapi.latest_vote_date=latest_vote.date if latest_vote else None\n    )",
        "import:fastapi.description=\"Vote choice filter (Yea",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.VoteDetail",
        "import:fastapi.vote_choice=ballot.vote",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.ballot: Optional[str] = Query(None",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.Vote.number == int(vote_number)\n            )\n    \n    if politician:\n        query = query.join(Member.politician).filter(\n            Member.politician.name.contains(politician)\n        )\n    \n    if ballot:\n        query = query.filter(Member.vote == ballot)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    ballots = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    ballot_list = []\n    for ballot in ballots:\n        # Get party position (simplified - in real implementation would come from PartyVote)\n        party_vote = db.query(Party).filter(\n            Party.votequestion_id == ballot.votequestion_id",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.politician: Optional[str] = Query(None",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.response_model=VoteBallotsResponse)\nasync def get_vote_ballots(\n    vote: Optional[str] = Query(None",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.whip_status=\"unknown\"",
        "import:fastapi.'Passed'] else 'Nay'\n        voted_with_government = ballot.vote in ['Yea'",
        "import:fastapi.'45-1/34')\")",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.vote_number: int",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific vote.\n    \"\"\"\n    \n    vote = db.query(Vote).join(Bill).filter(\n        Bill.session_id == session_id",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.etc.)\")",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Nay",
        "import:fastapi.government_position=government_position",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.'Nay'] and ballot.vote not in ['Nay'",
        "import:fastapi.count in session_counts}",
        "import:fastapi.detail=\"Vote not found\")\n    \n    # Get bill info\n    bill_info = {\n        \"bill_number\": vote.bill.number",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.result_breakdown={result: count for result",
        "import:fastapi.VoteBallot",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.Member.vote == 'Nay'\n    ).count()\n    \n    # Get party votes\n    party_votes = db.query(Party).filter(\n        Party.votequestion_id == vote.id\n    ).all()\n    \n    parties_y = [pv.party.name_en for pv in party_votes if pv.vote == 'Y']\n    parties_n = [pv.party.name_en for pv in party_votes if pv.vote == 'N']\n    \n    vote_detail = VoteDetail(\n        vote_id=str(vote.id)",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.session_breakdown={session: count for session",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.\"session\": vote.bill.session_id\n    }\n    \n    # Get vote totals\n    yea_total = db.query(Member).filter(\n        Member.votequestion_id == vote.id",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.'Yea'] and ballot.vote not in ['Yea'",
        "import:fastapi.MPVotePosition",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.vote_id=str(ballot.votequestion_id)",
        "import:fastapi.Member.vote == 'Yea'\n    ).count()\n    \n    nay_total = db.query(Member).filter(\n        Member.votequestion_id == vote.id",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.result=vote.result",
        "import:fastapi.member_name=f\"{ballot.member.politician.name_given} {ballot.member.politician.name_family}\"",
        "import:fastapi.response_model=VoteSummaryResponse)\nasync def get_vote_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about votes.\n    \"\"\"\n    \n    # Get total votes count\n    total_votes = db.query(Vote).count()\n    \n    # Get votes by result\n    result_counts = db.query(\n        Vote.result",
        "function:get_vote_summary_stats",
        "import:fastapi.APIRouter",
        "import:fastapi.db.func.count(Vote.id)\n    ).join(Vote).group_by(Bill.session_id).all()\n    \n    # Get most recent vote\n    latest_vote = db.query(Vote).order_by(Vote.date.desc()).first()\n    \n    return VoteSummaryResponse(\n        total_votes=total_votes",
        "import:fastapi.description=\"Search query for bill title or description\")"
      ]
    },
    "POST:/metrics": {
      "method": "POST",
      "path": "/metrics",
      "file": "services/api-gateway/app/api/v1/performance_optimization.py",
      "line": 41,
      "dependencies": [
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.performance_optimization import (\n    PerformanceMetric",
        "import:fastapi.PerformanceMetricCreateRequest",
        "import:fastapi.PerformanceAlertResponse",
        "import:fastapi.MetricTypeEnum",
        "import:fastapi.List\nfrom datetime import datetime",
        "import:fastapi.SystemHealth\n)\nfrom app.models.users import User\nfrom app.schemas.performance_optimization import (\n    PerformanceMetricResponse",
        "import:fastapi.HealthStatusEnum",
        "import:fastapi.AlertSeverityEnum",
        "import:fastapi.HealthCheckRequest",
        "import:fastapi.MetricCategoryEnum",
        "import:fastapi.PerformanceAlertCreateRequest",
        "import:fastapi.AlertTypeEnum",
        "import:fastapi.PerformanceMetricListResponse",
        "import:fastapi.PerformanceAlertListResponse",
        "import:fastapi.PerformanceAnalysisRequest",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.EffortLevelEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PERFORMANCE METRICS MANAGEMENT\n# ============================================================================",
        "import:fastapi.Path",
        "import:fastapi.PerformanceTrend",
        "import:fastapi.PerformanceAlert",
        "import:fastapi.SystemOverview",
        "import:fastapi.ImpactLevelEnum",
        "import:fastapi.StrategyCategoryEnum",
        "import:fastapi.PriorityEnum",
        "import:fastapi.OptimizationRecommendation",
        "import:fastapi.APIRouter",
        "import:fastapi.HealthCheckTypeEnum",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional"
      ]
    },
    "GET:/metrics/{metric_id}": {
      "method": "GET",
      "path": "/metrics/{metric_id}",
      "file": "services/api-gateway/app/api/v1/performance_optimization.py",
      "line": 159,
      "dependencies": [
        "import:fastapi.description=\"Search in metric names\")",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.performance_optimization import (\n    PerformanceMetric",
        "import:fastapi.response_model=PerformanceMetricListResponse)\nasync def list_performance_metrics(\n    page: int = Query(1",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.description=\"Filter by metric category\")",
        "import:fastapi.description=\"Filter by end date\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.EffortLevelEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PERFORMANCE METRICS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/metrics\"",
        "import:fastapi.metric_category=metric.metric_category",
        "import:fastapi.PerformanceMetricCreateRequest",
        "function:list_performance_metrics",
        "import:fastapi.PerformanceAlertResponse",
        "import:fastapi.MetricTypeEnum",
        "import:fastapi.List\nfrom datetime import datetime",
        "import:fastapi.SystemHealth\n)\nfrom app.models.users import User\nfrom app.schemas.performance_optimization import (\n    PerformanceMetricResponse",
        "import:fastapi.source_endpoint=metric.source_endpoint",
        "import:fastapi.HealthStatusEnum",
        "import:fastapi.description=\"Filter by start date\")",
        "import:fastapi.threshold_critical=metric.threshold_critical",
        "import:fastapi.AlertSeverityEnum",
        "import:fastapi.HealthCheckRequest",
        "import:fastapi.response_model=PerformanceMetricResponse)\nasync def create_performance_metric(\n    metric_data: PerformanceMetricCreateRequest = Body(...)",
        "import:fastapi.ip_address=metric.ip_address",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.metric_value=metric.metric_value",
        "import:fastapi.metric_category: Optional[MetricCategoryEnum] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.threshold_warning=metric.threshold_warning",
        "import:fastapi.metric_type: Optional[MetricTypeEnum] = Query(None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.MetricCategoryEnum",
        "import:fastapi.PerformanceAlertCreateRequest",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Filter by metric type\")",
        "import:fastapi.AlertTypeEnum",
        "import:fastapi.PerformanceMetricListResponse",
        "import:fastapi.PerformanceAlertListResponse",
        "import:fastapi.metric_unit=metric.metric_unit",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.created_at=metric.created_at\n        ))\n    \n    return PerformanceMetricListResponse(\n        metrics=metric_responses",
        "import:fastapi.metric)\n    \n    logger.info(f\"Performance metric created: {current_user.username} - {metric_data.metric_name}\")\n    \n    return PerformanceMetricResponse(\n        id=str(metric.id)",
        "import:fastapi.metric_type=metric.metric_type",
        "import:fastapi.PerformanceAnalysisRequest",
        "import:fastapi.start_date: Optional[datetime] = Query(None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new performance metric.\n    \n    This creates a new performance metric for monitoring system performance.\n    \"\"\"\n    # Create new metric\n    metric = PerformanceMetric(**metric_data.dict())\n    db.add(metric)\n    db.commit()\n    db.refresh(metric)\n    \n    # Check if alert should be triggered\n    if metric.is_alert_enabled:\n        await _check_and_create_alerts(db",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.Path",
        "import:fastapi.PerformanceTrend",
        "import:fastapi.metric_name=metric.metric_name",
        "import:fastapi.total=total",
        "import:fastapi.PerformanceAlert",
        "import:fastapi.page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.session_id=metric.session_id",
        "import:fastapi.SystemOverview",
        "import:fastapi.ImpactLevelEnum",
        "import:fastapi.StrategyCategoryEnum",
        "import:fastapi.is_alert_enabled=metric.is_alert_enabled",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List performance metrics with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PerformanceMetric)\n    \n    # Apply filters\n    if metric_type:\n        query = query.filter(PerformanceMetric.metric_type == metric_type)\n    \n    if metric_category:\n        query = query.filter(PerformanceMetric.metric_category == metric_category)\n    \n    if start_date:\n        query = query.filter(PerformanceMetric.collection_timestamp >= start_date)\n    \n    if end_date:\n        query = query.filter(PerformanceMetric.collection_timestamp <= end_date)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(PerformanceMetric.metric_name.ilike(search_term))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get metrics\n    metrics = query.order_by(PerformanceMetric.collection_timestamp.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    metric_responses = []\n    for metric in metrics:\n        metric_responses.append(PerformanceMetricResponse(\n            id=str(metric.id)",
        "import:fastapi.collection_timestamp=metric.collection_timestamp",
        "import:fastapi.PriorityEnum",
        "import:fastapi.user_agent=metric.user_agent",
        "import:fastapi.OptimizationRecommendation",
        "import:fastapi.APIRouter",
        "import:fastapi.created_at=metric.created_at\n    )\n\n\n@router.get(\"/metrics\"",
        "import:fastapi.HealthCheckTypeEnum",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional",
        "import:fastapi.end_date: Optional[datetime] = Query(None"
      ]
    },
    "POST:/alerts": {
      "method": "POST",
      "path": "/alerts",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 38,
      "dependencies": [
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailCampaign",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.EmailCampaignListResponse",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/alerts": {
      "method": "GET",
      "path": "/alerts",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 97,
      "dependencies": [
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.last_sent=alert.last_sent\n    )",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailCampaign",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "function:create_email_alert",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.EmailCampaignListResponse",
        "import:fastapi.HTTPException"
      ]
    },
    "POST:/health/check": {
      "method": "POST",
      "path": "/health/check",
      "file": "services/api-gateway/app/api/v1/performance_optimization.py",
      "line": 313,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.metric_category=metric.metric_category",
        "import:fastapi.description=\"Performance metric ID\")",
        "import:fastapi.PerformanceAlertResponse",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.metric_id=str(alert.metric_id)",
        "import:fastapi.source_endpoint=metric.source_endpoint",
        "import:fastapi.alert_severity: Optional[AlertSeverityEnum] = Query(None",
        "import:fastapi.description=\"Filter by start date\")",
        "import:fastapi.threshold_critical=metric.threshold_critical",
        "import:fastapi.AlertSeverityEnum",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ip_address=metric.ip_address",
        "import:fastapi.metric_category: Optional[MetricCategoryEnum] = Query(None",
        "import:fastapi.threshold_warning=metric.threshold_warning",
        "import:fastapi.metric_type: Optional[MetricTypeEnum] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.PerformanceMetricListResponse",
        "import:fastapi.created_at=metric.created_at\n        ))\n    \n    return PerformanceMetricListResponse(\n        metrics=metric_responses",
        "import:fastapi.le=100",
        "import:fastapi.updated_at=alert.updated_at\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.session_id=metric.session_id",
        "import:fastapi.response_model=PerformanceAlertListResponse)\nasync def list_performance_alerts(\n    page: int = Query(1",
        "import:fastapi.resolved_at=alert.resolved_at",
        "import:fastapi.SystemOverview",
        "import:fastapi.is_alert_enabled=metric.is_alert_enabled",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List performance metrics with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PerformanceMetric)\n    \n    # Apply filters\n    if metric_type:\n        query = query.filter(PerformanceMetric.metric_type == metric_type)\n    \n    if metric_category:\n        query = query.filter(PerformanceMetric.metric_category == metric_category)\n    \n    if start_date:\n        query = query.filter(PerformanceMetric.collection_timestamp >= start_date)\n    \n    if end_date:\n        query = query.filter(PerformanceMetric.collection_timestamp <= end_date)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(PerformanceMetric.metric_name.ilike(search_term))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get metrics\n    metrics = query.order_by(PerformanceMetric.collection_timestamp.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    metric_responses = []\n    for metric in metrics:\n        metric_responses.append(PerformanceMetricResponse(\n            id=str(metric.id)",
        "import:fastapi.resolution_notes=alert.resolution_notes",
        "import:fastapi.detail=\"Performance metric not found\")\n    \n    return PerformanceMetricResponse(\n        id=str(metric.id)",
        "import:fastapi.description=\"Filter by metric type\")",
        "import:fastapi.HealthCheckTypeEnum",
        "import:fastapi.HTTPException",
        "import:fastapi.MetricCategoryEnum",
        "import:fastapi.notification_sent=alert.notification_sent",
        "import:fastapi.description=\"Filter by metric category\")",
        "import:fastapi.MetricTypeEnum",
        "import:fastapi.notification_channels=alert.notification_channels",
        "import:fastapi.updated_at=alert.updated_at\n        ))\n    \n    return PerformanceAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.List\nfrom datetime import datetime",
        "import:fastapi.SystemHealth\n)\nfrom app.models.users import User\nfrom app.schemas.performance_optimization import (\n    PerformanceMetricResponse",
        "import:fastapi.HealthStatusEnum",
        "import:fastapi.response_model=PerformanceMetricResponse)\nasync def create_performance_metric(\n    metric_data: PerformanceMetricCreateRequest = Body(...)",
        "import:fastapi.HealthCheckRequest",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# SYSTEM HEALTH MONITORING\n# ============================================================================",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.resolved_by=alert.resolved_by",
        "import:fastapi.response_model=PerformanceAlertResponse)\nasync def create_performance_alert(\n    alert_data: PerformanceAlertCreateRequest = Body(...)",
        "import:fastapi.alert_severity=alert.alert_severity",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.AlertTypeEnum",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "import:fastapi.is_resolved: Optional[bool] = Query(None",
        "import:fastapi.PriorityEnum",
        "import:fastapi.OptimizationRecommendation",
        "import:fastapi.description=\"Search in metric names\")",
        "import:fastapi.response_model=PerformanceMetricListResponse)\nasync def list_performance_metrics(\n    page: int = Query(1",
        "function:list_performance_alerts",
        "import:fastapi.EffortLevelEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PERFORMANCE METRICS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/metrics\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific performance metric by ID.\n    \"\"\"\n    metric = db.query(PerformanceMetric).filter(PerformanceMetric.id == metric_id).first()\n    \n    if not metric:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by resolution status\")",
        "import:fastapi.alert_type: Optional[AlertTypeEnum] = Query(None",
        "import:fastapi.metric_value=metric.metric_value",
        "import:fastapi.PerformanceAlertCreateRequest",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.alert_message=alert.alert_message",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new performance metric.\n    \n    This creates a new performance metric for monitoring system performance.\n    \"\"\"\n    # Create new metric\n    metric = PerformanceMetric(**metric_data.dict())\n    db.add(metric)\n    db.commit()\n    db.refresh(metric)\n    \n    # Check if alert should be triggered\n    if metric.is_alert_enabled:\n        await _check_and_create_alerts(db",
        "import:fastapi.Query",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new performance alert.\n    \n    This creates a new performance alert for critical performance issues.\n    \"\"\"\n    # Verify metric exists\n    metric = db.query(PerformanceMetric).filter(PerformanceMetric.id == alert_data.metric_id).first()\n    if not metric:\n        raise HTTPException(status_code=404",
        "import:fastapi.PerformanceTrend",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.PerformanceAlert",
        "import:fastapi.created_at=metric.created_at\n    )\n\n\n@router.get(\"/metrics\"",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/metrics/{metric_id}\"",
        "import:fastapi.end_date: Optional[datetime] = Query(None",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.performance_optimization import (\n    PerformanceMetric",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.description=\"Filter by alert severity\")",
        "import:fastapi.description=\"Filter by end date\")",
        "import:fastapi.PerformanceMetricCreateRequest",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.created_at=metric.created_at\n    )\n\n\n# ============================================================================\n# PERFORMANCE ALERTS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.detail=\"Performance metric not found\")\n    \n    # Create new alert\n    alert = PerformanceAlert(**alert_data.dict())\n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Performance alert created: {current_user.username} - {alert_data.alert_message}\")\n    \n    return PerformanceAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.PerformanceAlertListResponse",
        "import:fastapi.metric_unit=metric.metric_unit",
        "import:fastapi.metric)\n    \n    logger.info(f\"Performance metric created: {current_user.username} - {metric_data.metric_name}\")\n    \n    return PerformanceMetricResponse(\n        id=str(metric.id)",
        "import:fastapi.metric_type=metric.metric_type",
        "import:fastapi.PerformanceAnalysisRequest",
        "import:fastapi.start_date: Optional[datetime] = Query(None",
        "import:fastapi.metric_name=metric.metric_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List performance alerts with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PerformanceAlert)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(PerformanceAlert.alert_type == alert_type)\n    \n    if alert_severity:\n        query = query.filter(PerformanceAlert.alert_severity == alert_severity)\n    \n    if is_resolved is not None:\n        query = query.filter(PerformanceAlert.is_resolved == is_resolved)\n    \n    if start_date:\n        query = query.filter(PerformanceAlert.created_at >= start_date)\n    \n    if end_date:\n        query = query.filter(PerformanceAlert.created_at <= end_date)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(PerformanceAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(PerformanceAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.is_resolved=alert.is_resolved",
        "import:fastapi.ImpactLevelEnum",
        "import:fastapi.StrategyCategoryEnum",
        "import:fastapi.collection_timestamp=metric.collection_timestamp",
        "import:fastapi.response_model=PerformanceMetricResponse)\nasync def get_performance_metric(\n    metric_id: str = Path(...",
        "import:fastapi.user_agent=metric.user_agent",
        "import:fastapi.APIRouter",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional"
      ]
    },
    "GET:/health/overview": {
      "method": "GET",
      "path": "/health/overview",
      "file": "services/api-gateway/app/api/v1/performance_optimization.py",
      "line": 372,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.metric_category=metric.metric_category",
        "import:fastapi.description=\"Performance metric ID\")",
        "import:fastapi.PerformanceAlertResponse",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.metric_id=str(alert.metric_id)",
        "import:fastapi.source_endpoint=metric.source_endpoint",
        "import:fastapi.alert_severity: Optional[AlertSeverityEnum] = Query(None",
        "import:fastapi.description=\"Filter by start date\")",
        "import:fastapi.threshold_critical=metric.threshold_critical",
        "import:fastapi.AlertSeverityEnum",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ip_address=metric.ip_address",
        "import:fastapi.metric_category: Optional[MetricCategoryEnum] = Query(None",
        "import:fastapi.threshold_warning=metric.threshold_warning",
        "import:fastapi.metric_type: Optional[MetricTypeEnum] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.PerformanceMetricListResponse",
        "import:fastapi.created_at=metric.created_at\n        ))\n    \n    return PerformanceMetricListResponse(\n        metrics=metric_responses",
        "import:fastapi.health_check_type=health_data.health_check_type",
        "import:fastapi.le=100",
        "function:perform_health_check",
        "import:fastapi.updated_at=alert.updated_at\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.session_id=metric.session_id",
        "import:fastapi.response_model=PerformanceAlertListResponse)\nasync def list_performance_alerts(\n    page: int = Query(1",
        "import:fastapi.resolved_at=alert.resolved_at",
        "import:fastapi.alert_threshold=3",
        "import:fastapi.SystemOverview",
        "import:fastapi.is_alert_enabled=metric.is_alert_enabled",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List performance metrics with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PerformanceMetric)\n    \n    # Apply filters\n    if metric_type:\n        query = query.filter(PerformanceMetric.metric_type == metric_type)\n    \n    if metric_category:\n        query = query.filter(PerformanceMetric.metric_category == metric_category)\n    \n    if start_date:\n        query = query.filter(PerformanceMetric.collection_timestamp >= start_date)\n    \n    if end_date:\n        query = query.filter(PerformanceMetric.collection_timestamp <= end_date)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(PerformanceMetric.metric_name.ilike(search_term))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get metrics\n    metrics = query.order_by(PerformanceMetric.collection_timestamp.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    metric_responses = []\n    for metric in metrics:\n        metric_responses.append(PerformanceMetricResponse(\n            id=str(metric.id)",
        "import:fastapi.resolution_notes=alert.resolution_notes",
        "import:fastapi.detail=\"Performance metric not found\")\n    \n    return PerformanceMetricResponse(\n        id=str(metric.id)",
        "import:fastapi.description=\"Filter by metric type\")",
        "import:fastapi.HealthCheckTypeEnum",
        "import:fastapi.HTTPException",
        "import:fastapi.MetricCategoryEnum",
        "import:fastapi.notification_sent=alert.notification_sent",
        "import:fastapi.description=\"Filter by metric category\")",
        "import:fastapi.MetricTypeEnum",
        "import:fastapi.notification_channels=alert.notification_channels",
        "import:fastapi.updated_at=alert.updated_at\n        ))\n    \n    return PerformanceAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.List\nfrom datetime import datetime",
        "import:fastapi.SystemHealth\n)\nfrom app.models.users import User\nfrom app.schemas.performance_optimization import (\n    PerformanceMetricResponse",
        "import:fastapi.HealthStatusEnum",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Perform a system health check.\n    \n    This endpoint allows external systems to report health check results.\n    \"\"\"\n    # Get or create health check record\n    health_check = db.query(SystemHealth).filter(\n        SystemHealth.health_check_name == health_data.health_check_name\n    ).first()\n    \n    if not health_check:\n        # Create new health check\n        health_check = SystemHealth(\n            health_check_name=health_data.health_check_name",
        "import:fastapi.response_model=PerformanceMetricResponse)\nasync def create_performance_metric(\n    metric_data: PerformanceMetricCreateRequest = Body(...)",
        "import:fastapi.HealthCheckRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.resolved_by=alert.resolved_by",
        "import:fastapi.response_model=PerformanceAlertResponse)\nasync def create_performance_alert(\n    alert_data: PerformanceAlertCreateRequest = Body(...)",
        "import:fastapi.alert_severity=alert.alert_severity",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.AlertTypeEnum",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# SYSTEM HEALTH MONITORING\n# ============================================================================\n\n@router.post(\"/health/check\")\nasync def perform_health_check(\n    health_data: HealthCheckRequest = Body(...)",
        "import:fastapi.Depends",
        "import:fastapi.\"performed_at\": datetime.utcnow()\n    }",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "import:fastapi.is_resolved: Optional[bool] = Query(None",
        "import:fastapi.last_check=datetime.utcnow()",
        "import:fastapi.PriorityEnum",
        "import:fastapi.OptimizationRecommendation",
        "import:fastapi.description=\"Search in metric names\")",
        "import:fastapi.response_model=PerformanceMetricListResponse)\nasync def list_performance_metrics(\n    page: int = Query(1",
        "import:fastapi.\"health_check_name\": health_data.health_check_name",
        "import:fastapi.EffortLevelEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PERFORMANCE METRICS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/metrics\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific performance metric by ID.\n    \"\"\"\n    metric = db.query(PerformanceMetric).filter(PerformanceMetric.id == metric_id).first()\n    \n    if not metric:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by resolution status\")",
        "import:fastapi.alert_type: Optional[AlertTypeEnum] = Query(None",
        "import:fastapi.consecutive_failures=0\n        )\n        db.add(health_check)\n    else:\n        # Update existing health check\n        health_check.last_check = datetime.utcnow()\n        health_check.next_check = datetime.utcnow() + timedelta(minutes=5)\n        \n        if health_data.error_message:\n            health_check.health_status = HealthStatusEnum.UNHEALTHY\n            health_check.error_count += 1\n            health_check.last_error = health_data.error_message\n            health_check.consecutive_failures += 1\n        else:\n            health_check.health_status = HealthStatusEnum.HEALTHY\n            health_check.consecutive_failures = 0\n        \n        if health_data.response_time:\n            health_check.response_time = health_data.response_time\n    \n    db.commit()\n    \n    logger.info(f\"Health check performed: {health_data.health_check_name} - {health_check.health_status}\")\n    \n    return {\n        \"message\": \"Health check performed successfully\"",
        "import:fastapi.metric_value=metric.metric_value",
        "import:fastapi.\"next_check\": health_check.next_check",
        "import:fastapi.check_interval=300",
        "import:fastapi.PerformanceAlertCreateRequest",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.alert_message=alert.alert_message",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new performance metric.\n    \n    This creates a new performance metric for monitoring system performance.\n    \"\"\"\n    # Create new metric\n    metric = PerformanceMetric(**metric_data.dict())\n    db.add(metric)\n    db.commit()\n    db.refresh(metric)\n    \n    # Check if alert should be triggered\n    if metric.is_alert_enabled:\n        await _check_and_create_alerts(db",
        "import:fastapi.Query",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new performance alert.\n    \n    This creates a new performance alert for critical performance issues.\n    \"\"\"\n    # Verify metric exists\n    metric = db.query(PerformanceMetric).filter(PerformanceMetric.id == alert_data.metric_id).first()\n    if not metric:\n        raise HTTPException(status_code=404",
        "import:fastapi.PerformanceTrend",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.PerformanceAlert",
        "import:fastapi.\"health_status\": health_check.health_status",
        "import:fastapi.created_at=metric.created_at\n    )\n\n\n@router.get(\"/metrics\"",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/metrics/{metric_id}\"",
        "import:fastapi.end_date: Optional[datetime] = Query(None",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.performance_optimization import (\n    PerformanceMetric",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.description=\"Filter by alert severity\")",
        "import:fastapi.description=\"Filter by end date\")",
        "import:fastapi.is_critical=False",
        "import:fastapi.PerformanceMetricCreateRequest",
        "import:fastapi.next_check=datetime.utcnow() + timedelta(minutes=5)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.created_at=metric.created_at\n    )\n\n\n# ============================================================================\n# PERFORMANCE ALERTS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.health_status=HealthStatusEnum.HEALTHY",
        "import:fastapi.detail=\"Performance metric not found\")\n    \n    # Create new alert\n    alert = PerformanceAlert(**alert_data.dict())\n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Performance alert created: {current_user.username} - {alert_data.alert_message}\")\n    \n    return PerformanceAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.PerformanceAlertListResponse",
        "import:fastapi.metric_unit=metric.metric_unit",
        "import:fastapi.metric)\n    \n    logger.info(f\"Performance metric created: {current_user.username} - {metric_data.metric_name}\")\n    \n    return PerformanceMetricResponse(\n        id=str(metric.id)",
        "import:fastapi.metric_type=metric.metric_type",
        "import:fastapi.PerformanceAnalysisRequest",
        "import:fastapi.start_date: Optional[datetime] = Query(None",
        "import:fastapi.metric_name=metric.metric_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List performance alerts with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PerformanceAlert)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(PerformanceAlert.alert_type == alert_type)\n    \n    if alert_severity:\n        query = query.filter(PerformanceAlert.alert_severity == alert_severity)\n    \n    if is_resolved is not None:\n        query = query.filter(PerformanceAlert.is_resolved == is_resolved)\n    \n    if start_date:\n        query = query.filter(PerformanceAlert.created_at >= start_date)\n    \n    if end_date:\n        query = query.filter(PerformanceAlert.created_at <= end_date)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(PerformanceAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(PerformanceAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.is_resolved=alert.is_resolved",
        "import:fastapi.ImpactLevelEnum",
        "import:fastapi.StrategyCategoryEnum",
        "import:fastapi.collection_timestamp=metric.collection_timestamp",
        "import:fastapi.response_model=PerformanceMetricResponse)\nasync def get_performance_metric(\n    metric_id: str = Path(...",
        "import:fastapi.user_agent=metric.user_agent",
        "import:fastapi.APIRouter",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional"
      ]
    },
    "POST:/analysis": {
      "method": "POST",
      "path": "/analysis",
      "file": "services/api-gateway/app/api/v1/performance_optimization.py",
      "line": 446,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.PerformanceAlert.alert_severity == AlertSeverityEnum.CRITICAL\n        )\n    ).count()\n    \n    overview = SystemOverview(\n        total_metrics=len(recent_metrics)",
        "import:fastapi.active_alerts=active_alerts",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.metric_category=metric.metric_category",
        "import:fastapi.avg_response_time=round(avg_response_time",
        "import:fastapi.description=\"Performance metric ID\")",
        "import:fastapi.PerformanceAlertResponse",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.metric_id=str(alert.metric_id)",
        "import:fastapi.source_endpoint=metric.source_endpoint",
        "import:fastapi.alert_severity: Optional[AlertSeverityEnum] = Query(None",
        "import:fastapi.description=\"Filter by start date\")",
        "import:fastapi.threshold_critical=metric.threshold_critical",
        "import:fastapi.AlertSeverityEnum",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ip_address=metric.ip_address",
        "import:fastapi.metric_category: Optional[MetricCategoryEnum] = Query(None",
        "import:fastapi.threshold_warning=metric.threshold_warning",
        "import:fastapi.metric_type: Optional[MetricTypeEnum] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.PerformanceMetricListResponse",
        "import:fastapi.created_at=metric.created_at\n        ))\n    \n    return PerformanceMetricListResponse(\n        metrics=metric_responses",
        "import:fastapi.health_check_type=health_data.health_check_type",
        "import:fastapi.le=100",
        "import:fastapi.updated_at=alert.updated_at\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.database_performance_score=round(health_score",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.session_id=metric.session_id",
        "import:fastapi.response_model=PerformanceAlertListResponse)\nasync def list_performance_alerts(\n    page: int = Query(1",
        "import:fastapi.resolved_at=alert.resolved_at",
        "import:fastapi.alert_threshold=3",
        "import:fastapi.SystemOverview",
        "import:fastapi.is_alert_enabled=metric.is_alert_enabled",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List performance metrics with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PerformanceMetric)\n    \n    # Apply filters\n    if metric_type:\n        query = query.filter(PerformanceMetric.metric_type == metric_type)\n    \n    if metric_category:\n        query = query.filter(PerformanceMetric.metric_category == metric_category)\n    \n    if start_date:\n        query = query.filter(PerformanceMetric.collection_timestamp >= start_date)\n    \n    if end_date:\n        query = query.filter(PerformanceMetric.collection_timestamp <= end_date)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(PerformanceMetric.metric_name.ilike(search_term))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get metrics\n    metrics = query.order_by(PerformanceMetric.collection_timestamp.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    metric_responses = []\n    for metric in metrics:\n        metric_responses.append(PerformanceMetricResponse(\n            id=str(metric.id)",
        "import:fastapi.resolution_notes=alert.resolution_notes",
        "import:fastapi.detail=\"Performance metric not found\")\n    \n    return PerformanceMetricResponse(\n        id=str(metric.id)",
        "import:fastapi.description=\"Filter by metric type\")",
        "import:fastapi.HealthCheckTypeEnum",
        "import:fastapi.HTTPException",
        "import:fastapi.MetricCategoryEnum",
        "import:fastapi.notification_sent=alert.notification_sent",
        "import:fastapi.description=\"Filter by metric category\")",
        "import:fastapi.MetricTypeEnum",
        "import:fastapi.notification_channels=alert.notification_channels",
        "import:fastapi.updated_at=alert.updated_at\n        ))\n    \n    return PerformanceAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.List\nfrom datetime import datetime",
        "import:fastapi.SystemHealth\n)\nfrom app.models.users import User\nfrom app.schemas.performance_optimization import (\n    PerformanceMetricResponse",
        "import:fastapi.HealthStatusEnum",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Perform a system health check.\n    \n    This endpoint allows external systems to report health check results.\n    \"\"\"\n    # Get or create health check record\n    health_check = db.query(SystemHealth).filter(\n        SystemHealth.health_check_name == health_data.health_check_name\n    ).first()\n    \n    if not health_check:\n        # Create new health check\n        health_check = SystemHealth(\n            health_check_name=health_data.health_check_name",
        "import:fastapi.response_model=PerformanceMetricResponse)\nasync def create_performance_metric(\n    metric_data: PerformanceMetricCreateRequest = Body(...)",
        "import:fastapi.HealthCheckRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.resolved_by=alert.resolved_by",
        "import:fastapi.response_model=PerformanceAlertResponse)\nasync def create_performance_alert(\n    alert_data: PerformanceAlertCreateRequest = Body(...)",
        "import:fastapi.alert_severity=alert.alert_severity",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.AlertTypeEnum",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# SYSTEM HEALTH MONITORING\n# ============================================================================\n\n@router.post(\"/health/check\")\nasync def perform_health_check(\n    health_data: HealthCheckRequest = Body(...)",
        "import:fastapi.critical_alerts=critical_alerts",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.page=page",
        "function:get_system_health_overview",
        "import:fastapi.is_resolved: Optional[bool] = Query(None",
        "import:fastapi.last_check=datetime.utcnow()",
        "import:fastapi.error_rate=round(error_rate",
        "import:fastapi.PriorityEnum",
        "import:fastapi.OptimizationRecommendation",
        "import:fastapi.description=\"Search in metric names\")",
        "import:fastapi.response_model=PerformanceMetricListResponse)\nasync def list_performance_metrics(\n    page: int = Query(1",
        "import:fastapi.\"health_check_name\": health_data.health_check_name",
        "import:fastapi.EffortLevelEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PERFORMANCE METRICS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/metrics\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific performance metric by ID.\n    \"\"\"\n    metric = db.query(PerformanceMetric).filter(PerformanceMetric.id == metric_id).first()\n    \n    if not metric:\n        raise HTTPException(status_code=404",
        "import:fastapi.system_health_score=round(health_score",
        "import:fastapi.description=\"Filter by resolution status\")",
        "import:fastapi.alert_type: Optional[AlertTypeEnum] = Query(None",
        "import:fastapi.consecutive_failures=0\n        )\n        db.add(health_check)\n    else:\n        # Update existing health check\n        health_check.last_check = datetime.utcnow()\n        health_check.next_check = datetime.utcnow() + timedelta(minutes=5)\n        \n        if health_data.error_message:\n            health_check.health_status = HealthStatusEnum.UNHEALTHY\n            health_check.error_count += 1\n            health_check.last_error = health_data.error_message\n            health_check.consecutive_failures += 1\n        else:\n            health_check.health_status = HealthStatusEnum.HEALTHY\n            health_check.consecutive_failures = 0\n        \n        if health_data.response_time:\n            health_check.response_time = health_data.response_time\n    \n    db.commit()\n    \n    logger.info(f\"Health check performed: {health_data.health_check_name} - {health_check.health_status}\")\n    \n    return {\n        \"message\": \"Health check performed successfully\"",
        "import:fastapi.metric_value=metric.metric_value",
        "import:fastapi.\"next_check\": health_check.next_check",
        "import:fastapi.check_interval=300",
        "import:fastapi.PerformanceAlertCreateRequest",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.alert_message=alert.alert_message",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new performance metric.\n    \n    This creates a new performance metric for monitoring system performance.\n    \"\"\"\n    # Create new metric\n    metric = PerformanceMetric(**metric_data.dict())\n    db.add(metric)\n    db.commit()\n    db.refresh(metric)\n    \n    # Check if alert should be triggered\n    if metric.is_alert_enabled:\n        await _check_and_create_alerts(db",
        "import:fastapi.Query",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new performance alert.\n    \n    This creates a new performance alert for critical performance issues.\n    \"\"\"\n    # Verify metric exists\n    metric = db.query(PerformanceMetric).filter(PerformanceMetric.id == alert_data.metric_id).first()\n    if not metric:\n        raise HTTPException(status_code=404",
        "import:fastapi.PerformanceTrend",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.# Simplified for now\n        last_updated=datetime.utcnow()\n    )\n    \n    return overview\n\n\n# ============================================================================\n# PERFORMANCE ANALYSIS\n# ============================================================================",
        "import:fastapi.PerformanceAlert",
        "import:fastapi.\"health_status\": health_check.health_status",
        "import:fastapi.created_at=metric.created_at\n    )\n\n\n@router.get(\"/metrics\"",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/metrics/{metric_id}\"",
        "import:fastapi.2)",
        "import:fastapi.end_date: Optional[datetime] = Query(None",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.performance_optimization import (\n    PerformanceMetric",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.description=\"Filter by alert severity\")",
        "import:fastapi.description=\"Filter by end date\")",
        "import:fastapi.is_critical=False",
        "import:fastapi.\"performed_at\": datetime.utcnow()\n    }\n\n\n@router.get(\"/health/overview\")\nasync def get_system_health_overview(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get system health overview.\n    \n    This provides a comprehensive overview of system health status.\n    \"\"\"\n    # Get health checks\n    health_checks = db.query(SystemHealth).all()\n    \n    # Calculate overall health score\n    total_checks = len(health_checks)\n    healthy_checks = len([h for h in health_checks if h.health_status == HealthStatusEnum.HEALTHY])\n    degraded_checks = len([h for h in health_checks if h.health_status == HealthStatusEnum.DEGRADED])\n    unhealthy_checks = len([h for h in health_checks if h.health_status == HealthStatusEnum.UNHEALTHY])\n    \n    if total_checks > 0:\n        health_score = (healthy_checks / total_checks) * 100\n    else:\n        health_score = 100.0\n    \n    # Get performance metrics summary\n    recent_metrics = db.query(PerformanceMetric).filter(\n        PerformanceMetric.collection_timestamp >= datetime.utcnow() - timedelta(hours=1)\n    ).all()\n    \n    avg_response_time = 0\n    error_rate = 0\n    cache_hit_rate = 0\n    \n    if recent_metrics:\n        response_times = [m.metric_value for m in recent_metrics if m.metric_type == MetricTypeEnum.RESPONSE_TIME]\n        if response_times:\n            avg_response_time = sum(response_times) / len(response_times)\n        \n        total_requests = len([m for m in recent_metrics if m.metric_type == MetricTypeEnum.THROUGHPUT])\n        error_requests = len([m for m in recent_metrics if m.metric_type == MetricTypeEnum.ERROR_RATE])\n        if total_requests > 0:\n            error_rate = (error_requests / total_requests) * 100\n        \n        cache_metrics = [m for m in recent_metrics if m.metric_type == MetricTypeEnum.CACHE_HIT_RATE]\n        if cache_metrics:\n            cache_hit_rate = sum([m.metric_value for m in cache_metrics]) / len(cache_metrics)\n    \n    # Get active alerts\n    active_alerts = db.query(PerformanceAlert).filter(PerformanceAlert.is_resolved == False).count()\n    critical_alerts = db.query(PerformanceAlert).filter(\n        and_(\n            PerformanceAlert.is_resolved == False",
        "import:fastapi.PerformanceMetricCreateRequest",
        "import:fastapi.next_check=datetime.utcnow() + timedelta(minutes=5)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.created_at=metric.created_at\n    )\n\n\n# ============================================================================\n# PERFORMANCE ALERTS MANAGEMENT\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.health_status=HealthStatusEnum.HEALTHY",
        "import:fastapi.detail=\"Performance metric not found\")\n    \n    # Create new alert\n    alert = PerformanceAlert(**alert_data.dict())\n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Performance alert created: {current_user.username} - {alert_data.alert_message}\")\n    \n    return PerformanceAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.PerformanceAlertListResponse",
        "import:fastapi.metric_unit=metric.metric_unit",
        "import:fastapi.metric)\n    \n    logger.info(f\"Performance metric created: {current_user.username} - {metric_data.metric_name}\")\n    \n    return PerformanceMetricResponse(\n        id=str(metric.id)",
        "import:fastapi.metric_type=metric.metric_type",
        "import:fastapi.PerformanceAnalysisRequest",
        "import:fastapi.start_date: Optional[datetime] = Query(None",
        "import:fastapi.metric_name=metric.metric_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List performance alerts with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PerformanceAlert)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(PerformanceAlert.alert_type == alert_type)\n    \n    if alert_severity:\n        query = query.filter(PerformanceAlert.alert_severity == alert_severity)\n    \n    if is_resolved is not None:\n        query = query.filter(PerformanceAlert.is_resolved == is_resolved)\n    \n    if start_date:\n        query = query.filter(PerformanceAlert.created_at >= start_date)\n    \n    if end_date:\n        query = query.filter(PerformanceAlert.created_at <= end_date)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(PerformanceAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(PerformanceAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.cache_hit_rate=round(cache_hit_rate",
        "import:fastapi.is_resolved=alert.is_resolved",
        "import:fastapi.ImpactLevelEnum",
        "import:fastapi.StrategyCategoryEnum",
        "import:fastapi.collection_timestamp=metric.collection_timestamp",
        "import:fastapi.response_model=PerformanceMetricResponse)\nasync def get_performance_metric(\n    metric_id: str = Path(...",
        "import:fastapi.user_agent=metric.user_agent",
        "import:fastapi.APIRouter",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional"
      ]
    },
    "GET:/alerts/{alert_id}": {
      "method": "GET",
      "path": "/alerts/{alert_id}",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 158,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.EmailAlertUpdateRequest",
        "function:list_user_alerts",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.le=100",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.total=total",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailCampaign",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.page=page",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.EmailCampaignListResponse",
        "import:fastapi.HTTPException"
      ]
    },
    "PUT:/alerts/{alert_id}": {
      "method": "PUT",
      "path": "/alerts/{alert_id}",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 195,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.frequency=alert.frequency",
        "function:get_email_alert",
        "import:fastapi.ge=1",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.last_sent=alert.last_sent\n    )",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.le=100",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.total=total",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailCampaign",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.page=page",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.EmailCampaignListResponse",
        "import:fastapi.HTTPException"
      ]
    },
    "DELETE:/alerts/{alert_id}": {
      "method": "DELETE",
      "path": "/alerts/{alert_id}",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 245,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "function:update_email_alert",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.last_sent=alert.last_sent\n    )",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "GET:/templates": {
      "method": "GET",
      "path": "/templates",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 278,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.EmailAlertListResponse",
        "function:delete_email_alert",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an email alert.\n    \n    Users can only delete their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    db.delete(alert)\n    db.commit()\n    \n    logger.info(f\"Email alert deleted: {current_user.username} - {alert.alert_type}\")\n    \n    return {\"message\": \"Email alert deleted successfully\"}\n\n\n# ============================================================================\n# EMAIL TEMPLATES\n# ============================================================================",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.delete(\"/alerts/{alert_id}\")\nasync def delete_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "GET:/templates/{template_id}": {
      "method": "GET",
      "path": "/templates/{template_id}",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 340,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.description=template.description",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.text_template=template.text_template",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.subject_template=template.subject_template",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.created_at=template.created_at",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.user_id=str(alert.user_id)",
        "function:list_email_templates",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.updated_at=template.updated_at\n        ))\n    \n    return EmailTemplateListResponse(\n        templates=template_responses",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    db.delete(alert)\n    db.commit()\n    \n    logger.info(f\"Email alert deleted: {current_user.username} - {alert.alert_type}\")\n    \n    return {\"message\": \"Email alert deleted successfully\"}\n\n\n# ============================================================================\n# EMAIL TEMPLATES\n# ============================================================================\n\n@router.get(\"/templates\"",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.description=\"Filter by template type\")",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.is_active=template.is_active",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an email alert.\n    \n    Users can only delete their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.html_template=template.html_template",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.template_name=template.template_name",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email templates.\n    \n    Only active templates are returned.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailTemplate).filter(EmailTemplate.is_active == True)\n    \n    # Apply filters\n    if template_type:\n        query = query.filter(EmailTemplate.template_type == template_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailTemplate.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get templates\n    templates = query.order_by(EmailTemplate.template_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    template_responses = []\n    for template in templates:\n        template_responses.append(EmailTemplateResponse(\n            id=str(template.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.response_model=EmailTemplateListResponse)\nasync def list_email_templates(\n    page: int = Query(1",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.delete(\"/alerts/{alert_id}\")\nasync def delete_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.variables=template.variables",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.template_type=template.template_type",
        "import:fastapi.template_type: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "POST:/campaigns": {
      "method": "POST",
      "path": "/campaigns",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 377,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.description=template.description",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/templates/{template_id}\"",
        "import:fastapi.text_template=template.text_template",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.subject_template=template.subject_template",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.created_at=template.created_at",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.description=\"Template ID\")",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.updated_at=template.updated_at\n        ))\n    \n    return EmailTemplateListResponse(\n        templates=template_responses",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    db.delete(alert)\n    db.commit()\n    \n    logger.info(f\"Email alert deleted: {current_user.username} - {alert.alert_type}\")\n    \n    return {\"message\": \"Email alert deleted successfully\"}\n\n\n# ============================================================================\n# EMAIL TEMPLATES\n# ============================================================================\n\n@router.get(\"/templates\"",
        "import:fastapi.EmailTemplate.is_active == True\n        )\n    ).first()\n    \n    if not template:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.description=\"Filter by template type\")",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.is_active=template.is_active",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an email alert.\n    \n    Users can only delete their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.html_template=template.html_template",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.template_name=template.template_name",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.response_model=EmailTemplateResponse)\nasync def get_email_template(\n    template_id: str = Path(...",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email templates.\n    \n    Only active templates are returned.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailTemplate).filter(EmailTemplate.is_active == True)\n    \n    # Apply filters\n    if template_type:\n        query = query.filter(EmailTemplate.template_type == template_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailTemplate.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get templates\n    templates = query.order_by(EmailTemplate.template_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    template_responses = []\n    for template in templates:\n        template_responses.append(EmailTemplateResponse(\n            id=str(template.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "function:get_email_template",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.response_model=EmailTemplateListResponse)\nasync def list_email_templates(\n    page: int = Query(1",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.delete(\"/alerts/{alert_id}\")\nasync def delete_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.variables=template.variables",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.detail=\"Email template not found\")\n    \n    return EmailTemplateResponse(\n        id=str(template.id)",
        "import:fastapi.template_type=template.template_type",
        "import:fastapi.template_type: Optional[str] = Query(None",
        "import:fastapi.updated_at=template.updated_at\n    )\n\n\n# ============================================================================\n# EMAIL CAMPAIGNS\n# ============================================================================",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific email template by ID.\n    \"\"\"\n    template = db.query(EmailTemplate).filter(\n        and_(\n            EmailTemplate.id == template_id",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "GET:/campaigns": {
      "method": "GET",
      "path": "/campaigns",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 429,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.html_content=campaign.html_content",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.bounced_count=campaign.bounced_count",
        "import:fastapi.description=template.description",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/templates/{template_id}\"",
        "import:fastapi.text_template=template.text_template",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.is_active=campaign_data.is_active\n    )\n    \n    db.add(campaign)\n    db.commit()\n    db.refresh(campaign)\n    \n    logger.info(f\"Email campaign created: {current_user.username} - {campaign_data.campaign_name}\")\n    \n    return EmailCampaignResponse(\n        id=str(campaign.id)",
        "import:fastapi.page_size: int = Query(20",
        "function:create_email_campaign",
        "import:fastapi.subject_template=template.subject_template",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.completed_at=campaign.completed_at\n    )",
        "import:fastapi.created_at=template.created_at",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.description=\"Template ID\")",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.total_recipients=campaign.total_recipients",
        "import:fastapi.updated_at=template.updated_at\n        ))\n    \n    return EmailTemplateListResponse(\n        templates=template_responses",
        "import:fastapi.response_model=EmailCampaignResponse)\nasync def create_email_campaign(\n    campaign_data: EmailCampaignCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    db.delete(alert)\n    db.commit()\n    \n    logger.info(f\"Email alert deleted: {current_user.username} - {alert.alert_type}\")\n    \n    return {\"message\": \"Email alert deleted successfully\"}\n\n\n# ============================================================================\n# EMAIL TEMPLATES\n# ============================================================================\n\n@router.get(\"/templates\"",
        "import:fastapi.target_audience=campaign_data.target_audience",
        "import:fastapi.EmailTemplate.is_active == True\n        )\n    ).first()\n    \n    if not template:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.opened_count=campaign.opened_count",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.description=\"Filter by template type\")",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.is_active=template.is_active",
        "import:fastapi.html_content=campaign_data.html_content",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an email alert.\n    \n    Users can only delete their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.html_template=template.html_template",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.scheduled_at=campaign.scheduled_at",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.subject=campaign_data.subject",
        "import:fastapi.scheduled_at=campaign_data.scheduled_at",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.created_at=campaign.created_at",
        "import:fastapi.updated_at=campaign.updated_at",
        "import:fastapi.template_name=template.template_name",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.response_model=EmailTemplateResponse)\nasync def get_email_template(\n    template_id: str = Path(...",
        "import:fastapi.clicked_count=campaign.clicked_count",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.delivered_count=campaign.delivered_count",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email templates.\n    \n    Only active templates are returned.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailTemplate).filter(EmailTemplate.is_active == True)\n    \n    # Apply filters\n    if template_type:\n        query = query.filter(EmailTemplate.template_type == template_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailTemplate.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get templates\n    templates = query.order_by(EmailTemplate.template_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    template_responses = []\n    for template in templates:\n        template_responses.append(EmailTemplateResponse(\n            id=str(template.id)",
        "import:fastapi.is_active=campaign.is_active",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.response_model=EmailTemplateListResponse)\nasync def list_email_templates(\n    page: int = Query(1",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.target_audience=campaign.target_audience",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.started_at=campaign.started_at",
        "import:fastapi.campaign_type=campaign_data.campaign_type",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email campaign.\n    \n    This is typically used by administrators for bulk communications.\n    \"\"\"\n    # Create new campaign\n    campaign = EmailCampaign(\n        campaign_name=campaign_data.campaign_name",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.campaign_type=campaign.campaign_type",
        "import:fastapi.sent_count=campaign.sent_count",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.delete(\"/alerts/{alert_id}\")\nasync def delete_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.updated_at=template.updated_at\n    )\n\n\n# ============================================================================\n# EMAIL CAMPAIGNS\n# ============================================================================\n\n@router.post(\"/campaigns\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.variables=template.variables",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.subject=campaign.subject",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.text_content=campaign_data.text_content",
        "import:fastapi.detail=\"Email template not found\")\n    \n    return EmailTemplateResponse(\n        id=str(template.id)",
        "import:fastapi.template_type=template.template_type",
        "import:fastapi.template_type: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.text_content=campaign.text_content",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.campaign_name=campaign.campaign_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific email template by ID.\n    \"\"\"\n    template = db.query(EmailTemplate).filter(\n        and_(\n            EmailTemplate.id == template_id",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "GET:/analytics": {
      "method": "GET",
      "path": "/analytics",
      "file": "services/api-gateway/app/api/v1/user_profiles.py",
      "line": 18,
      "dependencies": [
        "import:fastapi.Riding\n\nrouter = APIRouter()",
        "import:fastapi.Party",
        "import:fastapi.List",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Dict",
        "import:fastapi.ElectedMember",
        "import:fastapi.VoteQuestion",
        "import:fastapi.APIRouter",
        "import:fastapi.Politician",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional"
      ]
    },
    "GET:/alerts/stats": {
      "method": "GET",
      "path": "/alerts/stats",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 602,
      "dependencies": [
        "import:fastapi.\"opened\": len([log for log in campaign_logs if log.status == \"opened\"])",
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=EmailAnalyticsResponse)\nasync def get_email_analytics(\n    date_from: Optional[str] = Query(None",
        "import:fastapi.html_content=campaign.html_content",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.\"total_sent\": len(campaign_logs)",
        "import:fastapi.bounced_count=campaign.bounced_count",
        "import:fastapi.description=template.description",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/templates/{template_id}\"",
        "import:fastapi.text_template=template.text_template",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.is_active=campaign_data.is_active\n    )\n    \n    db.add(campaign)\n    db.commit()\n    db.refresh(campaign)\n    \n    logger.info(f\"Email campaign created: {current_user.username} - {campaign_data.campaign_name}\")\n    \n    return EmailCampaignResponse(\n        id=str(campaign.id)",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(EmailLog.created_at <= date_to_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.subject_template=template.subject_template",
        "import:fastapi.\"bounced\": len([log for log in campaign_logs if log.status == \"bounced\"])\n            })\n    \n    return EmailAnalyticsResponse(\n        total_emails_sent=total_sent",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get comprehensive email analytics.\n    \n    This provides insights into email performance and engagement.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailLog)\n    \n    # Apply date filters\n    if date_from:\n        try:\n            date_from_obj = datetime.strptime(date_from",
        "import:fastapi.click_rate=round(click_rate",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date_to:\n        try:\n            date_to_obj = datetime.strptime(date_to",
        "import:fastapi.description=\"Filter by campaign type\")",
        "import:fastapi.created_at=template.created_at",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.completed_at=campaign.completed_at\n    )\n\n\n@router.get(\"/campaigns\"",
        "import:fastapi.field",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.description=\"Template ID\")",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.total_recipients=campaign.total_recipients",
        "import:fastapi.updated_at=template.updated_at\n        ))\n    \n    return EmailTemplateListResponse(\n        templates=template_responses",
        "import:fastapi.response_model=EmailCampaignResponse)\nasync def create_email_campaign(\n    campaign_data: EmailCampaignCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.campaign_performance=campaign_performance",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    db.delete(alert)\n    db.commit()\n    \n    logger.info(f\"Email alert deleted: {current_user.username} - {alert.alert_type}\")\n    \n    return {\"message\": \"Email alert deleted successfully\"}\n\n\n# ============================================================================\n# EMAIL TEMPLATES\n# ============================================================================\n\n@router.get(\"/templates\"",
        "import:fastapi.\"clicked\"]])",
        "import:fastapi.target_audience=campaign_data.target_audience",
        "import:fastapi.EmailTemplate.is_active == True\n        )\n    ).first()\n    \n    if not template:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.response_model=EmailCampaignListResponse)\nasync def list_email_campaigns(\n    page: int = Query(1",
        "import:fastapi.opened_count=campaign.opened_count",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.description=\"Filter by template type\")",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.is_active=template.is_active",
        "import:fastapi.html_content=campaign_data.html_content",
        "import:fastapi.total_emails_bounced=total_bounced",
        "import:fastapi.open_rate=round(open_rate",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an email alert.\n    \n    Users can only delete their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email campaigns.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailCampaign)\n    \n    # Apply filters\n    if campaign_type:\n        query = query.filter(EmailCampaign.campaign_type == campaign_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailCampaign.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get campaigns\n    campaigns = query.order_by(EmailCampaign.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    campaign_responses = []\n    for campaign in campaigns:\n        campaign_responses.append(EmailCampaignResponse(\n            id=str(campaign.id)",
        "import:fastapi.html_template=template.html_template",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.scheduled_at=campaign.scheduled_at",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.opens_by_day=opens_by_day",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.total_emails_opened=total_opened",
        "import:fastapi.subject=campaign_data.subject",
        "import:fastapi.scheduled_at=campaign_data.scheduled_at",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.\"opened\"",
        "import:fastapi.\"clicked\"])).count()\n    total_delivered = query.filter(EmailLog.status.in_([\"delivered\"",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.created_at=campaign.created_at",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(EmailLog.created_at >= date_from_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"campaign_name\": campaign.campaign_name",
        "import:fastapi.updated_at=campaign.updated_at",
        "import:fastapi.template_name=template.template_name",
        "import:fastapi.delivery_rate=round(delivery_rate",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.response_model=EmailTemplateResponse)\nasync def get_email_template(\n    template_id: str = Path(...",
        "import:fastapi.clicks_by_day=clicks_by_day",
        "import:fastapi.clicked_count=campaign.clicked_count",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.delivered_count=campaign.delivered_count",
        "import:fastapi.\"delivered\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email templates.\n    \n    Only active templates are returned.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailTemplate).filter(EmailTemplate.is_active == True)\n    \n    # Apply filters\n    if template_type:\n        query = query.filter(EmailTemplate.template_type == template_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailTemplate.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get templates\n    templates = query.order_by(EmailTemplate.template_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    template_responses = []\n    for template in templates:\n        template_responses.append(EmailTemplateResponse(\n            id=str(template.id)",
        "import:fastapi.is_active=campaign.is_active",
        "function:get_email_analytics",
        "import:fastapi.total_emails_failed=total_failed",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.response_model=EmailTemplateListResponse)\nasync def list_email_templates(\n    page: int = Query(1",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.target_audience=campaign.target_audience",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.started_at=campaign.started_at",
        "import:fastapi.campaign_type=campaign_data.campaign_type",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get email counts by status\n    total_sent = query.filter(EmailLog.status.in_([\"sent\"",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.\"delivered\": len([log for log in campaign_logs if log.status in [\"delivered\"",
        "import:fastapi.generated_at=datetime.utcnow()\n    )",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email campaign.\n    \n    This is typically used by administrators for bulk communications.\n    \"\"\"\n    # Create new campaign\n    campaign = EmailCampaign(\n        campaign_name=campaign_data.campaign_name",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.campaign_type=campaign.campaign_type",
        "import:fastapi.sent_count=campaign.sent_count",
        "import:fastapi.\"clicked\"])).count()\n    total_opened = query.filter(EmailLog.status == \"opened\").count()\n    total_clicked = query.filter(EmailLog.status == \"clicked\").count()\n    total_bounced = query.filter(EmailLog.status == \"bounced\").count()\n    total_failed = query.filter(EmailLog.status == \"failed\").count()\n    \n    # Calculate rates\n    delivery_rate = (total_delivered / total_sent * 100) if total_sent > 0 else 0\n    open_rate = (total_opened / total_delivered * 100) if total_delivered > 0 else 0\n    click_rate = (total_clicked / total_delivered * 100) if total_delivered > 0 else 0\n    bounce_rate = (total_bounced / total_sent * 100) if total_sent > 0 else 0\n    \n    # Get time-based analytics (last 30 days if no date range specified)\n    if not date_from and not date_to:\n        date_from_obj = datetime.utcnow() - timedelta(days=30)\n        date_to_obj = datetime.utcnow()\n    else:\n        date_from_obj = date_from_obj if date_from else datetime.utcnow() - timedelta(days=30)\n        date_to_obj = date_to_obj if date_to else datetime.utcnow()\n    \n    # Get emails by day\n    emails_by_day = {}\n    opens_by_day = {}\n    clicks_by_day = {}\n    \n    current_date = date_from_obj\n    while current_date <= date_to_obj:\n        date_str = current_date.strftime(\"%Y-%m-%d\")\n        emails_by_day[date_str] = 0\n        opens_by_day[date_str] = 0\n        clicks_by_day[date_str] = 0\n        current_date += timedelta(days=1)\n    \n    # Get campaign performance\n    campaign_performance = []\n    campaigns = db.query(EmailCampaign).filter(EmailCampaign.is_active == True).all()\n    \n    for campaign in campaigns:\n        campaign_logs = query.filter(EmailCampaign.id == campaign.id).all()\n        if campaign_logs:\n            campaign_performance.append({\n                \"campaign_id\": str(campaign.id)",
        "import:fastapi.bounce_rate=round(bounce_rate",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.delete(\"/alerts/{alert_id}\")\nasync def delete_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.2)",
        "import:fastapi.updated_at=template.updated_at\n    )\n\n\n# ============================================================================\n# EMAIL CAMPAIGNS\n# ============================================================================\n\n@router.post(\"/campaigns\"",
        "import:fastapi.total_emails_clicked=total_clicked",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.\"clicked\": len([log for log in campaign_logs if log.status == \"clicked\"])",
        "import:fastapi.variables=template.variables",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# EMAIL ANALYTICS\n# ============================================================================\n\n@router.get(\"/analytics\"",
        "import:fastapi.subject=campaign.subject",
        "import:fastapi.emails_by_day=emails_by_day",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.text_content=campaign_data.text_content",
        "import:fastapi.completed_at=campaign.completed_at\n        ))\n    \n    return EmailCampaignListResponse(\n        campaigns=campaign_responses",
        "import:fastapi.total_emails_delivered=total_delivered",
        "import:fastapi.detail=\"Email template not found\")\n    \n    return EmailTemplateResponse(\n        id=str(template.id)",
        "import:fastapi.campaign_type: Optional[str] = Query(None",
        "import:fastapi.template_type=template.template_type",
        "import:fastapi.template_type: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.text_content=campaign.text_content",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.campaign_name=campaign.campaign_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific email template by ID.\n    \"\"\"\n    template = db.query(EmailTemplate).filter(\n        and_(\n            EmailTemplate.id == template_id",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "POST:/notifications/send": {
      "method": "POST",
      "path": "/notifications/send",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 659,
      "dependencies": [
        "import:fastapi.\"opened\": len([log for log in campaign_logs if log.status == \"opened\"])",
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=EmailAnalyticsResponse)\nasync def get_email_analytics(\n    date_from: Optional[str] = Query(None",
        "import:fastapi.html_content=campaign.html_content",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.\"total_sent\": len(campaign_logs)",
        "import:fastapi.bounced_count=campaign.bounced_count",
        "import:fastapi.description=template.description",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/templates/{template_id}\"",
        "import:fastapi.emails_opened=emails_opened",
        "import:fastapi.text_template=template.text_template",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.is_active=campaign_data.is_active\n    )\n    \n    db.add(campaign)\n    db.commit()\n    db.refresh(campaign)\n    \n    logger.info(f\"Email campaign created: {current_user.username} - {campaign_data.campaign_name}\")\n    \n    return EmailCampaignResponse(\n        id=str(campaign.id)",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(EmailLog.created_at <= date_to_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.subject_template=template.subject_template",
        "import:fastapi.\"bounced\": len([log for log in campaign_logs if log.status == \"bounced\"])\n            })\n    \n    return EmailAnalyticsResponse(\n        total_emails_sent=total_sent",
        "import:fastapi.emails_clicked=emails_clicked",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get comprehensive email analytics.\n    \n    This provides insights into email performance and engagement.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailLog)\n    \n    # Apply date filters\n    if date_from:\n        try:\n            date_from_obj = datetime.strptime(date_from",
        "import:fastapi.click_rate=round(click_rate",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date_to:\n        try:\n            date_to_obj = datetime.strptime(date_to",
        "import:fastapi.description=\"Filter by campaign type\")",
        "import:fastapi.created_at=template.created_at",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.completed_at=campaign.completed_at\n    )\n\n\n@router.get(\"/campaigns\"",
        "import:fastapi.field",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.description=\"Template ID\")",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.total_recipients=campaign.total_recipients",
        "import:fastapi.response_model=EmailAlertStatsResponse)\nasync def get_user_alert_stats(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.updated_at=template.updated_at\n        ))\n    \n    return EmailTemplateListResponse(\n        templates=template_responses",
        "import:fastapi.response_model=EmailCampaignResponse)\nasync def create_email_campaign(\n    campaign_data: EmailCampaignCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.campaign_performance=campaign_performance",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    db.delete(alert)\n    db.commit()\n    \n    logger.info(f\"Email alert deleted: {current_user.username} - {alert.alert_type}\")\n    \n    return {\"message\": \"Email alert deleted successfully\"}\n\n\n# ============================================================================\n# EMAIL TEMPLATES\n# ============================================================================\n\n@router.get(\"/templates\"",
        "import:fastapi.\"clicked\"]])",
        "import:fastapi.target_audience=campaign_data.target_audience",
        "import:fastapi.EmailTemplate.is_active == True\n        )\n    ).first()\n    \n    if not template:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.total_alerts=total_alerts",
        "import:fastapi.response_model=EmailCampaignListResponse)\nasync def list_email_campaigns(\n    page: int = Query(1",
        "import:fastapi.opened_count=campaign.opened_count",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.description=\"Filter by template type\")",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.is_active=template.is_active",
        "import:fastapi.html_content=campaign_data.html_content",
        "import:fastapi.total_emails_bounced=total_bounced",
        "import:fastapi.generated_at=datetime.utcnow()\n    )\n\n\n@router.get(\"/alerts/stats\"",
        "import:fastapi.open_rate=round(open_rate",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an email alert.\n    \n    Users can only delete their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email campaigns.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailCampaign)\n    \n    # Apply filters\n    if campaign_type:\n        query = query.filter(EmailCampaign.campaign_type == campaign_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailCampaign.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get campaigns\n    campaigns = query.order_by(EmailCampaign.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    campaign_responses = []\n    for campaign in campaigns:\n        campaign_responses.append(EmailCampaignResponse(\n            id=str(campaign.id)",
        "import:fastapi.html_template=template.html_template",
        "import:fastapi.engagement_rate=round(engagement_rate",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.scheduled_at=campaign.scheduled_at",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.opens_by_day=opens_by_day",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.total_emails_opened=total_opened",
        "import:fastapi.subject=campaign_data.subject",
        "import:fastapi.total_emails_received=total_emails_received",
        "import:fastapi.scheduled_at=campaign_data.scheduled_at",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.\"opened\"",
        "import:fastapi.\"clicked\"])).count()\n    total_delivered = query.filter(EmailLog.status.in_([\"delivered\"",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.created_at=campaign.created_at",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(EmailLog.created_at >= date_from_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"campaign_name\": campaign.campaign_name",
        "import:fastapi.updated_at=campaign.updated_at",
        "import:fastapi.template_name=template.template_name",
        "import:fastapi.delivery_rate=round(delivery_rate",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.response_model=EmailTemplateResponse)\nasync def get_email_template(\n    template_id: str = Path(...",
        "import:fastapi.clicks_by_day=clicks_by_day",
        "import:fastapi.clicked_count=campaign.clicked_count",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.delivered_count=campaign.delivered_count",
        "import:fastapi.\"delivered\"",
        "import:fastapi.generated_at=datetime.utcnow()\n    )\n\n\n# ============================================================================\n# EMAIL NOTIFICATIONS\n# ============================================================================",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email templates.\n    \n    Only active templates are returned.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailTemplate).filter(EmailTemplate.is_active == True)\n    \n    # Apply filters\n    if template_type:\n        query = query.filter(EmailTemplate.template_type == template_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailTemplate.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get templates\n    templates = query.order_by(EmailTemplate.template_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    template_responses = []\n    for template in templates:\n        template_responses.append(EmailTemplateResponse(\n            id=str(template.id)",
        "import:fastapi.last_alert_sent=last_alert_sent",
        "import:fastapi.is_active=campaign.is_active",
        "import:fastapi.total_emails_failed=total_failed",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.response_model=EmailTemplateListResponse)\nasync def list_email_templates(\n    page: int = Query(1",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.target_audience=campaign.target_audience",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.started_at=campaign.started_at",
        "import:fastapi.campaign_type=campaign_data.campaign_type",
        "import:fastapi.0) + 1\n    \n    # Get last alert sent\n    last_alert_sent = None\n    if user_alerts:\n        last_alert_sent = max([alert.last_sent for alert in user_alerts if alert.last_sent])\n    \n    # Calculate email engagement\n    total_emails_received = len(user_logs)\n    emails_opened = len([log for log in user_logs if log.status == \"opened\"])\n    emails_clicked = len([log for log in user_logs if log.status == \"clicked\"])\n    engagement_rate = (emails_opened / total_emails_received * 100) if total_emails_received > 0 else 0\n    \n    return EmailAlertStatsResponse(\n        user_id=str(current_user.id)",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get email counts by status\n    total_sent = query.filter(EmailLog.status.in_([\"sent\"",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.\"delivered\": len([log for log in campaign_logs if log.status in [\"delivered\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email campaign.\n    \n    This is typically used by administrators for bulk communications.\n    \"\"\"\n    # Create new campaign\n    campaign = EmailCampaign(\n        campaign_name=campaign_data.campaign_name",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.campaign_type=campaign.campaign_type",
        "import:fastapi.sent_count=campaign.sent_count",
        "import:fastapi.\"clicked\"])).count()\n    total_opened = query.filter(EmailLog.status == \"opened\").count()\n    total_clicked = query.filter(EmailLog.status == \"clicked\").count()\n    total_bounced = query.filter(EmailLog.status == \"bounced\").count()\n    total_failed = query.filter(EmailLog.status == \"failed\").count()\n    \n    # Calculate rates\n    delivery_rate = (total_delivered / total_sent * 100) if total_sent > 0 else 0\n    open_rate = (total_opened / total_delivered * 100) if total_delivered > 0 else 0\n    click_rate = (total_clicked / total_delivered * 100) if total_delivered > 0 else 0\n    bounce_rate = (total_bounced / total_sent * 100) if total_sent > 0 else 0\n    \n    # Get time-based analytics (last 30 days if no date range specified)\n    if not date_from and not date_to:\n        date_from_obj = datetime.utcnow() - timedelta(days=30)\n        date_to_obj = datetime.utcnow()\n    else:\n        date_from_obj = date_from_obj if date_from else datetime.utcnow() - timedelta(days=30)\n        date_to_obj = date_to_obj if date_to else datetime.utcnow()\n    \n    # Get emails by day\n    emails_by_day = {}\n    opens_by_day = {}\n    clicks_by_day = {}\n    \n    current_date = date_from_obj\n    while current_date <= date_to_obj:\n        date_str = current_date.strftime(\"%Y-%m-%d\")\n        emails_by_day[date_str] = 0\n        opens_by_day[date_str] = 0\n        clicks_by_day[date_str] = 0\n        current_date += timedelta(days=1)\n    \n    # Get campaign performance\n    campaign_performance = []\n    campaigns = db.query(EmailCampaign).filter(EmailCampaign.is_active == True).all()\n    \n    for campaign in campaigns:\n        campaign_logs = query.filter(EmailCampaign.id == campaign.id).all()\n        if campaign_logs:\n            campaign_performance.append({\n                \"campaign_id\": str(campaign.id)",
        "import:fastapi.alerts_by_frequency=alerts_by_frequency",
        "import:fastapi.bounce_rate=round(bounce_rate",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.delete(\"/alerts/{alert_id}\")\nasync def delete_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.2)",
        "import:fastapi.updated_at=template.updated_at\n    )\n\n\n# ============================================================================\n# EMAIL CAMPAIGNS\n# ============================================================================\n\n@router.post(\"/campaigns\"",
        "import:fastapi.total_emails_clicked=total_clicked",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.0) + 1\n        alerts_by_frequency[alert.frequency] = alerts_by_frequency.get(alert.frequency",
        "function:get_user_alert_stats",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.\"clicked\": len([log for log in campaign_logs if log.status == \"clicked\"])",
        "import:fastapi.variables=template.variables",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# EMAIL ANALYTICS\n# ============================================================================\n\n@router.get(\"/analytics\"",
        "import:fastapi.subject=campaign.subject",
        "import:fastapi.emails_by_day=emails_by_day",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.text_content=campaign_data.text_content",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get email alert statistics for the current user.\n    \"\"\"\n    # Get user's alerts\n    user_alerts = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.completed_at=campaign.completed_at\n        ))\n    \n    return EmailCampaignListResponse(\n        campaigns=campaign_responses",
        "import:fastapi.alerts_by_type=alerts_by_type",
        "import:fastapi.total_emails_delivered=total_delivered",
        "import:fastapi.detail=\"Email template not found\")\n    \n    return EmailTemplateResponse(\n        id=str(template.id)",
        "import:fastapi.campaign_type: Optional[str] = Query(None",
        "import:fastapi.template_type=template.template_type",
        "import:fastapi.template_type: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.text_content=campaign.text_content",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.EmailAlert.is_active == True\n        )\n    ).all()\n    \n    # Get user's email logs\n    user_logs = db.query(EmailLog).filter(EmailLog.user_id == current_user.id).all()\n    \n    # Calculate statistics\n    total_alerts = len(user_alerts)\n    alerts_by_type = {}\n    alerts_by_frequency = {}\n    \n    for alert in user_alerts:\n        alerts_by_type[alert.alert_type] = alerts_by_type.get(alert.alert_type",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.campaign_name=campaign.campaign_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific email template by ID.\n    \"\"\"\n    template = db.query(EmailTemplate).filter(\n        and_(\n            EmailTemplate.id == template_id",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "POST:/unsubscribe/generate": {
      "method": "POST",
      "path": "/unsubscribe/generate",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 756,
      "dependencies": [
        "import:fastapi.\"opened\": len([log for log in campaign_logs if log.status == \"opened\"])",
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=EmailAnalyticsResponse)\nasync def get_email_analytics(\n    date_from: Optional[str] = Query(None",
        "import:fastapi.html_content=campaign.html_content",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.\"total_sent\": len(campaign_logs)",
        "import:fastapi.bounced_count=campaign.bounced_count",
        "import:fastapi.description=template.description",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/templates/{template_id}\"",
        "import:fastapi.emails_opened=emails_opened",
        "import:fastapi.text_template=template.text_template",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.is_active=campaign_data.is_active\n    )\n    \n    db.add(campaign)\n    db.commit()\n    db.refresh(campaign)\n    \n    logger.info(f\"Email campaign created: {current_user.username} - {campaign_data.campaign_name}\")\n    \n    return EmailCampaignResponse(\n        id=str(campaign.id)",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(EmailLog.created_at <= date_to_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.subject_template=template.subject_template",
        "import:fastapi.\"bounced\": len([log for log in campaign_logs if log.status == \"bounced\"])\n            })\n    \n    return EmailAnalyticsResponse(\n        total_emails_sent=total_sent",
        "import:fastapi.emails_clicked=emails_clicked",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get comprehensive email analytics.\n    \n    This provides insights into email performance and engagement.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailLog)\n    \n    # Apply date filters\n    if date_from:\n        try:\n            date_from_obj = datetime.strptime(date_from",
        "import:fastapi.click_rate=round(click_rate",
        "import:fastapi.sent_at=datetime.utcnow()\n        )\n        \n        db.add(email_log)\n        db.commit()\n        \n        logger.info(f\"Email notification sent: {user.email} - {notification_data.content.title}\")\n        \n        return EmailNotificationResponse(\n            success=True",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date_to:\n        try:\n            date_to_obj = datetime.strptime(date_to",
        "import:fastapi.EmailTemplate.is_active == True\n            )\n        ).first()\n    \n    try:\n        # In a real implementation",
        "import:fastapi.description=\"Filter by campaign type\")",
        "import:fastapi.EmailTemplate.is_active == True\n        )\n    ).first()\n    \n    if not template:\n        # Use default template\n        template = db.query(EmailTemplate).filter(\n            and_(\n                EmailTemplate.template_name == \"default\"",
        "import:fastapi.created_at=template.created_at",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.completed_at=campaign.completed_at\n    )\n\n\n@router.get(\"/campaigns\"",
        "import:fastapi.field",
        "import:fastapi.EmailAlert.alert_type == notification_data.alert_type",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.description=\"Template ID\")",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.total_recipients=campaign.total_recipients",
        "import:fastapi.response_model=EmailAlertStatsResponse)\nasync def get_user_alert_stats(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.updated_at=template.updated_at\n        ))\n    \n    return EmailTemplateListResponse(\n        templates=template_responses",
        "import:fastapi.error_message=str(e)\n        )\n        \n        db.add(email_log)\n        db.commit()\n        \n        return EmailNotificationResponse(\n            success=False",
        "import:fastapi.response_model=EmailCampaignResponse)\nasync def create_email_campaign(\n    campaign_data: EmailCampaignCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.campaign_performance=campaign_performance",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    db.delete(alert)\n    db.commit()\n    \n    logger.info(f\"Email alert deleted: {current_user.username} - {alert.alert_type}\")\n    \n    return {\"message\": \"Email alert deleted successfully\"}\n\n\n# ============================================================================\n# EMAIL TEMPLATES\n# ============================================================================\n\n@router.get(\"/templates\"",
        "import:fastapi.detail=\"User does not have active alerts for this type\")\n    \n    # Get appropriate template\n    template = db.query(EmailTemplate).filter(\n        and_(\n            EmailTemplate.template_type == notification_data.alert_type",
        "import:fastapi.\"clicked\"]])",
        "import:fastapi.target_audience=campaign_data.target_audience",
        "import:fastapi.EmailTemplate.is_active == True\n        )\n    ).first()\n    \n    if not template:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.we'll just log it and create a log entry\n        \n        # Create email log entry\n        email_log = EmailLog(\n            user_id=notification_data.user_id",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.total_alerts=total_alerts",
        "import:fastapi.response_model=EmailCampaignListResponse)\nasync def list_email_campaigns(\n    page: int = Query(1",
        "import:fastapi.opened_count=campaign.opened_count",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.error_message=str(e)",
        "import:fastapi.description=\"Filter by template type\")",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.this would send the actual email\n        # For now",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.is_active=template.is_active",
        "import:fastapi.html_content=campaign_data.html_content",
        "import:fastapi.total_emails_bounced=total_bounced",
        "import:fastapi.generated_at=datetime.utcnow()\n    )\n\n\n@router.get(\"/alerts/stats\"",
        "import:fastapi.open_rate=round(open_rate",
        "import:fastapi.message_id=str(email_log.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an email alert.\n    \n    Users can only delete their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.email_type=\"alert\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email campaigns.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailCampaign)\n    \n    # Apply filters\n    if campaign_type:\n        query = query.filter(EmailCampaign.campaign_type == campaign_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailCampaign.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get campaigns\n    campaigns = query.order_by(EmailCampaign.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    campaign_responses = []\n    for campaign in campaigns:\n        campaign_responses.append(EmailCampaignResponse(\n            id=str(campaign.id)",
        "import:fastapi.html_template=template.html_template",
        "import:fastapi.engagement_rate=round(engagement_rate",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.scheduled_at=campaign.scheduled_at",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.opens_by_day=opens_by_day",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.total_emails_opened=total_opened",
        "import:fastapi.subject=campaign_data.subject",
        "import:fastapi.total_emails_received=total_emails_received",
        "import:fastapi.sent_at=datetime.utcnow()\n        )\n\n\n# ============================================================================\n# UNSUBSCRIBE MANAGEMENT\n# ============================================================================",
        "import:fastapi.scheduled_at=campaign_data.scheduled_at",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.\"opened\"",
        "import:fastapi.\"clicked\"])).count()\n    total_delivered = query.filter(EmailLog.status.in_([\"delivered\"",
        "import:fastapi.response_model=EmailNotificationResponse)\nasync def send_email_notification(\n    notification_data: EmailNotificationRequest = Body(...)",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.created_at=campaign.created_at",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(EmailLog.created_at >= date_from_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"campaign_name\": campaign.campaign_name",
        "import:fastapi.updated_at=campaign.updated_at",
        "import:fastapi.template_name=template.template_name",
        "import:fastapi.delivery_rate=round(delivery_rate",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.response_model=EmailTemplateResponse)\nasync def get_email_template(\n    template_id: str = Path(...",
        "import:fastapi.EmailAlert.is_active == True\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=400",
        "import:fastapi.clicks_by_day=clicks_by_day",
        "import:fastapi.clicked_count=campaign.clicked_count",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.delivered_count=campaign.delivered_count",
        "import:fastapi.\"delivered\"",
        "import:fastapi.status=\"failed\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email templates.\n    \n    Only active templates are returned.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailTemplate).filter(EmailTemplate.is_active == True)\n    \n    # Apply filters\n    if template_type:\n        query = query.filter(EmailTemplate.template_type == template_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailTemplate.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get templates\n    templates = query.order_by(EmailTemplate.template_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    template_responses = []\n    for template in templates:\n        template_responses.append(EmailTemplateResponse(\n            id=str(template.id)",
        "import:fastapi.last_alert_sent=last_alert_sent",
        "import:fastapi.is_active=campaign.is_active",
        "import:fastapi.total_emails_failed=total_failed",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Send an email notification.\n    \n    This endpoint is used to trigger immediate email notifications.\n    \"\"\"\n    # Get user\n    user = db.query(User).filter(User.id == notification_data.user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.response_model=EmailTemplateListResponse)\nasync def list_email_templates(\n    page: int = Query(1",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "function:send_email_notification",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.target_audience=campaign.target_audience",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.started_at=campaign.started_at",
        "import:fastapi.campaign_type=campaign_data.campaign_type",
        "import:fastapi.0) + 1\n    \n    # Get last alert sent\n    last_alert_sent = None\n    if user_alerts:\n        last_alert_sent = max([alert.last_sent for alert in user_alerts if alert.last_sent])\n    \n    # Calculate email engagement\n    total_emails_received = len(user_logs)\n    emails_opened = len([log for log in user_logs if log.status == \"opened\"])\n    emails_clicked = len([log for log in user_logs if log.status == \"clicked\"])\n    engagement_rate = (emails_opened / total_emails_received * 100) if total_emails_received > 0 else 0\n    \n    return EmailAlertStatsResponse(\n        user_id=str(current_user.id)",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get email counts by status\n    total_sent = query.filter(EmailLog.status.in_([\"sent\"",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.\"delivered\": len([log for log in campaign_logs if log.status in [\"delivered\"",
        "import:fastapi.sent_at=email_log.sent_at\n        )\n        \n    except Exception as e:\n        logger.error(f\"Failed to send email notification: {str(e)}\")\n        \n        # Create failed log entry\n        email_log = EmailLog(\n            user_id=notification_data.user_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email campaign.\n    \n    This is typically used by administrators for bulk communications.\n    \"\"\"\n    # Create new campaign\n    campaign = EmailCampaign(\n        campaign_name=campaign_data.campaign_name",
        "import:fastapi.total=total",
        "import:fastapi.subject=f\"OpenPolicy Update: {notification_data.content.title}\"",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.recipient_email=user.email",
        "import:fastapi.campaign_type=campaign.campaign_type",
        "import:fastapi.sent_count=campaign.sent_count",
        "import:fastapi.\"clicked\"])).count()\n    total_opened = query.filter(EmailLog.status == \"opened\").count()\n    total_clicked = query.filter(EmailLog.status == \"clicked\").count()\n    total_bounced = query.filter(EmailLog.status == \"bounced\").count()\n    total_failed = query.filter(EmailLog.status == \"failed\").count()\n    \n    # Calculate rates\n    delivery_rate = (total_delivered / total_sent * 100) if total_sent > 0 else 0\n    open_rate = (total_opened / total_delivered * 100) if total_delivered > 0 else 0\n    click_rate = (total_clicked / total_delivered * 100) if total_delivered > 0 else 0\n    bounce_rate = (total_bounced / total_sent * 100) if total_sent > 0 else 0\n    \n    # Get time-based analytics (last 30 days if no date range specified)\n    if not date_from and not date_to:\n        date_from_obj = datetime.utcnow() - timedelta(days=30)\n        date_to_obj = datetime.utcnow()\n    else:\n        date_from_obj = date_from_obj if date_from else datetime.utcnow() - timedelta(days=30)\n        date_to_obj = date_to_obj if date_to else datetime.utcnow()\n    \n    # Get emails by day\n    emails_by_day = {}\n    opens_by_day = {}\n    clicks_by_day = {}\n    \n    current_date = date_from_obj\n    while current_date <= date_to_obj:\n        date_str = current_date.strftime(\"%Y-%m-%d\")\n        emails_by_day[date_str] = 0\n        opens_by_day[date_str] = 0\n        clicks_by_day[date_str] = 0\n        current_date += timedelta(days=1)\n    \n    # Get campaign performance\n    campaign_performance = []\n    campaigns = db.query(EmailCampaign).filter(EmailCampaign.is_active == True).all()\n    \n    for campaign in campaigns:\n        campaign_logs = query.filter(EmailCampaign.id == campaign.id).all()\n        if campaign_logs:\n            campaign_performance.append({\n                \"campaign_id\": str(campaign.id)",
        "import:fastapi.alerts_by_frequency=alerts_by_frequency",
        "import:fastapi.bounce_rate=round(bounce_rate",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.delete(\"/alerts/{alert_id}\")\nasync def delete_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.2)",
        "import:fastapi.generated_at=datetime.utcnow()\n    )\n\n\n# ============================================================================\n# EMAIL NOTIFICATIONS\n# ============================================================================\n\n@router.post(\"/notifications/send\"",
        "import:fastapi.updated_at=template.updated_at\n    )\n\n\n# ============================================================================\n# EMAIL CAMPAIGNS\n# ============================================================================\n\n@router.post(\"/campaigns\"",
        "import:fastapi.total_emails_clicked=total_clicked",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.0) + 1\n        alerts_by_frequency[alert.frequency] = alerts_by_frequency.get(alert.frequency",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.\"clicked\": len([log for log in campaign_logs if log.status == \"clicked\"])",
        "import:fastapi.variables=template.variables",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.status=\"sent\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# EMAIL ANALYTICS\n# ============================================================================\n\n@router.get(\"/analytics\"",
        "import:fastapi.subject=campaign.subject",
        "import:fastapi.emails_by_day=emails_by_day",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.text_content=campaign_data.text_content",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get email alert statistics for the current user.\n    \"\"\"\n    # Get user's alerts\n    user_alerts = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.completed_at=campaign.completed_at\n        ))\n    \n    return EmailCampaignListResponse(\n        campaigns=campaign_responses",
        "import:fastapi.alerts_by_type=alerts_by_type",
        "import:fastapi.total_emails_delivered=total_delivered",
        "import:fastapi.detail=\"Email template not found\")\n    \n    return EmailTemplateResponse(\n        id=str(template.id)",
        "import:fastapi.campaign_type: Optional[str] = Query(None",
        "import:fastapi.template_type=template.template_type",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get user's email alert preferences\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == notification_data.user_id",
        "import:fastapi.template_type: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.text_content=campaign.text_content",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.EmailAlert.is_active == True\n        )\n    ).all()\n    \n    # Get user's email logs\n    user_logs = db.query(EmailLog).filter(EmailLog.user_id == current_user.id).all()\n    \n    # Calculate statistics\n    total_alerts = len(user_alerts)\n    alerts_by_type = {}\n    alerts_by_frequency = {}\n    \n    for alert in user_alerts:\n        alerts_by_type[alert.alert_type] = alerts_by_type.get(alert.alert_type",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.campaign_name=campaign.campaign_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific email template by ID.\n    \"\"\"\n    template = db.query(EmailTemplate).filter(\n        and_(\n            EmailTemplate.id == template_id",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "POST:/unsubscribe/{token}": {
      "method": "POST",
      "path": "/unsubscribe/{token}",
      "file": "services/api-gateway/app/api/v1/email_alerts.py",
      "line": 792,
      "dependencies": [
        "import:fastapi.\"opened\": len([log for log in campaign_logs if log.status == \"opened\"])",
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=EmailAnalyticsResponse)\nasync def get_email_analytics(\n    date_from: Optional[str] = Query(None",
        "import:fastapi.html_content=campaign.html_content",
        "import:fastapi.alert_type=alert.alert_type",
        "import:fastapi.\"total_sent\": len(campaign_logs)",
        "import:fastapi.bounced_count=campaign.bounced_count",
        "import:fastapi.description=template.description",
        "import:fastapi.description=\"Alert ID\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom typing import Optional\nfrom datetime import datetime",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/templates/{template_id}\"",
        "import:fastapi.emails_opened=emails_opened",
        "import:fastapi.description=\"Specific alert type to unsubscribe from\")",
        "import:fastapi.text_template=template.text_template",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def get_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.is_active=campaign_data.is_active\n    )\n    \n    db.add(campaign)\n    db.commit()\n    db.refresh(campaign)\n    \n    logger.info(f\"Email campaign created: {current_user.username} - {campaign_data.campaign_name}\")\n    \n    return EmailCampaignResponse(\n        id=str(campaign.id)",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(EmailLog.created_at <= date_to_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.subject_template=template.subject_template",
        "import:fastapi.\"bounced\": len([log for log in campaign_logs if log.status == \"bounced\"])\n            })\n    \n    return EmailAnalyticsResponse(\n        total_emails_sent=total_sent",
        "import:fastapi.emails_clicked=emails_clicked",
        "import:fastapi.frequency=alert.frequency",
        "import:fastapi.ge=1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get comprehensive email analytics.\n    \n    This provides insights into email performance and engagement.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailLog)\n    \n    # Apply date filters\n    if date_from:\n        try:\n            date_from_obj = datetime.strptime(date_from",
        "import:fastapi.click_rate=round(click_rate",
        "import:fastapi.sent_at=datetime.utcnow()\n        )\n        \n        db.add(email_log)\n        db.commit()\n        \n        logger.info(f\"Email notification sent: {user.email} - {notification_data.content.title}\")\n        \n        return EmailNotificationResponse(\n            success=True",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date_to:\n        try:\n            date_to_obj = datetime.strptime(date_to",
        "import:fastapi.EmailTemplate.is_active == True\n            )\n        ).first()\n    \n    try:\n        # In a real implementation",
        "import:fastapi.description=\"Filter by campaign type\")",
        "import:fastapi.EmailTemplate.is_active == True\n        )\n    ).first()\n    \n    if not template:\n        # Use default template\n        template = db.query(EmailTemplate).filter(\n            and_(\n                EmailTemplate.template_name == \"default\"",
        "import:fastapi.created_at=template.created_at",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.le=100",
        "import:fastapi.EmailTemplate",
        "import:fastapi.EmailAlert.user_id == current_user.id\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=404",
        "import:fastapi.sent_at=datetime.utcnow()\n        )\n\n\n# ============================================================================\n# UNSUBSCRIBE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/unsubscribe/generate\")\nasync def generate_unsubscribe_token(\n    alert_type: Optional[str] = Body(None",
        "import:fastapi.EmailTemplateCreateRequest",
        "import:fastapi.EmailNotificationResponse",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.completed_at=campaign.completed_at\n    )\n\n\n@router.get(\"/campaigns\"",
        "import:fastapi.field",
        "import:fastapi.EmailAlert.alert_type == notification_data.alert_type",
        "import:fastapi.EmailAlertListResponse",
        "import:fastapi.user_id=str(alert.user_id)",
        "import:fastapi.description=\"Template ID\")",
        "import:fastapi.NotificationContent\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# EMAIL ALERTS\n# ============================================================================\n\n@router.post(\"/alerts\"",
        "import:fastapi.HTTPException",
        "import:fastapi.total_recipients=campaign.total_recipients",
        "import:fastapi.response_model=EmailAlertStatsResponse)\nasync def get_user_alert_stats(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.updated_at=template.updated_at\n        ))\n    \n    return EmailTemplateListResponse(\n        templates=template_responses",
        "import:fastapi.error_message=str(e)\n        )\n        \n        db.add(email_log)\n        db.commit()\n        \n        return EmailNotificationResponse(\n            success=False",
        "import:fastapi.response_model=EmailCampaignResponse)\nasync def create_email_campaign(\n    campaign_data: EmailCampaignCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update an email alert.\n    \n    Users can only update their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.campaign_performance=campaign_performance",
        "import:fastapi.EmailTemplateUpdateRequest",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    db.delete(alert)\n    db.commit()\n    \n    logger.info(f\"Email alert deleted: {current_user.username} - {alert.alert_type}\")\n    \n    return {\"message\": \"Email alert deleted successfully\"}\n\n\n# ============================================================================\n# EMAIL TEMPLATES\n# ============================================================================\n\n@router.get(\"/templates\"",
        "import:fastapi.detail=\"User does not have active alerts for this type\")\n    \n    # Get appropriate template\n    template = db.query(EmailTemplate).filter(\n        and_(\n            EmailTemplate.template_type == notification_data.alert_type",
        "import:fastapi.\"clicked\"]])",
        "import:fastapi.target_audience=campaign_data.target_audience",
        "import:fastapi.EmailTemplate.is_active == True\n        )\n    ).first()\n    \n    if not template:\n        raise HTTPException(status_code=404",
        "import:fastapi.EmailCampaignCreateRequest",
        "import:fastapi.we'll just log it and create a log entry\n        \n        # Create email log entry\n        email_log = EmailLog(\n            user_id=notification_data.user_id",
        "import:fastapi.include_links=alert.include_links",
        "import:fastapi.response_model=EmailAlertListResponse)\nasync def list_user_alerts(\n    page: int = Query(1",
        "import:fastapi.alert_data: EmailAlertUpdateRequest = Body(...)",
        "import:fastapi.field):\n            setattr(alert",
        "import:fastapi.EmailAnalyticsResponse",
        "import:fastapi.total_alerts=total_alerts",
        "import:fastapi.response_model=EmailCampaignListResponse)\nasync def list_email_campaigns(\n    page: int = Query(1",
        "import:fastapi.opened_count=campaign.opened_count",
        "import:fastapi.\"unsubscribe_url\": unsubscribe_url",
        "import:fastapi.EmailTemplateResponse",
        "import:fastapi.error_message=str(e)",
        "import:fastapi.description=\"Filter by template type\")",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.this would send the actual email\n        # For now",
        "import:fastapi.include_summary=alert_data.include_summary",
        "import:fastapi.created_at=alert.created_at",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.is_active=template.is_active",
        "import:fastapi.html_content=campaign_data.html_content",
        "import:fastapi.this would send an email with the unsubscribe link\n    unsubscribe_url = f\"https://openpolicy.ca/unsubscribe?token={token}\"\n    \n    logger.info(f\"Unsubscribe token generated: {current_user.email} - {token}\")\n    \n    return {\n        \"message\": \"Unsubscribe token generated successfully\"",
        "import:fastapi.total_emails_bounced=total_bounced",
        "import:fastapi.generated_at=datetime.utcnow()\n    )\n\n\n@router.get(\"/alerts/stats\"",
        "import:fastapi.open_rate=round(open_rate",
        "import:fastapi.message_id=str(email_log.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Delete an email alert.\n    \n    Users can only delete their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.email_type=\"alert\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email campaigns.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailCampaign)\n    \n    # Apply filters\n    if campaign_type:\n        query = query.filter(EmailCampaign.campaign_type == campaign_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailCampaign.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get campaigns\n    campaigns = query.order_by(EmailCampaign.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    campaign_responses = []\n    for campaign in campaigns:\n        campaign_responses.append(EmailCampaignResponse(\n            id=str(campaign.id)",
        "import:fastapi.\"expires_at\": unsubscribe_token.expires_at.isoformat()\n    }",
        "import:fastapi.html_template=template.html_template",
        "import:fastapi.engagement_rate=round(engagement_rate",
        "import:fastapi.Depends",
        "import:fastapi.EmailAlertCreateRequest",
        "import:fastapi.Path",
        "import:fastapi.scheduled_at=campaign.scheduled_at",
        "import:fastapi.EmailAlertStatsResponse",
        "import:fastapi.opens_by_day=opens_by_day",
        "import:fastapi.EmailCampaignUpdateRequest",
        "import:fastapi.alert_type: Optional[str] = Query(None",
        "import:fastapi.total_emails_opened=total_opened",
        "import:fastapi.subject=campaign_data.subject",
        "import:fastapi.total_emails_received=total_emails_received",
        "import:fastapi.scheduled_at=campaign_data.scheduled_at",
        "import:fastapi.EmailCampaign",
        "import:fastapi.page=page",
        "import:fastapi.\"opened\"",
        "import:fastapi.\"clicked\"])).count()\n    total_delivered = query.filter(EmailLog.status.in_([\"delivered\"",
        "import:fastapi.response_model=EmailNotificationResponse)\nasync def send_email_notification(\n    notification_data: EmailNotificationRequest = Body(...)",
        "import:fastapi.email=current_user.email",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def create_email_alert(\n    alert_data: EmailAlertCreateRequest = Body(...)",
        "import:fastapi.created_at=campaign.created_at",
        "import:fastapi.\"%Y-%m-%d\")\n            query = query.filter(EmailLog.created_at >= date_from_obj)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"campaign_name\": campaign.campaign_name",
        "import:fastapi.updated_at=campaign.updated_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Generate an unsubscribe token for the current user.\n    \"\"\"\n    # Generate unique token\n    token = secrets.token_urlsafe(32)\n    \n    # Create unsubscribe token\n    unsubscribe_token = UnsubscribeToken(\n        user_id=current_user.id",
        "import:fastapi.token=token",
        "import:fastapi.template_name=template.template_name",
        "import:fastapi.delivery_rate=round(delivery_rate",
        "import:fastapi.filters=alert.filters",
        "import:fastapi.response_model=EmailTemplateResponse)\nasync def get_email_template(\n    template_id: str = Path(...",
        "import:fastapi.EmailAlert.is_active == True\n        )\n    ).first()\n    \n    if not alert:\n        raise HTTPException(status_code=400",
        "import:fastapi.clicks_by_day=clicks_by_day",
        "import:fastapi.clicked_count=campaign.clicked_count",
        "import:fastapi.EmailAlertUpdateRequest",
        "import:fastapi.include_summary=alert.include_summary",
        "import:fastapi.last_sent=alert.last_sent\n        ))\n    \n    return EmailAlertListResponse(\n        alerts=alert_responses",
        "import:fastapi.EmailAlert.alert_type == alert_data.alert_type\n        )\n    ).first()\n    \n    if existing_alert:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.delivered_count=campaign.delivered_count",
        "import:fastapi.\"delivered\"",
        "import:fastapi.status=\"failed\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List email templates.\n    \n    Only active templates are returned.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailTemplate).filter(EmailTemplate.is_active == True)\n    \n    # Apply filters\n    if template_type:\n        query = query.filter(EmailTemplate.template_type == template_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailTemplate.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get templates\n    templates = query.order_by(EmailTemplate.template_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    template_responses = []\n    for template in templates:\n        template_responses.append(EmailTemplateResponse(\n            id=str(template.id)",
        "import:fastapi.last_alert_sent=last_alert_sent",
        "import:fastapi.is_active=campaign.is_active",
        "import:fastapi.expires_at=datetime.utcnow() + timedelta(days=30)  # 30 day expiration\n    )\n    \n    db.add(unsubscribe_token)\n    db.commit()\n    \n    # In a real implementation",
        "import:fastapi.total_emails_failed=total_failed",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    List all email alerts for the current user.\n    \"\"\"\n    # Build base query\n    query = db.query(EmailAlert).filter(EmailAlert.user_id == current_user.id)\n    \n    # Apply filters\n    if alert_type:\n        query = query.filter(EmailAlert.alert_type == alert_type)\n    \n    if is_active is not None:\n        query = query.filter(EmailAlert.is_active == is_active)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get alerts\n    alerts = query.order_by(EmailAlert.created_at.desc()).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    alert_responses = []\n    for alert in alerts:\n        alert_responses.append(EmailAlertResponse(\n            id=str(alert.id)",
        "import:fastapi.UnsubscribeToken\nfrom app.models.users import User\nfrom app.schemas.email_alerts import (\n    EmailAlertResponse",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Send an email notification.\n    \n    This endpoint is used to trigger immediate email notifications.\n    \"\"\"\n    # Get user\n    user = db.query(User).filter(User.id == notification_data.user_id).first()\n    if not user:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_active=alert.is_active",
        "import:fastapi.response_model=EmailTemplateListResponse)\nasync def list_email_templates(\n    page: int = Query(1",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.put(\"/alerts/{alert_id}\"",
        "import:fastapi.updated_at=alert.updated_at",
        "import:fastapi.filters=alert_data.filters\n    )\n    \n    db.add(alert)\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert created: {current_user.username} - {alert_data.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.target_audience=campaign.target_audience",
        "import:fastapi.timedelta\nimport math\nimport secrets\n\nfrom app.database import get_db\nfrom app.models.email_alerts import EmailAlert",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/alerts/{alert_id}\"",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.get(\"/alerts\"",
        "import:fastapi.started_at=campaign.started_at",
        "import:fastapi.campaign_type=campaign_data.campaign_type",
        "import:fastapi.0) + 1\n    \n    # Get last alert sent\n    last_alert_sent = None\n    if user_alerts:\n        last_alert_sent = max([alert.last_sent for alert in user_alerts if alert.last_sent])\n    \n    # Calculate email engagement\n    total_emails_received = len(user_logs)\n    emails_opened = len([log for log in user_logs if log.status == \"opened\"])\n    emails_clicked = len([log for log in user_logs if log.status == \"clicked\"])\n    engagement_rate = (emails_opened / total_emails_received * 100) if total_emails_received > 0 else 0\n    \n    return EmailAlertStatsResponse(\n        user_id=str(current_user.id)",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get email counts by status\n    total_sent = query.filter(EmailLog.status.in_([\"sent\"",
        "import:fastapi.Query",
        "import:fastapi.value)\n    \n    alert.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(alert)\n    \n    logger.info(f\"Email alert updated: {current_user.username} - {alert.alert_type}\")\n    \n    return EmailAlertResponse(\n        id=str(alert.id)",
        "import:fastapi.\"delivered\": len([log for log in campaign_logs if log.status in [\"delivered\"",
        "import:fastapi.sent_at=email_log.sent_at\n        )\n        \n    except Exception as e:\n        logger.error(f\"Failed to send email notification: {str(e)}\")\n        \n        # Create failed log entry\n        email_log = EmailLog(\n            user_id=notification_data.user_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email campaign.\n    \n    This is typically used by administrators for bulk communications.\n    \"\"\"\n    # Create new campaign\n    campaign = EmailCampaign(\n        campaign_name=campaign_data.campaign_name",
        "import:fastapi.total=total",
        "import:fastapi.subject=f\"OpenPolicy Update: {notification_data.content.title}\"",
        "import:fastapi.description=\"Filter by alert type\")",
        "import:fastapi.recipient_email=user.email",
        "import:fastapi.campaign_type=campaign.campaign_type",
        "import:fastapi.sent_count=campaign.sent_count",
        "import:fastapi.\"clicked\"])).count()\n    total_opened = query.filter(EmailLog.status == \"opened\").count()\n    total_clicked = query.filter(EmailLog.status == \"clicked\").count()\n    total_bounced = query.filter(EmailLog.status == \"bounced\").count()\n    total_failed = query.filter(EmailLog.status == \"failed\").count()\n    \n    # Calculate rates\n    delivery_rate = (total_delivered / total_sent * 100) if total_sent > 0 else 0\n    open_rate = (total_opened / total_delivered * 100) if total_delivered > 0 else 0\n    click_rate = (total_clicked / total_delivered * 100) if total_delivered > 0 else 0\n    bounce_rate = (total_bounced / total_sent * 100) if total_sent > 0 else 0\n    \n    # Get time-based analytics (last 30 days if no date range specified)\n    if not date_from and not date_to:\n        date_from_obj = datetime.utcnow() - timedelta(days=30)\n        date_to_obj = datetime.utcnow()\n    else:\n        date_from_obj = date_from_obj if date_from else datetime.utcnow() - timedelta(days=30)\n        date_to_obj = date_to_obj if date_to else datetime.utcnow()\n    \n    # Get emails by day\n    emails_by_day = {}\n    opens_by_day = {}\n    clicks_by_day = {}\n    \n    current_date = date_from_obj\n    while current_date <= date_to_obj:\n        date_str = current_date.strftime(\"%Y-%m-%d\")\n        emails_by_day[date_str] = 0\n        opens_by_day[date_str] = 0\n        clicks_by_day[date_str] = 0\n        current_date += timedelta(days=1)\n    \n    # Get campaign performance\n    campaign_performance = []\n    campaigns = db.query(EmailCampaign).filter(EmailCampaign.is_active == True).all()\n    \n    for campaign in campaigns:\n        campaign_logs = query.filter(EmailCampaign.id == campaign.id).all()\n        if campaign_logs:\n            campaign_performance.append({\n                \"campaign_id\": str(campaign.id)",
        "import:fastapi.alerts_by_frequency=alerts_by_frequency",
        "function:generate_unsubscribe_token",
        "import:fastapi.bounce_rate=round(bounce_rate",
        "import:fastapi.last_sent=alert.last_sent\n    )\n\n\n@router.delete(\"/alerts/{alert_id}\")\nasync def delete_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.2)",
        "import:fastapi.generated_at=datetime.utcnow()\n    )\n\n\n# ============================================================================\n# EMAIL NOTIFICATIONS\n# ============================================================================\n\n@router.post(\"/notifications/send\"",
        "import:fastapi.alert_type=alert_type",
        "import:fastapi.updated_at=template.updated_at\n    )\n\n\n# ============================================================================\n# EMAIL CAMPAIGNS\n# ============================================================================\n\n@router.post(\"/campaigns\"",
        "import:fastapi.total_emails_clicked=total_clicked",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.include_analytics=alert.include_analytics",
        "import:fastapi.0) + 1\n        alerts_by_frequency[alert.frequency] = alerts_by_frequency.get(alert.frequency",
        "import:fastapi.value in update_data.items():\n        if hasattr(alert",
        "import:fastapi.\"clicked\": len([log for log in campaign_logs if log.status == \"clicked\"])",
        "import:fastapi.variables=template.variables",
        "import:fastapi.EmailCampaignResponse",
        "import:fastapi.status=\"sent\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get a specific email alert by ID.\n    \n    Users can only view their own alerts.\n    \"\"\"\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.id == alert_id",
        "import:fastapi.detail=\"Email alert not found\")\n    \n    # Update alert fields\n    update_data = alert_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# EMAIL ANALYTICS\n# ============================================================================\n\n@router.get(\"/analytics\"",
        "import:fastapi.subject=campaign.subject",
        "import:fastapi.emails_by_day=emails_by_day",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.text_content=campaign_data.text_content",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get email alert statistics for the current user.\n    \"\"\"\n    # Get user's alerts\n    user_alerts = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.completed_at=campaign.completed_at\n        ))\n    \n    return EmailCampaignListResponse(\n        campaigns=campaign_responses",
        "import:fastapi.alerts_by_type=alerts_by_type",
        "import:fastapi.total_emails_delivered=total_delivered",
        "import:fastapi.detail=\"Email template not found\")\n    \n    return EmailTemplateResponse(\n        id=str(template.id)",
        "import:fastapi.campaign_type: Optional[str] = Query(None",
        "import:fastapi.template_type=template.template_type",
        "import:fastapi.detail=\"User not found\")\n    \n    # Get user's email alert preferences\n    alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == notification_data.user_id",
        "import:fastapi.template_type: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.detail=f\"User already has an active {alert_data.alert_type} alert\"\n        )\n    \n    # Create new alert\n    alert = EmailAlert(\n        user_id=current_user.id",
        "import:fastapi.is_active=alert_data.is_active",
        "import:fastapi.include_links=alert_data.include_links",
        "import:fastapi.alert_type=alert_data.alert_type",
        "import:fastapi.text_content=campaign.text_content",
        "import:fastapi.EmailNotificationRequest",
        "import:fastapi.include_analytics=alert_data.include_analytics",
        "import:fastapi.EmailAlert.is_active == True\n        )\n    ).all()\n    \n    # Get user's email logs\n    user_logs = db.query(EmailLog).filter(EmailLog.user_id == current_user.id).all()\n    \n    # Calculate statistics\n    total_alerts = len(user_alerts)\n    alerts_by_type = {}\n    alerts_by_frequency = {}\n    \n    for alert in user_alerts:\n        alerts_by_type[alert.alert_type] = alerts_by_type.get(alert.alert_type",
        "import:fastapi.response_model=EmailAlertResponse)\nasync def update_email_alert(\n    alert_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new email alert subscription.\n    \n    Users can subscribe to various types of parliamentary updates.\n    \"\"\"\n    # Check if user already has this alert type\n    existing_alert = db.query(EmailAlert).filter(\n        and_(\n            EmailAlert.user_id == current_user.id",
        "import:fastapi.APIRouter",
        "import:fastapi.EmailTemplateListResponse",
        "import:fastapi.frequency=alert_data.frequency",
        "import:fastapi.campaign_name=campaign.campaign_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific email template by ID.\n    \"\"\"\n    template = db.query(EmailTemplate).filter(\n        and_(\n            EmailTemplate.id == template_id",
        "import:fastapi.EmailCampaignListResponse"
      ]
    },
    "POST:/manifests": {
      "method": "POST",
      "path": "/manifests",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 42,
      "dependencies": [
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.PWAInstallation",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.ServiceWorker",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================",
        "import:fastapi.OfflineResource",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Path",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.PWAStatistics",
        "import:fastapi.or_",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/manifests": {
      "method": "GET",
      "path": "/manifests",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 105,
      "dependencies": [
        "import:fastapi.dir=manifest.dir",
        "import:fastapi.orientation=manifest.orientation",
        "import:fastapi.lang=manifest.lang",
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.is_active=manifest.is_active",
        "import:fastapi.is_default=manifest.is_default",
        "import:fastapi.created_at=manifest.created_at",
        "import:fastapi.categories=manifest.categories",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def create_pwa_manifest(\n    manifest_data: PWAManifestCreateRequest = Body(...)",
        "import:fastapi.theme_color=manifest.theme_color",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.description=manifest.description",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.PWAInstallation",
        "import:fastapi.app_name=manifest.app_name",
        "import:fastapi.ServiceWorker",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.updated_at=manifest.updated_at\n    )",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests\"",
        "import:fastapi.display_mode=manifest.display_mode",
        "import:fastapi.scope=manifest.scope",
        "import:fastapi.OfflineResource",
        "import:fastapi.screenshots=manifest.screenshots",
        "import:fastapi.background_color=manifest.background_color",
        "import:fastapi.short_name=manifest.short_name",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.related_applications=manifest.related_applications",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.prefer_related_applications=manifest.prefer_related_applications",
        "import:fastapi.Path",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.PWAStatistics",
        "import:fastapi.or_",
        "import:fastapi.icons=manifest.icons",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.created_by=manifest.created_by",
        "import:fastapi.unset other defaults\n    if manifest_data.is_default:\n        db.query(PWAManifest).filter(PWAManifest.is_default).update({\"is_default\": False})\n    \n    # Create new manifest\n    manifest = PWAManifest(**manifest_data.dict())\n    manifest.created_by = current_user.username\n    db.add(manifest)\n    db.commit()\n    db.refresh(manifest)\n    \n    logger.info(f\"PWA manifest created: {current_user.username} - {manifest_data.manifest_name}\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "function:create_pwa_manifest",
        "import:fastapi.detail=f\"PWA manifest with name '{manifest_data.manifest_name}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.start_url=manifest.start_url",
        "import:fastapi.shortcuts=manifest.shortcuts",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new PWA manifest.\n    \n    This creates a new PWA manifest configuration for the system.\n    \"\"\"\n    # Check if manifest name already exists\n    existing_manifest = db.query(PWAManifest).filter(\n        PWAManifest.manifest_name == manifest_data.manifest_name\n    ).first()\n    \n    if existing_manifest:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.manifest_name=manifest.manifest_name",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/manifests/{manifest_id}": {
      "method": "GET",
      "path": "/manifests/{manifest_id}",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 193,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.response_model=PWAManifestListResponse)\nasync def list_pwa_manifests(\n    page: int = Query(1",
        "import:fastapi.display_mode=manifest.display_mode",
        "import:fastapi.ge=1",
        "import:fastapi.screenshots=manifest.screenshots",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.related_applications=manifest.related_applications",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.icons=manifest.icons",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.PWAManifest.app_name.ilike(search_term)",
        "import:fastapi.unset other defaults\n    if manifest_data.is_default:\n        db.query(PWAManifest).filter(PWAManifest.is_default).update({\"is_default\": False})\n    \n    # Create new manifest\n    manifest = PWAManifest(**manifest_data.dict())\n    manifest.created_by = current_user.username\n    db.add(manifest)\n    db.commit()\n    db.refresh(manifest)\n    \n    logger.info(f\"PWA manifest created: {current_user.username} - {manifest_data.manifest_name}\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.start_url=manifest.start_url",
        "import:fastapi.PWAManifest.short_name.ilike(search_term)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.shortcuts=manifest.shortcuts",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.HTTPException",
        "function:list_pwa_manifests",
        "import:fastapi.orientation=manifest.orientation",
        "import:fastapi.is_default=manifest.is_default",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.description=manifest.description",
        "import:fastapi.ServiceWorker",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests\"",
        "import:fastapi.scope=manifest.scope",
        "import:fastapi.background_color=manifest.background_color",
        "import:fastapi.short_name=manifest.short_name",
        "import:fastapi.Depends",
        "import:fastapi.prefer_related_applications=manifest.prefer_related_applications",
        "import:fastapi.Path",
        "import:fastapi.PWAStatistics",
        "import:fastapi.page=page",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.PWAManifest.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get manifests\n    manifests = query.order_by(PWAManifest.manifest_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    manifest_responses = []\n    for manifest in manifests:\n        manifest_responses.append(PWAManifestResponse(\n            id=str(manifest.id)",
        "import:fastapi.dir=manifest.dir",
        "import:fastapi.created_at=manifest.created_at",
        "import:fastapi.categories=manifest.categories",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def create_pwa_manifest(\n    manifest_data: PWAManifestCreateRequest = Body(...)",
        "import:fastapi.theme_color=manifest.theme_color",
        "import:fastapi.PWAInstallation",
        "import:fastapi.description=\"Filter by display mode\")",
        "import:fastapi.OfflineResource",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.detail=f\"PWA manifest with name '{manifest_data.manifest_name}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.lang=manifest.lang",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.is_active=manifest.is_active",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.description=\"Search in manifest names and descriptions\")",
        "import:fastapi.app_name=manifest.app_name",
        "import:fastapi.display_mode: Optional[DisplayModeEnum] = Query(None",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List PWA manifests with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PWAManifest)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(PWAManifest.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(PWAManifest.is_default == is_default)\n    \n    if display_mode:\n        query = query.filter(PWAManifest.display_mode == display_mode)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                PWAManifest.manifest_name.ilike(search_term)",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_by=manifest.created_by",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new PWA manifest.\n    \n    This creates a new PWA manifest configuration for the system.\n    \"\"\"\n    # Check if manifest name already exists\n    existing_manifest = db.query(PWAManifest).filter(\n        PWAManifest.manifest_name == manifest_data.manifest_name\n    ).first()\n    \n    if existing_manifest:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.manifest_name=manifest.manifest_name",
        "import:fastapi.APIRouter",
        "import:fastapi.updated_at=manifest.updated_at\n        ))\n    \n    return PWAManifestListResponse(\n        manifests=manifest_responses"
      ]
    },
    "GET:/manifests/{manifest_id}/manifest.json": {
      "method": "GET",
      "path": "/manifests/{manifest_id}/manifest.json",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 234,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.response_model=PWAManifestListResponse)\nasync def list_pwa_manifests(\n    page: int = Query(1",
        "import:fastapi.display_mode=manifest.display_mode",
        "import:fastapi.ge=1",
        "import:fastapi.screenshots=manifest.screenshots",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.related_applications=manifest.related_applications",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.icons=manifest.icons",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.PWAManifest.app_name.ilike(search_term)",
        "import:fastapi.unset other defaults\n    if manifest_data.is_default:\n        db.query(PWAManifest).filter(PWAManifest.is_default).update({\"is_default\": False})\n    \n    # Create new manifest\n    manifest = PWAManifest(**manifest_data.dict())\n    manifest.created_by = current_user.username\n    db.add(manifest)\n    db.commit()\n    db.refresh(manifest)\n    \n    logger.info(f\"PWA manifest created: {current_user.username} - {manifest_data.manifest_name}\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.start_url=manifest.start_url",
        "import:fastapi.PWAManifest.short_name.ilike(search_term)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.shortcuts=manifest.shortcuts",
        "import:fastapi.HTTPException",
        "import:fastapi.orientation=manifest.orientation",
        "import:fastapi.is_default=manifest.is_default",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.description=manifest.description",
        "import:fastapi.ServiceWorker",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.updated_at=manifest.updated_at\n    )",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests\"",
        "import:fastapi.scope=manifest.scope",
        "import:fastapi.description=\"PWA manifest ID\")",
        "import:fastapi.background_color=manifest.background_color",
        "import:fastapi.short_name=manifest.short_name",
        "import:fastapi.Depends",
        "import:fastapi.prefer_related_applications=manifest.prefer_related_applications",
        "import:fastapi.Path",
        "import:fastapi.PWAStatistics",
        "import:fastapi.page=page",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.PWAManifest.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get manifests\n    manifests = query.order_by(PWAManifest.manifest_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    manifest_responses = []\n    for manifest in manifests:\n        manifest_responses.append(PWAManifestResponse(\n            id=str(manifest.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific PWA manifest by ID.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.dir=manifest.dir",
        "import:fastapi.created_at=manifest.created_at",
        "import:fastapi.categories=manifest.categories",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def create_pwa_manifest(\n    manifest_data: PWAManifestCreateRequest = Body(...)",
        "import:fastapi.theme_color=manifest.theme_color",
        "import:fastapi.PWAInstallation",
        "import:fastapi.description=\"Filter by display mode\")",
        "import:fastapi.OfflineResource",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "function:get_pwa_manifest",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def get_pwa_manifest(\n    manifest_id: str = Path(...",
        "import:fastapi.detail=f\"PWA manifest with name '{manifest_data.manifest_name}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.lang=manifest.lang",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.is_active=manifest.is_active",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.description=\"Search in manifest names and descriptions\")",
        "import:fastapi.app_name=manifest.app_name",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/manifests/{manifest_id}\"",
        "import:fastapi.display_mode: Optional[DisplayModeEnum] = Query(None",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List PWA manifests with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PWAManifest)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(PWAManifest.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(PWAManifest.is_default == is_default)\n    \n    if display_mode:\n        query = query.filter(PWAManifest.display_mode == display_mode)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                PWAManifest.manifest_name.ilike(search_term)",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_by=manifest.created_by",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new PWA manifest.\n    \n    This creates a new PWA manifest configuration for the system.\n    \"\"\"\n    # Check if manifest name already exists\n    existing_manifest = db.query(PWAManifest).filter(\n        PWAManifest.manifest_name == manifest_data.manifest_name\n    ).first()\n    \n    if existing_manifest:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.manifest_name=manifest.manifest_name",
        "import:fastapi.APIRouter",
        "import:fastapi.updated_at=manifest.updated_at\n        ))\n    \n    return PWAManifestListResponse(\n        manifests=manifest_responses"
      ]
    },
    "POST:/manifests/{manifest_id}/service-workers": {
      "method": "POST",
      "path": "/manifests/{manifest_id}/service-workers",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 275,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.\"description\": manifest.description",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.\"orientation\": manifest.orientation",
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get PWA manifest as JSON for browser consumption.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.response_model=PWAManifestListResponse)\nasync def list_pwa_manifests(\n    page: int = Query(1",
        "import:fastapi.display_mode=manifest.display_mode",
        "import:fastapi.ge=1",
        "import:fastapi.screenshots=manifest.screenshots",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.related_applications=manifest.related_applications",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.icons=manifest.icons",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.PWAManifest.app_name.ilike(search_term)",
        "import:fastapi.unset other defaults\n    if manifest_data.is_default:\n        db.query(PWAManifest).filter(PWAManifest.is_default).update({\"is_default\": False})\n    \n    # Create new manifest\n    manifest = PWAManifest(**manifest_data.dict())\n    manifest.created_by = current_user.username\n    db.add(manifest)\n    db.commit()\n    db.refresh(manifest)\n    \n    logger.info(f\"PWA manifest created: {current_user.username} - {manifest_data.manifest_name}\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.start_url=manifest.start_url",
        "import:fastapi.PWAManifest.short_name.ilike(search_term)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.\"scope\": manifest.scope",
        "import:fastapi.\"screenshots\": manifest.screenshots",
        "import:fastapi.shortcuts=manifest.shortcuts",
        "import:fastapi.HTTPException",
        "import:fastapi.\"dir\": manifest.dir",
        "import:fastapi.orientation=manifest.orientation",
        "import:fastapi.is_default=manifest.is_default",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.description=manifest.description",
        "import:fastapi.ServiceWorker",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests\"",
        "import:fastapi.scope=manifest.scope",
        "import:fastapi.description=\"PWA manifest ID\")",
        "import:fastapi.background_color=manifest.background_color",
        "import:fastapi.\"display\": manifest.display_mode",
        "import:fastapi.short_name=manifest.short_name",
        "import:fastapi.Depends",
        "import:fastapi.prefer_related_applications=manifest.prefer_related_applications",
        "import:fastapi.Path",
        "import:fastapi.PWAStatistics",
        "import:fastapi.page=page",
        "import:fastapi.\"prefer_related_applications\": manifest.prefer_related_applications\n    }\n    \n    return JSONResponse(content=manifest_json",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.\"shortcuts\": manifest.shortcuts",
        "import:fastapi.PWAManifest.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get manifests\n    manifests = query.order_by(PWAManifest.manifest_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    manifest_responses = []\n    for manifest in manifests:\n        manifest_responses.append(PWAManifestResponse(\n            id=str(manifest.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific PWA manifest by ID.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.dir=manifest.dir",
        "import:fastapi.created_at=manifest.created_at",
        "import:fastapi.categories=manifest.categories",
        "import:fastapi.\"lang\": manifest.lang",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def create_pwa_manifest(\n    manifest_data: PWAManifestCreateRequest = Body(...)",
        "import:fastapi.theme_color=manifest.theme_color",
        "import:fastapi.\"categories\": manifest.categories",
        "import:fastapi.PWAInstallation",
        "import:fastapi.description=\"Filter by display mode\")",
        "import:fastapi.OfflineResource",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def get_pwa_manifest(\n    manifest_id: str = Path(...",
        "import:fastapi.detail=f\"PWA manifest with name '{manifest_data.manifest_name}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.\"theme_color\": manifest.theme_color",
        "import:fastapi.\"icons\": manifest.icons",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/manifest.json\")\nasync def get_pwa_manifest_json(\n    manifest_id: str = Path(...",
        "import:fastapi.\"short_name\": manifest.short_name",
        "import:fastapi.lang=manifest.lang",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.is_active=manifest.is_active",
        "import:fastapi.\"related_applications\": manifest.related_applications",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.description=\"Search in manifest names and descriptions\")",
        "function:get_pwa_manifest_json",
        "import:fastapi.app_name=manifest.app_name",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/manifests/{manifest_id}\"",
        "import:fastapi.display_mode: Optional[DisplayModeEnum] = Query(None",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List PWA manifests with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PWAManifest)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(PWAManifest.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(PWAManifest.is_default == is_default)\n    \n    if display_mode:\n        query = query.filter(PWAManifest.display_mode == display_mode)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                PWAManifest.manifest_name.ilike(search_term)",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.\"start_url\": manifest.start_url",
        "import:fastapi.\"background_color\": manifest.background_color",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Convert to standard PWA manifest format\n    manifest_json = {\n        \"name\": manifest.app_name",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_by=manifest.created_by",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new PWA manifest.\n    \n    This creates a new PWA manifest configuration for the system.\n    \"\"\"\n    # Check if manifest name already exists\n    existing_manifest = db.query(PWAManifest).filter(\n        PWAManifest.manifest_name == manifest_data.manifest_name\n    ).first()\n    \n    if existing_manifest:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.manifest_name=manifest.manifest_name",
        "import:fastapi.APIRouter",
        "import:fastapi.updated_at=manifest.updated_at\n        ))\n    \n    return PWAManifestListResponse(\n        manifests=manifest_responses",
        "import:fastapi.media_type=\"application/manifest+json\")\n\n\n# ============================================================================\n# SERVICE WORKER MANAGEMENT\n# ============================================================================"
      ]
    },
    "GET:/manifests/{manifest_id}/service-workers": {
      "method": "GET",
      "path": "/manifests/{manifest_id}/service-workers",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 343,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.\"description\": manifest.description",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.worker_url=worker.worker_url",
        "import:fastapi.\"orientation\": manifest.orientation",
        "import:fastapi.worker_scope=worker.worker_scope",
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.is_default=worker.is_default",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get PWA manifest as JSON for browser consumption.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.response_model=PWAManifestListResponse)\nasync def list_pwa_manifests(\n    page: int = Query(1",
        "import:fastapi.display_mode=manifest.display_mode",
        "import:fastapi.ge=1",
        "import:fastapi.screenshots=manifest.screenshots",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.related_applications=manifest.related_applications",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.icons=manifest.icons",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.PWAManifest.app_name.ilike(search_term)",
        "import:fastapi.unset other defaults\n    if manifest_data.is_default:\n        db.query(PWAManifest).filter(PWAManifest.is_default).update({\"is_default\": False})\n    \n    # Create new manifest\n    manifest = PWAManifest(**manifest_data.dict())\n    manifest.created_by = current_user.username\n    db.add(manifest)\n    db.commit()\n    db.refresh(manifest)\n    \n    logger.info(f\"PWA manifest created: {current_user.username} - {manifest_data.manifest_name}\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.start_url=manifest.start_url",
        "import:fastapi.PWAManifest.short_name.ilike(search_term)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.\"scope\": manifest.scope",
        "import:fastapi.\"screenshots\": manifest.screenshots",
        "import:fastapi.shortcuts=manifest.shortcuts",
        "import:fastapi.HTTPException",
        "import:fastapi.\"dir\": manifest.dir",
        "import:fastapi.orientation=manifest.orientation",
        "import:fastapi.is_default=manifest.is_default",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.unset other defaults for this manifest\n    if worker_data.is_default:\n        db.query(ServiceWorker).filter(\n            and_(\n                ServiceWorker.manifest_id == manifest_id",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.is_active=worker.is_active",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.description=manifest.description",
        "import:fastapi.created_at=worker.created_at",
        "import:fastapi.ServiceWorker",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests\"",
        "import:fastapi.scope=manifest.scope",
        "import:fastapi.description=\"PWA manifest ID\")",
        "function:create_service_worker",
        "import:fastapi.background_color=manifest.background_color",
        "import:fastapi.\"display\": manifest.display_mode",
        "import:fastapi.short_name=manifest.short_name",
        "import:fastapi.offline_fallback=worker.offline_fallback",
        "import:fastapi.worker_script=worker.worker_script",
        "import:fastapi.Depends",
        "import:fastapi.prefer_related_applications=manifest.prefer_related_applications",
        "import:fastapi.updated_at=worker.updated_at\n    )",
        "import:fastapi.Path",
        "import:fastapi.PWAStatistics",
        "import:fastapi.page=page",
        "import:fastapi.\"prefer_related_applications\": manifest.prefer_related_applications\n    }\n    \n    return JSONResponse(content=manifest_json",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.\"shortcuts\": manifest.shortcuts",
        "import:fastapi.PWAManifest.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get manifests\n    manifests = query.order_by(PWAManifest.manifest_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    manifest_responses = []\n    for manifest in manifests:\n        manifest_responses.append(PWAManifestResponse(\n            id=str(manifest.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new service worker for a PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific PWA manifest by ID.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.dir=manifest.dir",
        "import:fastapi.created_at=manifest.created_at",
        "import:fastapi.categories=manifest.categories",
        "import:fastapi.\"lang\": manifest.lang",
        "import:fastapi.worker_name=worker.worker_name",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def create_pwa_manifest(\n    manifest_data: PWAManifestCreateRequest = Body(...)",
        "import:fastapi.media_type=\"application/manifest+json\")\n\n\n# ============================================================================\n# SERVICE WORKER MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests/{manifest_id}/service-workers\"",
        "import:fastapi.detail=f\"Service worker with name '{worker_data.worker_name}' already exists for this manifest\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.theme_color=manifest.theme_color",
        "import:fastapi.\"categories\": manifest.categories",
        "import:fastapi.PWAInstallation",
        "import:fastapi.description=\"Filter by display mode\")",
        "import:fastapi.OfflineResource",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.response_model=ServiceWorkerResponse)\nasync def create_service_worker(\n    manifest_id: str = Path(...",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def get_pwa_manifest(\n    manifest_id: str = Path(...",
        "import:fastapi.detail=f\"PWA manifest with name '{manifest_data.manifest_name}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.\"theme_color\": manifest.theme_color",
        "import:fastapi.\"icons\": manifest.icons",
        "import:fastapi.created_by=worker.created_by",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/manifest.json\")\nasync def get_pwa_manifest_json(\n    manifest_id: str = Path(...",
        "import:fastapi.\"short_name\": manifest.short_name",
        "import:fastapi.worker_data: ServiceWorkerCreateRequest = Body(...)",
        "import:fastapi.lang=manifest.lang",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.is_active=manifest.is_active",
        "import:fastapi.ServiceWorker.worker_name == worker_data.worker_name\n        )\n    ).first()\n    \n    if existing_worker:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.cache_strategy=worker.cache_strategy",
        "import:fastapi.\"related_applications\": manifest.related_applications",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.description=\"Search in manifest names and descriptions\")",
        "import:fastapi.worker_version=worker.worker_version",
        "import:fastapi.push_enabled=worker.push_enabled",
        "import:fastapi.app_name=manifest.app_name",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/manifests/{manifest_id}\"",
        "import:fastapi.display_mode: Optional[DisplayModeEnum] = Query(None",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List PWA manifests with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PWAManifest)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(PWAManifest.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(PWAManifest.is_default == is_default)\n    \n    if display_mode:\n        query = query.filter(PWAManifest.display_mode == display_mode)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                PWAManifest.manifest_name.ilike(search_term)",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.\"start_url\": manifest.start_url",
        "import:fastapi.\"background_color\": manifest.background_color",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Convert to standard PWA manifest format\n    manifest_json = {\n        \"name\": manifest.app_name",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Check if worker name already exists for this manifest\n    existing_worker = db.query(ServiceWorker).filter(\n        and_(\n            ServiceWorker.manifest_id == manifest_id",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_by=manifest.created_by",
        "import:fastapi.ServiceWorker.is_default == True\n            )\n        ).update({\"is_default\": False})\n    \n    # Create new service worker\n    worker = ServiceWorker(**worker_data.dict())\n    worker.manifest_id = manifest_id\n    worker.created_by = current_user.username\n    db.add(worker)\n    db.commit()\n    db.refresh(worker)\n    \n    logger.info(f\"Service worker created: {current_user.username} - {worker_data.worker_name}\")\n    \n    return ServiceWorkerResponse(\n        id=str(worker.id)",
        "import:fastapi.manifest_id=str(worker.manifest_id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new PWA manifest.\n    \n    This creates a new PWA manifest configuration for the system.\n    \"\"\"\n    # Check if manifest name already exists\n    existing_manifest = db.query(PWAManifest).filter(\n        PWAManifest.manifest_name == manifest_data.manifest_name\n    ).first()\n    \n    if existing_manifest:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.manifest_name=manifest.manifest_name",
        "import:fastapi.APIRouter",
        "import:fastapi.background_sync_enabled=worker.background_sync_enabled",
        "import:fastapi.updated_at=manifest.updated_at\n        ))\n    \n    return PWAManifestListResponse(\n        manifests=manifest_responses"
      ]
    },
    "POST:/manifests/{manifest_id}/offline-resources": {
      "method": "POST",
      "path": "/manifests/{manifest_id}/offline-resources",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 421,
      "dependencies": [
        "function:list_service_workers",
        "import:fastapi.page_size=page_size",
        "import:fastapi.\"description\": manifest.description",
        "import:fastapi.updated_at=worker.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/service-workers\"",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# OFFLINE RESOURCE MANAGEMENT\n# ============================================================================",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.worker_url=worker.worker_url",
        "import:fastapi.\"orientation\": manifest.orientation",
        "import:fastapi.worker_scope=worker.worker_scope",
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.cache_strategy: Optional[CacheStrategyEnum] = Query(None",
        "import:fastapi.is_default=worker.is_default",
        "import:fastapi.response_model=ServiceWorkerListResponse)\nasync def list_service_workers(\n    manifest_id: str = Path(...",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get PWA manifest as JSON for browser consumption.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.response_model=PWAManifestListResponse)\nasync def list_pwa_manifests(\n    page: int = Query(1",
        "import:fastapi.display_mode=manifest.display_mode",
        "import:fastapi.ge=1",
        "import:fastapi.screenshots=manifest.screenshots",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.related_applications=manifest.related_applications",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.icons=manifest.icons",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.PWAManifest.app_name.ilike(search_term)",
        "import:fastapi.unset other defaults\n    if manifest_data.is_default:\n        db.query(PWAManifest).filter(PWAManifest.is_default).update({\"is_default\": False})\n    \n    # Create new manifest\n    manifest = PWAManifest(**manifest_data.dict())\n    manifest.created_by = current_user.username\n    db.add(manifest)\n    db.commit()\n    db.refresh(manifest)\n    \n    logger.info(f\"PWA manifest created: {current_user.username} - {manifest_data.manifest_name}\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.start_url=manifest.start_url",
        "import:fastapi.PWAManifest.short_name.ilike(search_term)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.\"scope\": manifest.scope",
        "import:fastapi.\"screenshots\": manifest.screenshots",
        "import:fastapi.shortcuts=manifest.shortcuts",
        "import:fastapi.HTTPException",
        "import:fastapi.\"dir\": manifest.dir",
        "import:fastapi.orientation=manifest.orientation",
        "import:fastapi.is_default=manifest.is_default",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.updated_at=worker.updated_at\n        ))\n    \n    return ServiceWorkerListResponse(\n        workers=worker_responses",
        "import:fastapi.unset other defaults for this manifest\n    if worker_data.is_default:\n        db.query(ServiceWorker).filter(\n            and_(\n                ServiceWorker.manifest_id == manifest_id",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.is_active=worker.is_active",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.description=manifest.description",
        "import:fastapi.created_at=worker.created_at",
        "import:fastapi.ServiceWorker",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests\"",
        "import:fastapi.scope=manifest.scope",
        "import:fastapi.description=\"PWA manifest ID\")",
        "import:fastapi.background_color=manifest.background_color",
        "import:fastapi.\"display\": manifest.display_mode",
        "import:fastapi.short_name=manifest.short_name",
        "import:fastapi.offline_fallback=worker.offline_fallback",
        "import:fastapi.worker_script=worker.worker_script",
        "import:fastapi.Depends",
        "import:fastapi.prefer_related_applications=manifest.prefer_related_applications",
        "import:fastapi.Path",
        "import:fastapi.PWAStatistics",
        "import:fastapi.page=page",
        "import:fastapi.\"prefer_related_applications\": manifest.prefer_related_applications\n    }\n    \n    return JSONResponse(content=manifest_json",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.\"shortcuts\": manifest.shortcuts",
        "import:fastapi.PWAManifest.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get manifests\n    manifests = query.order_by(PWAManifest.manifest_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    manifest_responses = []\n    for manifest in manifests:\n        manifest_responses.append(PWAManifestResponse(\n            id=str(manifest.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new service worker for a PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific PWA manifest by ID.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Build base query\n    query = db.query(ServiceWorker).filter(ServiceWorker.manifest_id == manifest_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(ServiceWorker.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(ServiceWorker.is_default == is_default)\n    \n    if cache_strategy:\n        query = query.filter(ServiceWorker.cache_strategy == cache_strategy)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get workers\n    workers = query.order_by(ServiceWorker.worker_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    worker_responses = []\n    for worker in workers:\n        worker_responses.append(ServiceWorkerResponse(\n            id=str(worker.id)",
        "import:fastapi.dir=manifest.dir",
        "import:fastapi.created_at=manifest.created_at",
        "import:fastapi.categories=manifest.categories",
        "import:fastapi.\"lang\": manifest.lang",
        "import:fastapi.worker_name=worker.worker_name",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def create_pwa_manifest(\n    manifest_data: PWAManifestCreateRequest = Body(...)",
        "import:fastapi.media_type=\"application/manifest+json\")\n\n\n# ============================================================================\n# SERVICE WORKER MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests/{manifest_id}/service-workers\"",
        "import:fastapi.detail=f\"Service worker with name '{worker_data.worker_name}' already exists for this manifest\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.theme_color=manifest.theme_color",
        "import:fastapi.\"categories\": manifest.categories",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List service workers for a specific PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.PWAInstallation",
        "import:fastapi.description=\"Filter by display mode\")",
        "import:fastapi.OfflineResource",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.response_model=ServiceWorkerResponse)\nasync def create_service_worker(\n    manifest_id: str = Path(...",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def get_pwa_manifest(\n    manifest_id: str = Path(...",
        "import:fastapi.detail=f\"PWA manifest with name '{manifest_data.manifest_name}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.\"theme_color\": manifest.theme_color",
        "import:fastapi.\"icons\": manifest.icons",
        "import:fastapi.created_by=worker.created_by",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/manifest.json\")\nasync def get_pwa_manifest_json(\n    manifest_id: str = Path(...",
        "import:fastapi.\"short_name\": manifest.short_name",
        "import:fastapi.worker_data: ServiceWorkerCreateRequest = Body(...)",
        "import:fastapi.lang=manifest.lang",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.is_active=manifest.is_active",
        "import:fastapi.ServiceWorker.worker_name == worker_data.worker_name\n        )\n    ).first()\n    \n    if existing_worker:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.cache_strategy=worker.cache_strategy",
        "import:fastapi.\"related_applications\": manifest.related_applications",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.description=\"Search in manifest names and descriptions\")",
        "import:fastapi.worker_version=worker.worker_version",
        "import:fastapi.push_enabled=worker.push_enabled",
        "import:fastapi.app_name=manifest.app_name",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/manifests/{manifest_id}\"",
        "import:fastapi.display_mode: Optional[DisplayModeEnum] = Query(None",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List PWA manifests with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PWAManifest)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(PWAManifest.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(PWAManifest.is_default == is_default)\n    \n    if display_mode:\n        query = query.filter(PWAManifest.display_mode == display_mode)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                PWAManifest.manifest_name.ilike(search_term)",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.\"start_url\": manifest.start_url",
        "import:fastapi.\"background_color\": manifest.background_color",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Convert to standard PWA manifest format\n    manifest_json = {\n        \"name\": manifest.app_name",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Check if worker name already exists for this manifest\n    existing_worker = db.query(ServiceWorker).filter(\n        and_(\n            ServiceWorker.manifest_id == manifest_id",
        "import:fastapi.description=\"Filter by cache strategy\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_by=manifest.created_by",
        "import:fastapi.ServiceWorker.is_default == True\n            )\n        ).update({\"is_default\": False})\n    \n    # Create new service worker\n    worker = ServiceWorker(**worker_data.dict())\n    worker.manifest_id = manifest_id\n    worker.created_by = current_user.username\n    db.add(worker)\n    db.commit()\n    db.refresh(worker)\n    \n    logger.info(f\"Service worker created: {current_user.username} - {worker_data.worker_name}\")\n    \n    return ServiceWorkerResponse(\n        id=str(worker.id)",
        "import:fastapi.manifest_id=str(worker.manifest_id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new PWA manifest.\n    \n    This creates a new PWA manifest configuration for the system.\n    \"\"\"\n    # Check if manifest name already exists\n    existing_manifest = db.query(PWAManifest).filter(\n        PWAManifest.manifest_name == manifest_data.manifest_name\n    ).first()\n    \n    if existing_manifest:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.manifest_name=manifest.manifest_name",
        "import:fastapi.APIRouter",
        "import:fastapi.background_sync_enabled=worker.background_sync_enabled",
        "import:fastapi.updated_at=manifest.updated_at\n        ))\n    \n    return PWAManifestListResponse(\n        manifests=manifest_responses"
      ]
    },
    "GET:/manifests/{manifest_id}/offline-resources": {
      "method": "GET",
      "path": "/manifests/{manifest_id}/offline-resources",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 476,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.\"description\": manifest.description",
        "import:fastapi.updated_at=worker.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/service-workers\"",
        "import:fastapi.OfflineResource.resource_url == resource_data.resource_url\n        )\n    ).first()\n    \n    if existing_resource:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.worker_url=worker.worker_url",
        "import:fastapi.\"orientation\": manifest.orientation",
        "import:fastapi.worker_scope=worker.worker_scope",
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.cache_strategy: Optional[CacheStrategyEnum] = Query(None",
        "import:fastapi.is_default=worker.is_default",
        "import:fastapi.response_model=ServiceWorkerListResponse)\nasync def list_service_workers(\n    manifest_id: str = Path(...",
        "function:create_offline_resource",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get PWA manifest as JSON for browser consumption.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.response_model=PWAManifestListResponse)\nasync def list_pwa_manifests(\n    page: int = Query(1",
        "import:fastapi.display_mode=manifest.display_mode",
        "import:fastapi.ge=1",
        "import:fastapi.screenshots=manifest.screenshots",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.related_applications=manifest.related_applications",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.icons=manifest.icons",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.PWAManifest.app_name.ilike(search_term)",
        "import:fastapi.unset other defaults\n    if manifest_data.is_default:\n        db.query(PWAManifest).filter(PWAManifest.is_default).update({\"is_default\": False})\n    \n    # Create new manifest\n    manifest = PWAManifest(**manifest_data.dict())\n    manifest.created_by = current_user.username\n    db.add(manifest)\n    db.commit()\n    db.refresh(manifest)\n    \n    logger.info(f\"PWA manifest created: {current_user.username} - {manifest_data.manifest_name}\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.start_url=manifest.start_url",
        "import:fastapi.PWAManifest.short_name.ilike(search_term)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.\"scope\": manifest.scope",
        "import:fastapi.\"screenshots\": manifest.screenshots",
        "import:fastapi.shortcuts=manifest.shortcuts",
        "import:fastapi.response_model=OfflineResourceResponse)\nasync def create_offline_resource(\n    manifest_id: str = Path(...",
        "import:fastapi.HTTPException",
        "import:fastapi.\"dir\": manifest.dir",
        "import:fastapi.orientation=manifest.orientation",
        "import:fastapi.created_at=resource.created_at",
        "import:fastapi.is_default=manifest.is_default",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Check if resource URL already exists for this manifest\n    existing_resource = db.query(OfflineResource).filter(\n        and_(\n            OfflineResource.manifest_id == manifest_id",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.updated_at=worker.updated_at\n        ))\n    \n    return ServiceWorkerListResponse(\n        workers=worker_responses",
        "import:fastapi.unset other defaults for this manifest\n    if worker_data.is_default:\n        db.query(ServiceWorker).filter(\n            and_(\n                ServiceWorker.manifest_id == manifest_id",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.is_active=worker.is_active",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.description=manifest.description",
        "import:fastapi.created_at=worker.created_at",
        "import:fastapi.ServiceWorker",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests\"",
        "import:fastapi.scope=manifest.scope",
        "import:fastapi.description=\"PWA manifest ID\")",
        "import:fastapi.background_color=manifest.background_color",
        "import:fastapi.\"display\": manifest.display_mode",
        "import:fastapi.short_name=manifest.short_name",
        "import:fastapi.offline_fallback=worker.offline_fallback",
        "import:fastapi.worker_script=worker.worker_script",
        "import:fastapi.Depends",
        "import:fastapi.prefer_related_applications=manifest.prefer_related_applications",
        "import:fastapi.Path",
        "import:fastapi.PWAStatistics",
        "import:fastapi.resource_url=resource.resource_url",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# OFFLINE RESOURCE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests/{manifest_id}/offline-resources\"",
        "import:fastapi.page=page",
        "import:fastapi.\"prefer_related_applications\": manifest.prefer_related_applications\n    }\n    \n    return JSONResponse(content=manifest_json",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.\"shortcuts\": manifest.shortcuts",
        "import:fastapi.PWAManifest.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get manifests\n    manifests = query.order_by(PWAManifest.manifest_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    manifest_responses = []\n    for manifest in manifests:\n        manifest_responses.append(PWAManifestResponse(\n            id=str(manifest.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new service worker for a PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.resource_category=resource.resource_category",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific PWA manifest by ID.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Build base query\n    query = db.query(ServiceWorker).filter(ServiceWorker.manifest_id == manifest_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(ServiceWorker.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(ServiceWorker.is_default == is_default)\n    \n    if cache_strategy:\n        query = query.filter(ServiceWorker.cache_strategy == cache_strategy)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get workers\n    workers = query.order_by(ServiceWorker.worker_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    worker_responses = []\n    for worker in workers:\n        worker_responses.append(ServiceWorkerResponse(\n            id=str(worker.id)",
        "import:fastapi.dir=manifest.dir",
        "import:fastapi.created_at=manifest.created_at",
        "import:fastapi.categories=manifest.categories",
        "import:fastapi.\"lang\": manifest.lang",
        "import:fastapi.worker_name=worker.worker_name",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def create_pwa_manifest(\n    manifest_data: PWAManifestCreateRequest = Body(...)",
        "import:fastapi.media_type=\"application/manifest+json\")\n\n\n# ============================================================================\n# SERVICE WORKER MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests/{manifest_id}/service-workers\"",
        "import:fastapi.detail=f\"Service worker with name '{worker_data.worker_name}' already exists for this manifest\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.theme_color=manifest.theme_color",
        "import:fastapi.\"categories\": manifest.categories",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List service workers for a specific PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.resource_type=resource.resource_type",
        "import:fastapi.PWAInstallation",
        "import:fastapi.description=\"Filter by display mode\")",
        "import:fastapi.version_hash=resource.version_hash",
        "import:fastapi.OfflineResource",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.response_model=ServiceWorkerResponse)\nasync def create_service_worker(\n    manifest_id: str = Path(...",
        "import:fastapi.manifest_id=str(resource.manifest_id)",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def get_pwa_manifest(\n    manifest_id: str = Path(...",
        "import:fastapi.detail=f\"PWA manifest with name '{manifest_data.manifest_name}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.\"theme_color\": manifest.theme_color",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new offline resource for a PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"icons\": manifest.icons",
        "import:fastapi.created_by=worker.created_by",
        "import:fastapi.resource_data: OfflineResourceCreateRequest = Body(...)",
        "import:fastapi.is_offline_available=resource.is_offline_available",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/manifest.json\")\nasync def get_pwa_manifest_json(\n    manifest_id: str = Path(...",
        "import:fastapi.\"short_name\": manifest.short_name",
        "import:fastapi.worker_data: ServiceWorkerCreateRequest = Body(...)",
        "import:fastapi.lang=manifest.lang",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.is_active=manifest.is_active",
        "import:fastapi.compression_enabled=resource.compression_enabled",
        "import:fastapi.ServiceWorker.worker_name == worker_data.worker_name\n        )\n    ).first()\n    \n    if existing_worker:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.file_size=resource.file_size",
        "import:fastapi.cache_strategy=worker.cache_strategy",
        "import:fastapi.\"related_applications\": manifest.related_applications",
        "import:fastapi.updated_at=resource.updated_at\n    )",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.description=\"Search in manifest names and descriptions\")",
        "import:fastapi.worker_version=worker.worker_version",
        "import:fastapi.push_enabled=worker.push_enabled",
        "import:fastapi.app_name=manifest.app_name",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/manifests/{manifest_id}\"",
        "import:fastapi.display_mode: Optional[DisplayModeEnum] = Query(None",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List PWA manifests with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PWAManifest)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(PWAManifest.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(PWAManifest.is_default == is_default)\n    \n    if display_mode:\n        query = query.filter(PWAManifest.display_mode == display_mode)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                PWAManifest.manifest_name.ilike(search_term)",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.\"start_url\": manifest.start_url",
        "import:fastapi.last_updated=resource.last_updated",
        "import:fastapi.\"background_color\": manifest.background_color",
        "import:fastapi.detail=f\"Offline resource with URL '{resource_data.resource_url}' already exists for this manifest\"\n        )\n    \n    # Create new offline resource\n    resource = OfflineResource(**resource_data.dict())\n    resource.manifest_id = manifest_id\n    db.add(resource)\n    db.commit()\n    db.refresh(resource)\n    \n    logger.info(f\"Offline resource created: {current_user.username} - {resource_data.resource_url}\")\n    \n    return OfflineResourceResponse(\n        id=str(resource.id)",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Convert to standard PWA manifest format\n    manifest_json = {\n        \"name\": manifest.app_name",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Check if worker name already exists for this manifest\n    existing_worker = db.query(ServiceWorker).filter(\n        and_(\n            ServiceWorker.manifest_id == manifest_id",
        "import:fastapi.description=\"Filter by cache strategy\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_by=manifest.created_by",
        "import:fastapi.cache_duration=resource.cache_duration",
        "import:fastapi.ServiceWorker.is_default == True\n            )\n        ).update({\"is_default\": False})\n    \n    # Create new service worker\n    worker = ServiceWorker(**worker_data.dict())\n    worker.manifest_id = manifest_id\n    worker.created_by = current_user.username\n    db.add(worker)\n    db.commit()\n    db.refresh(worker)\n    \n    logger.info(f\"Service worker created: {current_user.username} - {worker_data.worker_name}\")\n    \n    return ServiceWorkerResponse(\n        id=str(worker.id)",
        "import:fastapi.manifest_id=str(worker.manifest_id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new PWA manifest.\n    \n    This creates a new PWA manifest configuration for the system.\n    \"\"\"\n    # Check if manifest name already exists\n    existing_manifest = db.query(PWAManifest).filter(\n        PWAManifest.manifest_name == manifest_data.manifest_name\n    ).first()\n    \n    if existing_manifest:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.manifest_name=manifest.manifest_name",
        "import:fastapi.APIRouter",
        "import:fastapi.background_sync_enabled=worker.background_sync_enabled",
        "import:fastapi.updated_at=manifest.updated_at\n        ))\n    \n    return PWAManifestListResponse(\n        manifests=manifest_responses"
      ]
    },
    "POST:/installations/track": {
      "method": "POST",
      "path": "/installations/track",
      "file": "services/api-gateway/app/api/v1/pwa_system.py",
      "line": 551,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.\"description\": manifest.description",
        "import:fastapi.updated_at=worker.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/service-workers\"",
        "import:fastapi.OfflineResource.resource_url == resource_data.resource_url\n        )\n    ).first()\n    \n    if existing_resource:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.worker_url=worker.worker_url",
        "import:fastapi.\"orientation\": manifest.orientation",
        "import:fastapi.worker_scope=worker.worker_scope",
        "import:fastapi.PWAManifestListResponse",
        "import:fastapi.cache_strategy: Optional[CacheStrategyEnum] = Query(None",
        "import:fastapi.is_default=worker.is_default",
        "import:fastapi.response_model=ServiceWorkerListResponse)\nasync def list_service_workers(\n    manifest_id: str = Path(...",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get PWA manifest as JSON for browser consumption.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.PWAManifestCreateRequest",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.ServiceWorkerCreateRequest",
        "import:fastapi.response_model=PWAManifestListResponse)\nasync def list_pwa_manifests(\n    page: int = Query(1",
        "import:fastapi.display_mode=manifest.display_mode",
        "import:fastapi.ge=1",
        "import:fastapi.screenshots=manifest.screenshots",
        "import:fastapi.Body\nfrom fastapi.responses import JSONResponse\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.related_applications=manifest.related_applications",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Build base query\n    query = db.query(OfflineResource).filter(OfflineResource.manifest_id == manifest_id)\n    \n    # Apply filters\n    if resource_type:\n        query = query.filter(OfflineResource.resource_type == resource_type)\n    \n    if resource_category:\n        query = query.filter(OfflineResource.resource_category == resource_category)\n    \n    if is_offline_available is not None:\n        query = query.filter(OfflineResource.is_offline_available == is_offline_available)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get resources\n    resources = query.order_by(OfflineResource.resource_url).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    resource_responses = []\n    for resource in resources:\n        resource_responses.append(OfflineResourceResponse(\n            id=str(resource.id)",
        "import:fastapi.le=100",
        "import:fastapi.resource_category: Optional[ResourceCategoryEnum] = Query(None",
        "import:fastapi.or_",
        "import:fastapi.icons=manifest.icons",
        "import:fastapi.PWAAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.pwa_system import (\n    PWAManifestResponse",
        "import:fastapi.PWAManifest.app_name.ilike(search_term)",
        "import:fastapi.unset other defaults\n    if manifest_data.is_default:\n        db.query(PWAManifest).filter(PWAManifest.is_default).update({\"is_default\": False})\n    \n    # Create new manifest\n    manifest = PWAManifest(**manifest_data.dict())\n    manifest.created_by = current_user.username\n    db.add(manifest)\n    db.commit()\n    db.refresh(manifest)\n    \n    logger.info(f\"PWA manifest created: {current_user.username} - {manifest_data.manifest_name}\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.start_url=manifest.start_url",
        "import:fastapi.PWAManifest.short_name.ilike(search_term)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.\"scope\": manifest.scope",
        "import:fastapi.\"screenshots\": manifest.screenshots",
        "import:fastapi.shortcuts=manifest.shortcuts",
        "import:fastapi.response_model=OfflineResourceResponse)\nasync def create_offline_resource(\n    manifest_id: str = Path(...",
        "import:fastapi.HTTPException",
        "import:fastapi.\"dir\": manifest.dir",
        "import:fastapi.orientation=manifest.orientation",
        "import:fastapi.created_at=resource.created_at",
        "import:fastapi.is_default=manifest.is_default",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Check if resource URL already exists for this manifest\n    existing_resource = db.query(OfflineResource).filter(\n        and_(\n            OfflineResource.manifest_id == manifest_id",
        "import:fastapi.ServiceWorkerResponse",
        "import:fastapi.updated_at=worker.updated_at\n        ))\n    \n    return ServiceWorkerListResponse(\n        workers=worker_responses",
        "import:fastapi.description=\"Filter by offline availability\")",
        "function:list_offline_resources",
        "import:fastapi.unset other defaults for this manifest\n    if worker_data.is_default:\n        db.query(ServiceWorker).filter(\n            and_(\n                ServiceWorker.manifest_id == manifest_id",
        "import:fastapi.is_offline_available: Optional[bool] = Query(None",
        "import:fastapi.OfflineResourceCreateRequest",
        "import:fastapi.is_active=worker.is_active",
        "import:fastapi.ServiceWorkerListResponse",
        "import:fastapi.DisplayModeEnum",
        "import:fastapi.description=manifest.description",
        "import:fastapi.created_at=worker.created_at",
        "import:fastapi.ServiceWorker",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.pwa_system import (\n    PWAManifest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests\"",
        "import:fastapi.scope=manifest.scope",
        "import:fastapi.description=\"PWA manifest ID\")",
        "import:fastapi.background_color=manifest.background_color",
        "import:fastapi.\"display\": manifest.display_mode",
        "import:fastapi.short_name=manifest.short_name",
        "import:fastapi.offline_fallback=worker.offline_fallback",
        "import:fastapi.description=\"Filter by resource category\")",
        "import:fastapi.worker_script=worker.worker_script",
        "import:fastapi.Depends",
        "import:fastapi.updated_at=resource.updated_at\n        ))\n    \n    return OfflineResourceListResponse(\n        resources=resource_responses",
        "import:fastapi.prefer_related_applications=manifest.prefer_related_applications",
        "import:fastapi.response_model=OfflineResourceListResponse)\nasync def list_offline_resources(\n    manifest_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.PWAStatistics",
        "import:fastapi.resource_url=resource.resource_url",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# OFFLINE RESOURCE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests/{manifest_id}/offline-resources\"",
        "import:fastapi.page=page",
        "import:fastapi.\"prefer_related_applications\": manifest.prefer_related_applications\n    }\n    \n    return JSONResponse(content=manifest_json",
        "import:fastapi.ResourceTypeEnum",
        "import:fastapi.CacheStrategyEnum",
        "import:fastapi.\"shortcuts\": manifest.shortcuts",
        "import:fastapi.PWAManifest.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get manifests\n    manifests = query.order_by(PWAManifest.manifest_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    manifest_responses = []\n    for manifest in manifests:\n        manifest_responses.append(PWAManifestResponse(\n            id=str(manifest.id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new service worker for a PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.resource_category=resource.resource_category",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific PWA manifest by ID.\n    \"\"\"\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    \n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Build base query\n    query = db.query(ServiceWorker).filter(ServiceWorker.manifest_id == manifest_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(ServiceWorker.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(ServiceWorker.is_default == is_default)\n    \n    if cache_strategy:\n        query = query.filter(ServiceWorker.cache_strategy == cache_strategy)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get workers\n    workers = query.order_by(ServiceWorker.worker_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    worker_responses = []\n    for worker in workers:\n        worker_responses.append(ServiceWorkerResponse(\n            id=str(worker.id)",
        "import:fastapi.dir=manifest.dir",
        "import:fastapi.created_at=manifest.created_at",
        "import:fastapi.categories=manifest.categories",
        "import:fastapi.\"lang\": manifest.lang",
        "import:fastapi.worker_name=worker.worker_name",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def create_pwa_manifest(\n    manifest_data: PWAManifestCreateRequest = Body(...)",
        "import:fastapi.media_type=\"application/manifest+json\")\n\n\n# ============================================================================\n# SERVICE WORKER MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests/{manifest_id}/service-workers\"",
        "import:fastapi.detail=f\"Service worker with name '{worker_data.worker_name}' already exists for this manifest\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.theme_color=manifest.theme_color",
        "import:fastapi.\"categories\": manifest.categories",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List service workers for a specific PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.resource_type=resource.resource_type",
        "import:fastapi.PWAInstallation",
        "import:fastapi.description=\"Filter by display mode\")",
        "import:fastapi.version_hash=resource.version_hash",
        "import:fastapi.OfflineResource",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.OfflineResourceListResponse",
        "import:fastapi.Query",
        "import:fastapi.resource_type: Optional[ResourceTypeEnum] = Query(None",
        "import:fastapi.total=total",
        "import:fastapi.response_model=ServiceWorkerResponse)\nasync def create_service_worker(\n    manifest_id: str = Path(...",
        "import:fastapi.manifest_id=str(resource.manifest_id)",
        "import:fastapi.response_model=PWAManifestResponse)\nasync def get_pwa_manifest(\n    manifest_id: str = Path(...",
        "import:fastapi.detail=f\"PWA manifest with name '{manifest_data.manifest_name}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.\"theme_color\": manifest.theme_color",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new offline resource for a PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"icons\": manifest.icons",
        "import:fastapi.created_by=worker.created_by",
        "import:fastapi.resource_data: OfflineResourceCreateRequest = Body(...)",
        "import:fastapi.is_offline_available=resource.is_offline_available",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.updated_at=manifest.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/manifest.json\")\nasync def get_pwa_manifest_json(\n    manifest_id: str = Path(...",
        "import:fastapi.\"short_name\": manifest.short_name",
        "import:fastapi.worker_data: ServiceWorkerCreateRequest = Body(...)",
        "import:fastapi.lang=manifest.lang",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    return PWAManifestResponse(\n        id=str(manifest.id)",
        "import:fastapi.is_active=manifest.is_active",
        "import:fastapi.updated_at=resource.updated_at\n    )\n\n\n@router.get(\"/manifests/{manifest_id}/offline-resources\"",
        "import:fastapi.compression_enabled=resource.compression_enabled",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List offline resources for a specific PWA manifest.\n    \"\"\"\n    # Verify manifest exists\n    manifest = db.query(PWAManifest).filter(PWAManifest.id == manifest_id).first()\n    if not manifest:\n        raise HTTPException(status_code=404",
        "import:fastapi.ServiceWorker.worker_name == worker_data.worker_name\n        )\n    ).first()\n    \n    if existing_worker:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.file_size=resource.file_size",
        "import:fastapi.cache_strategy=worker.cache_strategy",
        "import:fastapi.\"related_applications\": manifest.related_applications",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.description=\"Search in manifest names and descriptions\")",
        "import:fastapi.worker_version=worker.worker_version",
        "import:fastapi.push_enabled=worker.push_enabled",
        "import:fastapi.app_name=manifest.app_name",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/manifests/{manifest_id}\"",
        "import:fastapi.display_mode: Optional[DisplayModeEnum] = Query(None",
        "import:fastapi.PWAInstallationTrackingRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List PWA manifests with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(PWAManifest)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(PWAManifest.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(PWAManifest.is_default == is_default)\n    \n    if display_mode:\n        query = query.filter(PWAManifest.display_mode == display_mode)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                PWAManifest.manifest_name.ilike(search_term)",
        "import:fastapi.ResourceCategoryEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# PWA MANIFEST MANAGEMENT\n# ============================================================================\n\n@router.post(\"/manifests\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.\"start_url\": manifest.start_url",
        "import:fastapi.last_updated=resource.last_updated",
        "import:fastapi.\"background_color\": manifest.background_color",
        "import:fastapi.detail=f\"Offline resource with URL '{resource_data.resource_url}' already exists for this manifest\"\n        )\n    \n    # Create new offline resource\n    resource = OfflineResource(**resource_data.dict())\n    resource.manifest_id = manifest_id\n    db.add(resource)\n    db.commit()\n    db.refresh(resource)\n    \n    logger.info(f\"Offline resource created: {current_user.username} - {resource_data.resource_url}\")\n    \n    return OfflineResourceResponse(\n        id=str(resource.id)",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Convert to standard PWA manifest format\n    manifest_json = {\n        \"name\": manifest.app_name",
        "import:fastapi.OfflineResourceResponse",
        "import:fastapi.detail=\"PWA manifest not found\")\n    \n    # Check if worker name already exists for this manifest\n    existing_worker = db.query(ServiceWorker).filter(\n        and_(\n            ServiceWorker.manifest_id == manifest_id",
        "import:fastapi.description=\"Filter by cache strategy\")",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# PWA INSTALLATION TRACKING\n# ============================================================================",
        "import:fastapi.description=\"Filter by resource type\")",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_by=manifest.created_by",
        "import:fastapi.cache_duration=resource.cache_duration",
        "import:fastapi.ServiceWorker.is_default == True\n            )\n        ).update({\"is_default\": False})\n    \n    # Create new service worker\n    worker = ServiceWorker(**worker_data.dict())\n    worker.manifest_id = manifest_id\n    worker.created_by = current_user.username\n    db.add(worker)\n    db.commit()\n    db.refresh(worker)\n    \n    logger.info(f\"Service worker created: {current_user.username} - {worker_data.worker_name}\")\n    \n    return ServiceWorkerResponse(\n        id=str(worker.id)",
        "import:fastapi.manifest_id=str(worker.manifest_id)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new PWA manifest.\n    \n    This creates a new PWA manifest configuration for the system.\n    \"\"\"\n    # Check if manifest name already exists\n    existing_manifest = db.query(PWAManifest).filter(\n        PWAManifest.manifest_name == manifest_data.manifest_name\n    ).first()\n    \n    if existing_manifest:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.manifest_name=manifest.manifest_name",
        "import:fastapi.APIRouter",
        "import:fastapi.background_sync_enabled=worker.background_sync_enabled",
        "import:fastapi.updated_at=manifest.updated_at\n        ))\n    \n    return PWAManifestListResponse(\n        manifests=manifest_responses"
      ]
    },
    "GET:/{committee_id}/meetings": {
      "method": "GET",
      "path": "/{committee_id}/meetings",
      "file": "services/api-gateway/app/api/v1/committees.py",
      "line": 73,
      "dependencies": [
        "import:fastapi.MeetingListResponse",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.Bill",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.meeting_count=0",
        "function:list_committees",
        "import:fastapi.page_size=page_size",
        "import:fastapi.Member",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.active=True",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.and_",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.'45-1')\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.Pagination",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.APIRouter",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\"",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail"
      ]
    },
    "GET:/{committee_slug}/": {
      "method": "GET",
      "path": "/{committee_slug}/",
      "file": "services/api-gateway/app/api/v1/committees.py",
      "line": 164,
      "dependencies": [
        "import:fastapi.MeetingListResponse",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.Bill",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.meeting_count=0",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.Member",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.MeetingDetail",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.active=True",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "function:get_committee_meetings",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.total=total",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.Party",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.Pagination",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.APIRouter",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\"",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail"
      ]
    },
    "GET:/meetings/": {
      "method": "GET",
      "path": "/meetings/",
      "file": "services/api-gateway/app/api/v1/committees.py",
      "line": 193,
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "function:get_committee_detail",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    "GET:/{committee_slug}/{session_id}/{number}/": {
      "method": "GET",
      "path": "/{committee_slug}/{session_id}/{number}/",
      "file": "services/api-gateway/app/api/v1/committees.py",
      "line": 225,
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    "GET:/activities/": {
      "method": "GET",
      "path": "/activities/",
      "file": "services/api-gateway/app/api/v1/committees.py",
      "line": 242,
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "function:get_committee_meeting_detail",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.detail=\"Meeting not found\")",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.response_model=MeetingDetailResponse)\nasync def get_committee_meeting_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee meeting.\n    \n    Based on legacy CommitteeMeetingView functionality.\n    \"\"\"\n    \n    # Placeholder implementation\n    raise HTTPException(status_code=404",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.session_id: str",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.number: int",
        "import:fastapi.meeting_count=0",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/{session_id}/{number}/\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    "GET:/postcode/{postcode}": {
      "method": "GET",
      "path": "/postcode/{postcode}",
      "file": "services/api-gateway/app/api/v1/search.py",
      "line": 271,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.reverse=True)\n    \n    return SearchResponse(\n        query=search_query",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n        \n        if date__lte:\n            try:\n                date_lte = datetime.strptime(date__lte",
        "import:fastapi.description=\"Maximum number of suggestions\")",
        "import:fastapi.content_type=\"politician\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Search across all parliamentary content.\n    \n    Based on legacy search functionality with full-text search capabilities.\n    \"\"\"\n    \n    if not q or len(q.strip()) < 2:\n        raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.Bill.summary.ilike(f\"%{search_query}%\") if Bill.summary else False\n            )\n        )\n        \n        # Apply additional filters\n        if date__gte:\n            try:\n                date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Partial search query\")",
        "import:fastapi.# Not directly available in this schema\n                relevance_score=1.0  # Could implement actual scoring\n            ))\n    \n    if not content_type or content_type == \"bills\":\n        # Search bills\n        bill_query = db.query(Bill)\n        \n        # Add text search on title and summary\n        bill_query = bill_query.filter(\n            or_(\n                Bill.title.ilike(f\"%{search_query}%\")",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Politician name filter\")",
        "import:fastapi.title=f\"Bill {bill.bill_number}: {bill.title}\"",
        "import:fastapi.response_model=SearchResponse)\nasync def search_content(\n    q: str = Query(...",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.snippet_start + 200)\n                snippet = text[snippet_start:snippet_end]\n                if snippet_start > 0:\n                    snippet = \"...\" + snippet\n                if snippet_end < len(text):\n                    snippet = snippet + \"...\"\n            else:\n                snippet = \"No description available\"\n            \n            results.append(SearchResult(\n                id=str(stmt.id)",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.snippet=snippet",
        "import:fastapi.PostcodeResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.type=\"politician\"",
        "import:fastapi.HTTPException",
        "import:fastapi.date=bill.introduced_date.isoformat() if bill.introduced_date else None",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n        \n        # Apply sorting\n        if sort == \"date\":\n            bill_query = bill_query.order_by(desc(Bill.introduced_date))\n        else:\n            # For relevance",
        "import:fastapi.isouter=True).filter(Member.full_name.ilike(f\"%{politician}%\"))\n        \n        if date__gte:\n            try:\n                date_gte = datetime.strptime(date__gte",
        "import:fastapi.Member",
        "import:fastapi.content_type: Optional[str] = Query(None",
        "import:fastapi.total_pages=(total + page_size - 1) // page_size if total > 0 else 0\n    )\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.debates",
        "import:fastapi.title=f\"Member: {politician.full_name}\"",
        "import:fastapi.url=f\"/api/v1/bills/{bill.id}/\"\n        ))\n    \n    return SearchSuggestionsResponse(suggestions=suggestions[:limit])",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.and_",
        "import:fastapi.SearchSuggestionsResponse",
        "import:fastapi.detail=\"Search query must be at least 2 characters\")\n    \n    search_query = q.strip()\n    results = []\n    total = 0\n    \n    # Search in different content types based on filter\n    if not content_type or content_type == \"debates\":\n        # Search votes/debates\n        stmt_query = db.query(Vote).join(Bill",
        "import:fastapi.just order by date\n            stmt_query = stmt_query.order_by(desc(Vote.vote_date))\n        \n        # Get total count\n        stmt_total = stmt_query.count()\n        total += stmt_total\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        statements = stmt_query.offset(offset).limit(page_size).all()\n    \n        # Convert to search results\n        for stmt in statements:\n            # Create snippet with highlighted search terms\n            text = stmt.vote_type or \"\"\n            if text:\n                snippet_start = max(0",
        "import:fastapi.\"%Y-%m-%d\")\n                bill_query = bill_query.filter(Bill.introduced_date <= date_lte)\n            except ValueError:\n                raise HTTPException(status_code=400",
        "import:fastapi.relevance_score=1.0  # Could implement actual scoring\n            ))\n    \n    # Sort all results by relevance/date\n    if sort == \"date\":\n        results.sort(key=lambda x: x.date or date.min",
        "import:fastapi.response_model=SearchSuggestionsResponse)\nasync def get_search_suggestions(\n    q: str = Query(...",
        "import:fastapi.SearchResponse",
        "import:fastapi.page=page",
        "import:fastapi.Party",
        "import:fastapi.description=\"Sort order (relevance",
        "import:fastapi.Bill.jurisdiction_id == Member.jurisdiction_id",
        "import:fastapi.\"%Y-%m-%d\")\n                bill_query = bill_query.filter(Bill.introduced_date >= date_gte)\n            except ValueError:\n                raise HTTPException(status_code=400",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.description=\"Content type filter (bills",
        "import:fastapi.Jurisdiction\nfrom app.schemas.search import (\n    SearchResult",
        "import:fastapi.Vote.bill_id == Bill.id",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n        \n        # Apply sorting\n        if sort == \"date\":\n            stmt_query = stmt_query.order_by(desc(Vote.vote_date))\n        else:\n            # For relevance",
        "import:fastapi.url=f\"/api/v1/votes/{stmt.id}/\"",
        "import:fastapi.description=\"Search query\")",
        "import:fastapi.url=f\"/api/v1/members/{politician.id}/\"",
        "import:fastapi.order by title similarity\n            bill_query = bill_query.order_by(Bill.title.ilike(f\"%{search_query}%\").desc())\n        \n        # Get total count\n        bill_total = bill_query.count()\n        total += bill_total\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        bills = bill_query.offset(offset).limit(page_size).all()\n        \n        # Convert to search results\n        for bill in bills:\n            # Create snippet with highlighted search terms\n            text = bill.title or \"\"\n            if bill.summary:\n                text += \" \" + bill.summary\n            \n            if text:\n                snippet_start = max(0",
        "import:fastapi.Any\nfrom datetime import date",
        "import:fastapi.politician: Optional[str] = Query(None",
        "import:fastapi.politician_name=politician.full_name",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.Optional",
        "import:fastapi.title=f\"Vote on {stmt.bill.title if stmt.bill else 'Unknown Bill'}\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.snippet=f\"Member of Parliament representing {politician.district or 'Unknown District'}\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.content_type=\"debate\"",
        "import:fastapi.Query",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get search suggestions for autocomplete functionality.\n    \n    Based on legacy politician autocomplete and search suggestion features.\n    \"\"\"\n    \n    if len(q.strip()) < 2:\n        return SearchSuggestionsResponse(suggestions=[])\n    \n    search_query = q.strip()\n    \n    # Get politician name suggestions\n    politicians = db.query(Member).filter(\n        Member.full_name.ilike(f\"{search_query}%\")\n    ).limit(limit // 2).all()\n    \n    # Get bill title suggestions\n    bills = db.query(Bill).filter(\n        Bill.title.ilike(f\"{search_query}%\")\n    ).limit(limit // 2).all()\n    \n    suggestions = []\n    \n    # Add politician suggestions\n    for politician in politicians:\n        suggestions.append(SearchSuggestion(\n            text=politician.full_name",
        "import:fastapi.we could implement a scoring system\n            # For now",
        "import:fastapi.total_results=total",
        "import:fastapi.\"%Y-%m-%d\")\n                stmt_query = stmt_query.filter(Vote.vote_date <= date_lte)\n            except ValueError:\n                raise HTTPException(status_code=400",
        "import:fastapi.date)\")",
        "import:fastapi.date=stmt.vote_date.date().isoformat() if stmt.vote_date else None",
        "import:fastapi.SearchSuggestion",
        "import:fastapi.content_type=\"bill\"",
        "import:fastapi.PostcodeResult",
        "import:fastapi.date=politician.start_date.isoformat() if politician.start_date else None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.text.lower().find(search_query.lower()) - 50)\n                snippet_end = min(len(text)",
        "import:fastapi.url=f\"/api/v1/bills/{bill.id}/\"",
        "import:fastapi.isouter=True)\n        \n        # Add text search\n        stmt_query = stmt_query.filter(Vote.vote_type.ilike(f\"%{search_query}%\"))\n        \n        # Apply additional filters\n        if politician:\n            stmt_query = stmt_query.join(Bill).join(Member",
        "function:get_search_suggestions",
        "import:fastapi.sort: Optional[str] = Query(\"relevance\"",
        "import:fastapi.politicians)\")",
        "import:fastapi.politician_name=None",
        "import:fastapi.\"%Y-%m-%d\")\n                stmt_query = stmt_query.filter(Vote.vote_date >= date_gte)\n            except ValueError:\n                raise HTTPException(status_code=400",
        "import:fastapi.snippet_start + 200)\n                snippet = text[snippet_start:snippet_end]\n                if snippet_start > 0:\n                    snippet = \"...\" + snippet\n                if snippet_end < len(text):\n                    snippet = snippet + \"...\"\n            else:\n                snippet = \"No description available\"\n            \n            results.append(SearchResult(\n                id=str(bill.id)",
        "import:fastapi.type=\"bill\"",
        "import:fastapi.# Not directly available in this schema\n                relevance_score=1.0  # Could implement actual scoring\n            ))\n    \n    if not content_type or content_type == \"politicians\":\n        # Search politicians\n        pol_query = db.query(Member)\n        \n        # Add name search\n        pol_query = pol_query.filter(Member.full_name.ilike(f\"%{search_query}%\"))\n        \n        politicians = pol_query.limit(page_size // 3).all()  # Limit politician results\n        \n        # Convert to search results\n        for politician in politicians:\n            results.append(SearchResult(\n                id=str(politician.id)",
        "import:fastapi.url=f\"/api/v1/members/{politician.id}/\"\n        ))\n    \n    # Add bill suggestions\n    for bill in bills:\n        suggestions.append(SearchSuggestion(\n            text=f\"Bill {bill.bill_number}: {bill.title}\"",
        "import:fastapi.le=20",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.results=results"
      ]
    },
    "GET:/boundary-sets": {
      "method": "GET",
      "path": "/boundary-sets",
      "file": "services/api-gateway/app/api/v1/represent.py",
      "line": 63,
      "dependencies": [
        "import:fastapi.description=\"Name of the boundary set\")\n    domain: str = Field(...",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Name of the boundary set\")\n    external_id: str = Field(...",
        "import:fastapi.description=\"Elected office (e.g.",
        "import:fastapi.Any\nfrom pydantic import BaseModel",
        "import:fastapi.description=\"Centroid longitude\")\n    area: Optional[float] = Field(None",
        "import:fastapi.provincial districts).\"\"\"\n    name: str = Field(...",
        "import:fastapi.description=\"URL slug for the boundary set\")\n    last_updated: Optional[str] = Field(None",
        "import:fastapi.description=\"External identifier\")\n    centroid_lat: Optional[float] = Field(None",
        "import:fastapi.'Elections Canada')\")\n    slug: str = Field(...",
        "import:fastapi.description=\"Name of the boundary\")\n    boundary_set_name: str = Field(...",
        "import:fastapi.description=\"Boundaries linked by postal code\")\n    representatives_centroid: List[Representative] = Field(...",
        "import:fastapi.description=\"Domain (e.g.",
        "import:fastapi.description=\"Area in square kilometers\")\n\n\nclass Representative(BaseModel):\n    \"\"\"Elected representative information.\"\"\"\n    name: str = Field(...",
        "import:fastapi.'MP'",
        "import:fastapi.description=\"Representatives for concordance boundaries\")",
        "import:fastapi.description=\"Authority (e.g.",
        "import:fastapi.description=\"District/riding name\")\n    url: Optional[str] = Field(None",
        "import:fastapi.description=\"Boundaries containing the centroid\")\n    boundaries_concordance: List[Boundary] = Field(...",
        "import:fastapi.description=\"Representatives for centroid boundaries\")\n    representatives_concordance: List[Representative] = Field(...",
        "import:fastapi.Optional",
        "import:fastapi.description=\"Centroid latitude\")\n    centroid_lon: Optional[float] = Field(None",
        "import:fastapi.description=\"Personal website URL\")\n\n\nclass PostalCodeLookup(BaseModel):\n    \"\"\"Postal code lookup result.\"\"\"\n    postal_code: str = Field(...",
        "import:fastapi.specific riding or district).\"\"\"\n    name: str = Field(...",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.description=\"Full name of the representative\")\n    first_name: Optional[str] = Field(None",
        "import:fastapi.'MLA')\")\n    district_name: str = Field(...",
        "import:fastapi.description=\"Last name\")\n    party_name: Optional[str] = Field(None",
        "import:fastapi.federal ridings",
        "import:fastapi.description=\"Photo URL\")\n    elected_office: str = Field(...",
        "import:fastapi.description=\"Email address\")\n    photo_url: Optional[str] = Field(None",
        "import:fastapi.description=\"Last update timestamp\")\n\n\nclass Boundary(BaseModel):\n    \"\"\"Electoral boundary (e.g.",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"First name\")\n    last_name: Optional[str] = Field(None",
        "import:fastapi.description=\"Political party name\")\n    email: Optional[str] = Field(None",
        "import:fastapi.description=\"The postal code\")\n    boundaries_centroid: List[Boundary] = Field(...",
        "import:fastapi.'ca')\")\n    authority: str = Field(...",
        "import:fastapi.Field\n\nrouter = APIRouter()\n\n# Represent API base URL\nREPRESENT_API_BASE = \"https://represent.opennorth.ca\"\n\n# Rate limiting: 60 requests per minute\nRATE_LIMIT_PER_MINUTE = 60\n\n\nclass BoundarySet(BaseModel):\n    \"\"\"Electoral boundary set (e.g."
      ]
    },
    "GET:/boundaries/{boundary_set_slug}": {
      "method": "GET",
      "path": "/boundaries/{boundary_set_slug}",
      "file": "services/api-gateway/app/api/v1/represent.py",
      "line": 83,
      "dependencies": [
        "import:fastapi.description=\"Name of the boundary set\")\n    domain: str = Field(...",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Name of the boundary set\")\n    external_id: str = Field(...",
        "import:fastapi.description=\"Elected office (e.g.",
        "import:fastapi.Any\nfrom pydantic import BaseModel",
        "import:fastapi.description=\"Centroid longitude\")\n    area: Optional[float] = Field(None",
        "import:fastapi.provincial districts).\"\"\"\n    name: str = Field(...",
        "import:fastapi.description=\"URL slug for the boundary set\")\n    last_updated: Optional[str] = Field(None",
        "import:fastapi.description=\"Representatives for concordance boundaries\")\n\n\n@router.get(\"/boundary-sets\"",
        "import:fastapi.description=\"External identifier\")\n    centroid_lat: Optional[float] = Field(None",
        "import:fastapi.'Elections Canada')\")\n    slug: str = Field(...",
        "import:fastapi.description=\"Name of the boundary\")\n    boundary_set_name: str = Field(...",
        "import:fastapi.description=\"Boundaries linked by postal code\")\n    representatives_centroid: List[Representative] = Field(...",
        "import:fastapi.detail=f\"Failed to fetch boundary sets: {str(e)}\")",
        "import:fastapi.description=\"Domain (e.g.",
        "import:fastapi.detail=\"Represent API error\")\n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.description=\"Area in square kilometers\")\n\n\nclass Representative(BaseModel):\n    \"\"\"Elected representative information.\"\"\"\n    name: str = Field(...",
        "import:fastapi.'MP'",
        "import:fastapi.description=\"Authority (e.g.",
        "import:fastapi.description=\"District/riding name\")\n    url: Optional[str] = Field(None",
        "import:fastapi.description=\"Boundaries containing the centroid\")\n    boundaries_concordance: List[Boundary] = Field(...",
        "import:fastapi.description=\"Representatives for centroid boundaries\")\n    representatives_concordance: List[Representative] = Field(...",
        "import:fastapi.Optional",
        "import:fastapi.description=\"Centroid latitude\")\n    centroid_lon: Optional[float] = Field(None",
        "import:fastapi.response_model=List[BoundarySet])\nasync def get_boundary_sets():\n    \"\"\"\n    Get available electoral boundary sets.\n    \n    Returns:\n        List of available boundary sets (federal",
        "import:fastapi.description=\"Personal website URL\")\n\n\nclass PostalCodeLookup(BaseModel):\n    \"\"\"Postal code lookup result.\"\"\"\n    postal_code: str = Field(...",
        "import:fastapi.municipal)\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{REPRESENT_API_BASE}/boundary-sets/\")\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.specific riding or district).\"\"\"\n    name: str = Field(...",
        "function:get_boundary_sets",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.description=\"Full name of the representative\")\n    first_name: Optional[str] = Field(None",
        "import:fastapi.'MLA')\")\n    district_name: str = Field(...",
        "import:fastapi.description=\"Last name\")\n    party_name: Optional[str] = Field(None",
        "import:fastapi.[])\n    except httpx.HTTPStatusError as e:\n        raise HTTPException(status_code=e.response.status_code",
        "import:fastapi.federal ridings",
        "import:fastapi.description=\"Photo URL\")\n    elected_office: str = Field(...",
        "import:fastapi.provincial",
        "import:fastapi.description=\"Email address\")\n    photo_url: Optional[str] = Field(None",
        "import:fastapi.description=\"Last update timestamp\")\n\n\nclass Boundary(BaseModel):\n    \"\"\"Electoral boundary (e.g.",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"First name\")\n    last_name: Optional[str] = Field(None",
        "import:fastapi.description=\"Political party name\")\n    email: Optional[str] = Field(None",
        "import:fastapi.description=\"The postal code\")\n    boundaries_centroid: List[Boundary] = Field(...",
        "import:fastapi.'ca')\")\n    authority: str = Field(...",
        "import:fastapi.Field\n\nrouter = APIRouter()\n\n# Represent API base URL\nREPRESENT_API_BASE = \"https://represent.opennorth.ca\"\n\n# Rate limiting: 60 requests per minute\nRATE_LIMIT_PER_MINUTE = 60\n\n\nclass BoundarySet(BaseModel):\n    \"\"\"Electoral boundary set (e.g."
      ]
    },
    "GET:/representatives/{representative_set_slug}": {
      "method": "GET",
      "path": "/representatives/{representative_set_slug}",
      "file": "services/api-gateway/app/api/v1/represent.py",
      "line": 115,
      "dependencies": [
        "import:fastapi.description=\"Name of the boundary set\")\n    domain: str = Field(...",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Name of the boundary set\")\n    external_id: str = Field(...",
        "import:fastapi.description=\"Elected office (e.g.",
        "import:fastapi.Any\nfrom pydantic import BaseModel",
        "import:fastapi.description=\"Centroid longitude\")\n    area: Optional[float] = Field(None",
        "import:fastapi.provincial districts).\"\"\"\n    name: str = Field(...",
        "import:fastapi.description=\"URL slug for the boundary set\")\n    last_updated: Optional[str] = Field(None",
        "import:fastapi.description=\"Number of results to skip\")\n):\n    \"\"\"\n    Get boundaries for a specific boundary set.\n    \n    Args:\n        boundary_set_slug: Slug of the boundary set (e.g.",
        "import:fastapi.description=\"Representatives for concordance boundaries\")\n\n\n@router.get(\"/boundary-sets\"",
        "import:fastapi.description=\"External identifier\")\n    centroid_lat: Optional[float] = Field(None",
        "import:fastapi.'Elections Canada')\")\n    slug: str = Field(...",
        "import:fastapi.description=\"Name of the boundary\")\n    boundary_set_name: str = Field(...",
        "import:fastapi.description=\"Boundaries linked by postal code\")\n    representatives_centroid: List[Representative] = Field(...",
        "import:fastapi.description=\"Domain (e.g.",
        "import:fastapi.detail=\"Represent API error\")\n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.description=\"Area in square kilometers\")\n\n\nclass Representative(BaseModel):\n    \"\"\"Elected representative information.\"\"\"\n    name: str = Field(...",
        "import:fastapi.'MP'",
        "import:fastapi.detail=f\"Failed to fetch boundaries: {str(e)}\")",
        "import:fastapi.description=\"Authority (e.g.",
        "import:fastapi.description=\"District/riding name\")\n    url: Optional[str] = Field(None",
        "import:fastapi.description=\"Boundaries containing the centroid\")\n    boundaries_concordance: List[Boundary] = Field(...",
        "import:fastapi.description=\"Representatives for centroid boundaries\")\n    representatives_concordance: List[Representative] = Field(...",
        "import:fastapi.offset: int = Query(0",
        "import:fastapi.limit: int = Query(20",
        "import:fastapi.Optional",
        "import:fastapi.description=\"Centroid latitude\")\n    centroid_lon: Optional[float] = Field(None",
        "import:fastapi.response_model=List[BoundarySet])\nasync def get_boundary_sets():\n    \"\"\"\n    Get available electoral boundary sets.\n    \n    Returns:\n        List of available boundary sets (federal",
        "import:fastapi.params={\"limit\": limit",
        "import:fastapi.description=\"Personal website URL\")\n\n\nclass PostalCodeLookup(BaseModel):\n    \"\"\"Postal code lookup result.\"\"\"\n    postal_code: str = Field(...",
        "import:fastapi.ge=1",
        "import:fastapi.municipal)\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{REPRESENT_API_BASE}/boundary-sets/\")\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "function:get_boundaries",
        "import:fastapi.specific riding or district).\"\"\"\n    name: str = Field(...",
        "import:fastapi.response_model=List[Boundary])\nasync def get_boundaries(\n    boundary_set_slug: str",
        "import:fastapi.description=\"Number of results per page\")",
        "import:fastapi.le=100",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.description=\"Full name of the representative\")\n    first_name: Optional[str] = Field(None",
        "import:fastapi.ge=0",
        "import:fastapi.'MLA')\")\n    district_name: str = Field(...",
        "import:fastapi.description=\"Last name\")\n    party_name: Optional[str] = Field(None",
        "import:fastapi.[])\n    except httpx.HTTPStatusError as e:\n        raise HTTPException(status_code=e.response.status_code",
        "import:fastapi.federal ridings",
        "import:fastapi.description=\"Photo URL\")\n    elected_office: str = Field(...",
        "import:fastapi.provincial",
        "import:fastapi.\"offset\": offset}\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.description=\"Email address\")\n    photo_url: Optional[str] = Field(None",
        "import:fastapi.detail=f\"Failed to fetch boundary sets: {str(e)}\")\n\n\n@router.get(\"/boundaries/{boundary_set_slug}\"",
        "import:fastapi.description=\"Last update timestamp\")\n\n\nclass Boundary(BaseModel):\n    \"\"\"Electoral boundary (e.g.",
        "import:fastapi.'federal-electoral-districts')\n        limit: Number of results per page\n        offset: Number of results to skip\n    \n    Returns:\n        List of boundaries in the specified set\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{REPRESENT_API_BASE}/boundaries/{boundary_set_slug}/\"",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"First name\")\n    last_name: Optional[str] = Field(None",
        "import:fastapi.description=\"Political party name\")\n    email: Optional[str] = Field(None",
        "import:fastapi.description=\"The postal code\")\n    boundaries_centroid: List[Boundary] = Field(...",
        "import:fastapi.'ca')\")\n    authority: str = Field(...",
        "import:fastapi.Field\n\nrouter = APIRouter()\n\n# Represent API base URL\nREPRESENT_API_BASE = \"https://represent.opennorth.ca\"\n\n# Rate limiting: 60 requests per minute\nRATE_LIMIT_PER_MINUTE = 60\n\n\nclass BoundarySet(BaseModel):\n    \"\"\"Electoral boundary set (e.g."
      ]
    },
    "GET:/postal-code/{postal_code}": {
      "method": "GET",
      "path": "/postal-code/{postal_code}",
      "file": "services/api-gateway/app/api/v1/represent.py",
      "line": 157,
      "dependencies": [
        "import:fastapi.description=\"Name of the boundary set\")\n    domain: str = Field(...",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Name of the boundary set\")\n    external_id: str = Field(...",
        "import:fastapi.description=\"Elected office (e.g.",
        "import:fastapi.response_model=List[Representative])\nasync def get_representatives(\n    representative_set_slug: str",
        "import:fastapi.Any\nfrom pydantic import BaseModel",
        "import:fastapi.description=\"Centroid longitude\")\n    area: Optional[float] = Field(None",
        "import:fastapi.provincial districts).\"\"\"\n    name: str = Field(...",
        "import:fastapi.description=\"URL slug for the boundary set\")\n    last_updated: Optional[str] = Field(None",
        "import:fastapi.description=\"Number of results to skip\")\n):\n    \"\"\"\n    Get boundaries for a specific boundary set.\n    \n    Args:\n        boundary_set_slug: Slug of the boundary set (e.g.",
        "import:fastapi.description=\"Representatives for concordance boundaries\")\n\n\n@router.get(\"/boundary-sets\"",
        "import:fastapi.description=\"External identifier\")\n    centroid_lat: Optional[float] = Field(None",
        "import:fastapi.'Elections Canada')\")\n    slug: str = Field(...",
        "import:fastapi.detail=f\"Failed to fetch representatives: {str(e)}\")",
        "import:fastapi.description=\"Name of the boundary\")\n    boundary_set_name: str = Field(...",
        "import:fastapi.description=\"Boundaries linked by postal code\")\n    representatives_centroid: List[Representative] = Field(...",
        "import:fastapi.detail=f\"Failed to fetch boundaries: {str(e)}\")\n\n\n@router.get(\"/representatives/{representative_set_slug}\"",
        "import:fastapi.district_name: Optional[str] = Query(None",
        "import:fastapi.party_name: Optional[str] = Query(None",
        "import:fastapi.description=\"Domain (e.g.",
        "import:fastapi.detail=\"Represent API error\")\n    except Exception as e:\n        raise HTTPException(status_code=500",
        "function:get_representatives",
        "import:fastapi.description=\"Area in square kilometers\")\n\n\nclass Representative(BaseModel):\n    \"\"\"Elected representative information.\"\"\"\n    name: str = Field(...",
        "import:fastapi.'MP'",
        "import:fastapi.'house-of-commons')\n        limit: Number of results per page\n        offset: Number of results to skip\n        district_name: Filter by district name\n        party_name: Filter by party name\n    \n    Returns:\n        List of representatives in the specified set\n    \"\"\"\n    try:\n        params = {\"limit\": limit",
        "import:fastapi.description=\"Filter by party name\")\n):\n    \"\"\"\n    Get representatives for a specific representative set.\n    \n    Args:\n        representative_set_slug: Slug of the representative set (e.g.",
        "import:fastapi.description=\"Authority (e.g.",
        "import:fastapi.description=\"District/riding name\")\n    url: Optional[str] = Field(None",
        "import:fastapi.description=\"Boundaries containing the centroid\")\n    boundaries_concordance: List[Boundary] = Field(...",
        "import:fastapi.description=\"Representatives for centroid boundaries\")\n    representatives_concordance: List[Representative] = Field(...",
        "import:fastapi.offset: int = Query(0",
        "import:fastapi.limit: int = Query(20",
        "import:fastapi.Optional",
        "import:fastapi.description=\"Centroid latitude\")\n    centroid_lon: Optional[float] = Field(None",
        "import:fastapi.response_model=List[BoundarySet])\nasync def get_boundary_sets():\n    \"\"\"\n    Get available electoral boundary sets.\n    \n    Returns:\n        List of available boundary sets (federal",
        "import:fastapi.params={\"limit\": limit",
        "import:fastapi.description=\"Personal website URL\")\n\n\nclass PostalCodeLookup(BaseModel):\n    \"\"\"Postal code lookup result.\"\"\"\n    postal_code: str = Field(...",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Number of results to skip\")",
        "import:fastapi.municipal)\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{REPRESENT_API_BASE}/boundary-sets/\")\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.specific riding or district).\"\"\"\n    name: str = Field(...",
        "import:fastapi.response_model=List[Boundary])\nasync def get_boundaries(\n    boundary_set_slug: str",
        "import:fastapi.description=\"Number of results per page\")",
        "import:fastapi.\"offset\": offset}\n        if district_name:\n            params[\"district_name__icontains\"] = district_name\n        if party_name:\n            params[\"party_name__icontains\"] = party_name\n            \n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{REPRESENT_API_BASE}/representatives/{representative_set_slug}/\"",
        "import:fastapi.le=100",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.description=\"Full name of the representative\")\n    first_name: Optional[str] = Field(None",
        "import:fastapi.ge=0",
        "import:fastapi.'MLA')\")\n    district_name: str = Field(...",
        "import:fastapi.description=\"Last name\")\n    party_name: Optional[str] = Field(None",
        "import:fastapi.[])\n    except httpx.HTTPStatusError as e:\n        raise HTTPException(status_code=e.response.status_code",
        "import:fastapi.federal ridings",
        "import:fastapi.description=\"Photo URL\")\n    elected_office: str = Field(...",
        "import:fastapi.provincial",
        "import:fastapi.\"offset\": offset}\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.description=\"Filter by district name\")",
        "import:fastapi.description=\"Email address\")\n    photo_url: Optional[str] = Field(None",
        "import:fastapi.detail=f\"Failed to fetch boundary sets: {str(e)}\")\n\n\n@router.get(\"/boundaries/{boundary_set_slug}\"",
        "import:fastapi.description=\"Last update timestamp\")\n\n\nclass Boundary(BaseModel):\n    \"\"\"Electoral boundary (e.g.",
        "import:fastapi.'federal-electoral-districts')\n        limit: Number of results per page\n        offset: Number of results to skip\n    \n    Returns:\n        List of boundaries in the specified set\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{REPRESENT_API_BASE}/boundaries/{boundary_set_slug}/\"",
        "import:fastapi.Dict",
        "import:fastapi.params=params\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"First name\")\n    last_name: Optional[str] = Field(None",
        "import:fastapi.description=\"Political party name\")\n    email: Optional[str] = Field(None",
        "import:fastapi.description=\"The postal code\")\n    boundaries_centroid: List[Boundary] = Field(...",
        "import:fastapi.'ca')\")\n    authority: str = Field(...",
        "import:fastapi.Field\n\nrouter = APIRouter()\n\n# Represent API base URL\nREPRESENT_API_BASE = \"https://represent.opennorth.ca\"\n\n# Rate limiting: 60 requests per minute\nRATE_LIMIT_PER_MINUTE = 60\n\n\nclass BoundarySet(BaseModel):\n    \"\"\"Electoral boundary set (e.g."
      ]
    },
    "GET:/geocode": {
      "method": "GET",
      "path": "/geocode",
      "file": "services/api-gateway/app/api/v1/represent.py",
      "line": 193,
      "dependencies": [
        "import:fastapi.description=\"Name of the boundary\")\n    boundary_set_name: str = Field(...",
        "import:fastapi.description=\"Authority (e.g.",
        "import:fastapi.params={\"limit\": limit",
        "import:fastapi.ge=1",
        "import:fastapi.representatives_centroid=data.get(\"representatives_centroid\"",
        "import:fastapi.specific riding or district).\"\"\"\n    name: str = Field(...",
        "import:fastapi.\"offset\": offset}\n        if district_name:\n            params[\"district_name__icontains\"] = district_name\n        if party_name:\n            params[\"party_name__icontains\"] = party_name\n            \n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{REPRESENT_API_BASE}/representatives/{representative_set_slug}/\"",
        "import:fastapi.le=100",
        "import:fastapi.'MLA')\")\n    district_name: str = Field(...",
        "import:fastapi.[])\n    except httpx.HTTPStatusError as e:\n        raise HTTPException(status_code=e.response.status_code",
        "import:fastapi.'K1A0A6')\n    \n    Returns:\n        Boundaries and representatives for the postal code\n    \"\"\"\n    # Clean postal code (remove spaces",
        "import:fastapi.[])",
        "import:fastapi.representatives_concordance=data.get(\"representatives_concordance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.Field\n\nrouter = APIRouter()\n\n# Represent API base URL\nREPRESENT_API_BASE = \"https://represent.opennorth.ca\"\n\n# Rate limiting: 60 requests per minute\nRATE_LIMIT_PER_MINUTE = 60\n\n\nclass BoundarySet(BaseModel):\n    \"\"\"Electoral boundary set (e.g.",
        "import:fastapi.response_model=List[Representative])\nasync def get_representatives(\n    representative_set_slug: str",
        "import:fastapi.description=\"Number of results to skip\")\n):\n    \"\"\"\n    Get boundaries for a specific boundary set.\n    \n    Args:\n        boundary_set_slug: Slug of the boundary set (e.g.",
        "import:fastapi.uppercase)\n    postal_code = postal_code.replace(\" \"",
        "import:fastapi.description=\"External identifier\")\n    centroid_lat: Optional[float] = Field(None",
        "import:fastapi.detail=f\"Failed to fetch boundaries: {str(e)}\")\n\n\n@router.get(\"/representatives/{representative_set_slug}\"",
        "import:fastapi.boundaries_concordance=data.get(\"boundaries_concordance\"",
        "import:fastapi.[])\n            )\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise HTTPException(status_code=404",
        "import:fastapi.description=\"Domain (e.g.",
        "import:fastapi.detail=\"Represent API error\")\n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.'MP'",
        "import:fastapi.boundaries_centroid=data.get(\"boundaries_centroid\"",
        "import:fastapi.description=\"Boundaries containing the centroid\")\n    boundaries_concordance: List[Boundary] = Field(...",
        "import:fastapi.description=\"Personal website URL\")\n\n\nclass PostalCodeLookup(BaseModel):\n    \"\"\"Postal code lookup result.\"\"\"\n    postal_code: str = Field(...",
        "import:fastapi.description=\"Number of results to skip\")",
        "import:fastapi.response_model=PostalCodeLookup)\nasync def lookup_by_postal_code(postal_code: str):\n    \"\"\"\n    Look up electoral boundaries and representatives by postal code.\n    \n    Args:\n        postal_code: Canadian postal code (e.g.",
        "import:fastapi.description=\"Full name of the representative\")\n    first_name: Optional[str] = Field(None",
        "import:fastapi.federal ridings",
        "import:fastapi.description=\"Photo URL\")\n    elected_office: str = Field(...",
        "import:fastapi.\"\").upper()\n    \n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{REPRESENT_API_BASE}/postcodes/{postal_code}/\")\n            response.raise_for_status()\n            data = response.json()\n            \n            # Transform the response to match our schema\n            return PostalCodeLookup(\n                postal_code=postal_code",
        "import:fastapi.detail=f\"Failed to fetch boundary sets: {str(e)}\")\n\n\n@router.get(\"/boundaries/{boundary_set_slug}\"",
        "import:fastapi.params=params\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.description=\"The postal code\")\n    boundaries_centroid: List[Boundary] = Field(...",
        "import:fastapi.description=\"Name of the boundary set\")\n    domain: str = Field(...",
        "import:fastapi.description=\"Name of the boundary set\")\n    external_id: str = Field(...",
        "import:fastapi.Any\nfrom pydantic import BaseModel",
        "import:fastapi.description=\"Centroid longitude\")\n    area: Optional[float] = Field(None",
        "import:fastapi.provincial districts).\"\"\"\n    name: str = Field(...",
        "import:fastapi.detail=f\"Failed to fetch representatives: {str(e)}\")\n\n\n@router.get(\"/postal-code/{postal_code}\"",
        "import:fastapi.description=\"Representatives for concordance boundaries\")\n\n\n@router.get(\"/boundary-sets\"",
        "import:fastapi.description=\"Boundaries linked by postal code\")\n    representatives_centroid: List[Representative] = Field(...",
        "import:fastapi.district_name: Optional[str] = Query(None",
        "import:fastapi.party_name: Optional[str] = Query(None",
        "import:fastapi.description=\"Area in square kilometers\")\n\n\nclass Representative(BaseModel):\n    \"\"\"Elected representative information.\"\"\"\n    name: str = Field(...",
        "import:fastapi.description=\"Filter by party name\")\n):\n    \"\"\"\n    Get representatives for a specific representative set.\n    \n    Args:\n        representative_set_slug: Slug of the representative set (e.g.",
        "import:fastapi.description=\"District/riding name\")\n    url: Optional[str] = Field(None",
        "import:fastapi.offset: int = Query(0",
        "import:fastapi.Optional",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.detail=f\"Failed to lookup postal code: {str(e)}\")",
        "import:fastapi.\"offset\": offset}\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.provincial",
        "import:fastapi.description=\"Filter by district name\")",
        "import:fastapi.description=\"Email address\")\n    photo_url: Optional[str] = Field(None",
        "import:fastapi.'federal-electoral-districts')\n        limit: Number of results per page\n        offset: Number of results to skip\n    \n    Returns:\n        List of boundaries in the specified set\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{REPRESENT_API_BASE}/boundaries/{boundary_set_slug}/\"",
        "import:fastapi.description=\"Political party name\")\n    email: Optional[str] = Field(None",
        "import:fastapi.description=\"First name\")\n    last_name: Optional[str] = Field(None",
        "import:fastapi.'ca')\")\n    authority: str = Field(...",
        "import:fastapi.description=\"Elected office (e.g.",
        "import:fastapi.description=\"URL slug for the boundary set\")\n    last_updated: Optional[str] = Field(None",
        "import:fastapi.'Elections Canada')\")\n    slug: str = Field(...",
        "import:fastapi.'house-of-commons')\n        limit: Number of results per page\n        offset: Number of results to skip\n        district_name: Filter by district name\n        party_name: Filter by party name\n    \n    Returns:\n        List of representatives in the specified set\n    \"\"\"\n    try:\n        params = {\"limit\": limit",
        "import:fastapi.description=\"Representatives for centroid boundaries\")\n    representatives_concordance: List[Representative] = Field(...",
        "function:lookup_by_postal_code",
        "import:fastapi.limit: int = Query(20",
        "import:fastapi.description=\"Centroid latitude\")\n    centroid_lon: Optional[float] = Field(None",
        "import:fastapi.response_model=List[BoundarySet])\nasync def get_boundary_sets():\n    \"\"\"\n    Get available electoral boundary sets.\n    \n    Returns:\n        List of available boundary sets (federal",
        "import:fastapi.municipal)\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{REPRESENT_API_BASE}/boundary-sets/\")\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.response_model=List[Boundary])\nasync def get_boundaries(\n    boundary_set_slug: str",
        "import:fastapi.description=\"Number of results per page\")",
        "import:fastapi.ge=0",
        "import:fastapi.description=\"Last name\")\n    party_name: Optional[str] = Field(None",
        "import:fastapi.description=\"Last update timestamp\")\n\n\nclass Boundary(BaseModel):\n    \"\"\"Electoral boundary (e.g.",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=f\"Postal code {postal_code} not found\")\n        raise HTTPException(status_code=e.response.status_code"
      ]
    },
    "GET:/health": {
      "method": "GET",
      "path": "/health",
      "file": "services/api-gateway/app/api/v1/represent.py",
      "line": 229,
      "dependencies": [
        "import:fastapi.detail=f\"Failed to lookup postal code: {str(e)}\")\n\n\n@router.get(\"/geocode\"",
        "import:fastapi.description=\"Longitude\")",
        "import:fastapi.\"lon\": lon}\n        if boundary_set:\n            params[\"sets\"] = boundary_set\n            \n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{REPRESENT_API_BASE}/boundaries/\"",
        "import:fastapi.description=\"Name of the boundary\")\n    boundary_set_name: str = Field(...",
        "import:fastapi.detail=f\"Failed to lookup coordinates: {str(e)}\")",
        "import:fastapi.description=\"Authority (e.g.",
        "import:fastapi.params={\"limit\": limit",
        "import:fastapi.ge=1",
        "import:fastapi.boundary_set: Optional[str] = Query(None",
        "import:fastapi.representatives_centroid=data.get(\"representatives_centroid\"",
        "import:fastapi.specific riding or district).\"\"\"\n    name: str = Field(...",
        "import:fastapi.\"offset\": offset}\n        if district_name:\n            params[\"district_name__icontains\"] = district_name\n        if party_name:\n            params[\"party_name__icontains\"] = party_name\n            \n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{REPRESENT_API_BASE}/representatives/{representative_set_slug}/\"",
        "import:fastapi.le=100",
        "import:fastapi.lon: float = Query(...",
        "import:fastapi.'MLA')\")\n    district_name: str = Field(...",
        "import:fastapi.[])\n    except httpx.HTTPStatusError as e:\n        raise HTTPException(status_code=e.response.status_code",
        "import:fastapi.'K1A0A6')\n    \n    Returns:\n        Boundaries and representatives for the postal code\n    \"\"\"\n    # Clean postal code (remove spaces",
        "import:fastapi.[])",
        "import:fastapi.representatives_concordance=data.get(\"representatives_concordance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.Field\n\nrouter = APIRouter()\n\n# Represent API base URL\nREPRESENT_API_BASE = \"https://represent.opennorth.ca\"\n\n# Rate limiting: 60 requests per minute\nRATE_LIMIT_PER_MINUTE = 60\n\n\nclass BoundarySet(BaseModel):\n    \"\"\"Electoral boundary set (e.g.",
        "import:fastapi.response_model=List[Representative])\nasync def get_representatives(\n    representative_set_slug: str",
        "import:fastapi.description=\"Number of results to skip\")\n):\n    \"\"\"\n    Get boundaries for a specific boundary set.\n    \n    Args:\n        boundary_set_slug: Slug of the boundary set (e.g.",
        "import:fastapi.uppercase)\n    postal_code = postal_code.replace(\" \"",
        "import:fastapi.description=\"External identifier\")\n    centroid_lat: Optional[float] = Field(None",
        "import:fastapi.detail=f\"Failed to fetch boundaries: {str(e)}\")\n\n\n@router.get(\"/representatives/{representative_set_slug}\"",
        "import:fastapi.boundaries_concordance=data.get(\"boundaries_concordance\"",
        "import:fastapi.[])\n            )\n    except httpx.HTTPStatusError as e:\n        if e.response.status_code == 404:\n            raise HTTPException(status_code=404",
        "import:fastapi.description=\"Domain (e.g.",
        "import:fastapi.detail=\"Represent API error\")\n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.'MP'",
        "import:fastapi.boundaries_centroid=data.get(\"boundaries_centroid\"",
        "import:fastapi.description=\"Boundaries containing the centroid\")\n    boundaries_concordance: List[Boundary] = Field(...",
        "import:fastapi.description=\"Personal website URL\")\n\n\nclass PostalCodeLookup(BaseModel):\n    \"\"\"Postal code lookup result.\"\"\"\n    postal_code: str = Field(...",
        "import:fastapi.description=\"Number of results to skip\")",
        "function:lookup_by_coordinates",
        "import:fastapi.response_model=PostalCodeLookup)\nasync def lookup_by_postal_code(postal_code: str):\n    \"\"\"\n    Look up electoral boundaries and representatives by postal code.\n    \n    Args:\n        postal_code: Canadian postal code (e.g.",
        "import:fastapi.description=\"Full name of the representative\")\n    first_name: Optional[str] = Field(None",
        "import:fastapi.federal ridings",
        "import:fastapi.description=\"Photo URL\")\n    elected_office: str = Field(...",
        "import:fastapi.\"\").upper()\n    \n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{REPRESENT_API_BASE}/postcodes/{postal_code}/\")\n            response.raise_for_status()\n            data = response.json()\n            \n            # Transform the response to match our schema\n            return PostalCodeLookup(\n                postal_code=postal_code",
        "import:fastapi.detail=f\"Failed to fetch boundary sets: {str(e)}\")\n\n\n@router.get(\"/boundaries/{boundary_set_slug}\"",
        "import:fastapi.params=params\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.description=\"The postal code\")\n    boundaries_centroid: List[Boundary] = Field(...",
        "import:fastapi.description=\"Name of the boundary set\")\n    domain: str = Field(...",
        "import:fastapi.description=\"Name of the boundary set\")\n    external_id: str = Field(...",
        "import:fastapi.Any\nfrom pydantic import BaseModel",
        "import:fastapi.description=\"Centroid longitude\")\n    area: Optional[float] = Field(None",
        "import:fastapi.provincial districts).\"\"\"\n    name: str = Field(...",
        "import:fastapi.detail=f\"Failed to fetch representatives: {str(e)}\")\n\n\n@router.get(\"/postal-code/{postal_code}\"",
        "import:fastapi.description=\"Representatives for concordance boundaries\")\n\n\n@router.get(\"/boundary-sets\"",
        "import:fastapi.response_model=List[Boundary])\nasync def lookup_by_coordinates(\n    lat: float = Query(...",
        "import:fastapi.description=\"Boundaries linked by postal code\")\n    representatives_centroid: List[Representative] = Field(...",
        "import:fastapi.district_name: Optional[str] = Query(None",
        "import:fastapi.party_name: Optional[str] = Query(None",
        "import:fastapi.description=\"Area in square kilometers\")\n\n\nclass Representative(BaseModel):\n    \"\"\"Elected representative information.\"\"\"\n    name: str = Field(...",
        "import:fastapi.description=\"Filter by party name\")\n):\n    \"\"\"\n    Get representatives for a specific representative set.\n    \n    Args:\n        representative_set_slug: Slug of the representative set (e.g.",
        "import:fastapi.description=\"District/riding name\")\n    url: Optional[str] = Field(None",
        "import:fastapi.offset: int = Query(0",
        "import:fastapi.Optional",
        "import:fastapi.description=\"Boundary set to search in\")\n):\n    \"\"\"\n    Look up electoral boundaries by geographic coordinates.\n    \n    Args:\n        lat: Latitude\n        lon: Longitude\n        boundary_set: Optional boundary set to limit search\n    \n    Returns:\n        List of boundaries containing the coordinates\n    \"\"\"\n    try:\n        params = {\"lat\": lat",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.\"offset\": offset}\n            )\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.provincial",
        "import:fastapi.description=\"Filter by district name\")",
        "import:fastapi.description=\"Email address\")\n    photo_url: Optional[str] = Field(None",
        "import:fastapi.'federal-electoral-districts')\n        limit: Number of results per page\n        offset: Number of results to skip\n    \n    Returns:\n        List of boundaries in the specified set\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(\n                f\"{REPRESENT_API_BASE}/boundaries/{boundary_set_slug}/\"",
        "import:fastapi.description=\"Latitude\")",
        "import:fastapi.description=\"Political party name\")\n    email: Optional[str] = Field(None",
        "import:fastapi.description=\"First name\")\n    last_name: Optional[str] = Field(None",
        "import:fastapi.'ca')\")\n    authority: str = Field(...",
        "import:fastapi.description=\"Elected office (e.g.",
        "import:fastapi.description=\"URL slug for the boundary set\")\n    last_updated: Optional[str] = Field(None",
        "import:fastapi.'Elections Canada')\")\n    slug: str = Field(...",
        "import:fastapi.'house-of-commons')\n        limit: Number of results per page\n        offset: Number of results to skip\n        district_name: Filter by district name\n        party_name: Filter by party name\n    \n    Returns:\n        List of representatives in the specified set\n    \"\"\"\n    try:\n        params = {\"limit\": limit",
        "import:fastapi.description=\"Representatives for centroid boundaries\")\n    representatives_concordance: List[Representative] = Field(...",
        "import:fastapi.limit: int = Query(20",
        "import:fastapi.description=\"Centroid latitude\")\n    centroid_lon: Optional[float] = Field(None",
        "import:fastapi.response_model=List[BoundarySet])\nasync def get_boundary_sets():\n    \"\"\"\n    Get available electoral boundary sets.\n    \n    Returns:\n        List of available boundary sets (federal",
        "import:fastapi.municipal)\n    \"\"\"\n    try:\n        async with httpx.AsyncClient() as client:\n            response = await client.get(f\"{REPRESENT_API_BASE}/boundary-sets/\")\n            response.raise_for_status()\n            data = response.json()\n            return data.get(\"objects\"",
        "import:fastapi.response_model=List[Boundary])\nasync def get_boundaries(\n    boundary_set_slug: str",
        "import:fastapi.description=\"Number of results per page\")",
        "import:fastapi.ge=0",
        "import:fastapi.description=\"Last name\")\n    party_name: Optional[str] = Field(None",
        "import:fastapi.description=\"Last update timestamp\")\n\n\nclass Boundary(BaseModel):\n    \"\"\"Electoral boundary (e.g.",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.detail=f\"Postal code {postal_code} not found\")\n        raise HTTPException(status_code=e.response.status_code"
      ]
    },
    "POST:/languages": {
      "method": "POST",
      "path": "/languages",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 41,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.Translation",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Path",
        "import:fastapi.or_",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.Body",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/languages": {
      "method": "GET",
      "path": "/languages",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 92,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.Translation",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.time_format=language.time_format",
        "function:create_language",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.direction=language.direction",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.Path",
        "import:fastapi.or_",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.updated_at=language.updated_at\n    )",
        "import:fastapi.Body",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/languages/{language_id}": {
      "method": "GET",
      "path": "/languages/{language_id}",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 164,
      "dependencies": [
        "import:fastapi.desc",
        "function:list_languages",
        "import:fastapi.Translation",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.TranslationResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.direction=language.direction",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.ge=1",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.Path",
        "import:fastapi.le=100",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.total=total",
        "import:fastapi.or_",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.Body",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.HTTPException"
      ]
    },
    "PUT:/languages/{language_id}": {
      "method": "PUT",
      "path": "/languages/{language_id}",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 194,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.Translation",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "function:get_language",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.direction=language.direction",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.ge=1",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.Path",
        "import:fastapi.le=100",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.total=total",
        "import:fastapi.or_",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.updated_at=language.updated_at\n    )",
        "import:fastapi.Body",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.HTTPException"
      ]
    },
    "POST:/translations": {
      "method": "POST",
      "path": "/translations",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 246,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.ge=1",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.direction=language.direction",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.total=total",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "function:update_language",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.APIRouter"
      ]
    },
    "GET:/translations": {
      "method": "GET",
      "path": "/translations",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 299,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new translation.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == translation_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.ge=1",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.translation_notes=translation.translation_notes",
        "import:fastapi.or_",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.translation_context=translation.translation_context",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.Translation.translation_key == translation_data.translation_key",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.translation_key=translation.translation_key",
        "import:fastapi.response_model=TranslationResponse)\nasync def create_translation(\n    translation_data: TranslationCreateRequest = Body(...)",
        "import:fastapi.detail=f\"Translation with key '{translation_data.translation_key}' already exists for this language and version\"\n        )\n    \n    # Create new translation\n    translation = Translation(**translation_data.dict())\n    db.add(translation)\n    db.commit()\n    db.refresh(translation)\n    \n    logger.info(f\"Translation created: {current_user.username} - {translation_data.translation_key}\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.direction=language.direction",
        "import:fastapi.updated_at=translation.updated_at\n    )",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.is_approved=translation.is_approved",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Path",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.created_at=translation.created_at",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.language_id=str(translation.language_id)",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/translations\"",
        "function:create_translation",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if translation key already exists for this language and version\n    existing_translation = db.query(Translation).filter(\n        and_(\n            Translation.language_id == translation_data.language_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.total=total",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.Translation.version == translation_data.version\n        )\n    ).first()\n    \n    if existing_translation:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.approved_by=translation.approved_by",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.approved_at=translation.approved_at",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.translation_value=translation.translation_value",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.version=translation.version",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.APIRouter"
      ]
    },
    "GET:/translations/{translation_id}": {
      "method": "GET",
      "path": "/translations/{translation_id}",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 378,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by translation key\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new translation.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == translation_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.ge=1",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.description=\"Search in translation values\")",
        "import:fastapi.translation_notes=translation.translation_notes",
        "import:fastapi.or_",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.translation_context=translation.translation_context",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.Translation.translation_key == translation_data.translation_key",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.language_id: Optional[str] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.translation_key=translation.translation_key",
        "import:fastapi.description=\"Filter by language ID\")",
        "import:fastapi.response_model=TranslationResponse)\nasync def create_translation(\n    translation_data: TranslationCreateRequest = Body(...)",
        "function:list_translations",
        "import:fastapi.detail=f\"Translation with key '{translation_data.translation_key}' already exists for this language and version\"\n        )\n    \n    # Create new translation\n    translation = Translation(**translation_data.dict())\n    db.add(translation)\n    db.commit()\n    db.refresh(translation)\n    \n    logger.info(f\"Translation created: {current_user.username} - {translation_data.translation_key}\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.direction=language.direction",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.is_approved=translation.is_approved",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n@router.get(\"/translations\"",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Translation.translation_context.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get translations\n    translations = query.order_by(Translation.translation_key).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    translation_responses = []\n    for translation in translations:\n        translation_responses.append(TranslationResponse(\n            id=str(translation.id)",
        "import:fastapi.Path",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List translations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Translation)\n    \n    # Apply filters\n    if language_id:\n        query = query.filter(Translation.language_id == language_id)\n    \n    if translation_key:\n        query = query.filter(Translation.translation_key == translation_key)\n    \n    if context:\n        query = query.filter(Translation.translation_context == context)\n    \n    if is_approved is not None:\n        query = query.filter(Translation.is_approved == is_approved)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Translation.translation_value.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.updated_at=translation.updated_at\n        ))\n    \n    return TranslationListResponse(\n        translations=translation_responses",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.created_at=translation.created_at",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.language_id=str(translation.language_id)",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.context: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/translations\"",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if translation key already exists for this language and version\n    existing_translation = db.query(Translation).filter(\n        and_(\n            Translation.language_id == translation_data.language_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by context\")",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.description=\"Filter by approval status\")",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.is_approved: Optional[bool] = Query(None",
        "import:fastapi.Translation.version == translation_data.version\n        )\n    ).first()\n    \n    if existing_translation:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.approved_by=translation.approved_by",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.approved_at=translation.approved_at",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.translation_value=translation.translation_value",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.version=translation.version",
        "import:fastapi.translation_key: Optional[str] = Query(None",
        "import:fastapi.response_model=TranslationListResponse)\nasync def list_translations(\n    page: int = Query(1",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.APIRouter",
        "import:fastapi.Translation.translation_key.ilike(search_term)"
      ]
    },
    "POST:/users/preferences": {
      "method": "POST",
      "path": "/users/preferences",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 411,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by translation key\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new translation.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == translation_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n# ============================================================================\n# USER LANGUAGE PREFERENCES\n# ============================================================================",
        "import:fastapi.ge=1",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.description=\"Search in translation values\")",
        "import:fastapi.translation_notes=translation.translation_notes",
        "import:fastapi.or_",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.translation_context=translation.translation_context",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.Translation.translation_key == translation_data.translation_key",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.language_id: Optional[str] = Query(None",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.translation_key=translation.translation_key",
        "import:fastapi.description=\"Filter by language ID\")",
        "function:get_translation",
        "import:fastapi.response_model=TranslationResponse)\nasync def create_translation(\n    translation_data: TranslationCreateRequest = Body(...)",
        "import:fastapi.detail=f\"Translation with key '{translation_data.translation_key}' already exists for this language and version\"\n        )\n    \n    # Create new translation\n    translation = Translation(**translation_data.dict())\n    db.add(translation)\n    db.commit()\n    db.refresh(translation)\n    \n    logger.info(f\"Translation created: {current_user.username} - {translation_data.translation_key}\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.direction=language.direction",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.is_approved=translation.is_approved",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n@router.get(\"/translations\"",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Translation.translation_context.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get translations\n    translations = query.order_by(Translation.translation_key).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    translation_responses = []\n    for translation in translations:\n        translation_responses.append(TranslationResponse(\n            id=str(translation.id)",
        "import:fastapi.Path",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List translations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Translation)\n    \n    # Apply filters\n    if language_id:\n        query = query.filter(Translation.language_id == language_id)\n    \n    if translation_key:\n        query = query.filter(Translation.translation_key == translation_key)\n    \n    if context:\n        query = query.filter(Translation.translation_context == context)\n    \n    if is_approved is not None:\n        query = query.filter(Translation.is_approved == is_approved)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Translation.translation_value.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.updated_at=translation.updated_at\n        ))\n    \n    return TranslationListResponse(\n        translations=translation_responses",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.created_at=translation.created_at",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.response_model=TranslationResponse)\nasync def get_translation(\n    translation_id: str = Path(...",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.language_id=str(translation.language_id)",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/translations/{translation_id}\"",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.context: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/translations\"",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if translation key already exists for this language and version\n    existing_translation = db.query(Translation).filter(\n        and_(\n            Translation.language_id == translation_data.language_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by context\")",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.description=\"Filter by approval status\")",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.is_approved: Optional[bool] = Query(None",
        "import:fastapi.Translation.version == translation_data.version\n        )\n    ).first()\n    \n    if existing_translation:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"Translation not found\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Translation ID\")",
        "import:fastapi.approved_by=translation.approved_by",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific translation by ID.\n    \"\"\"\n    translation = db.query(Translation).filter(Translation.id == translation_id).first()\n    \n    if not translation:\n        raise HTTPException(status_code=404",
        "import:fastapi.approved_at=translation.approved_at",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.translation_value=translation.translation_value",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.version=translation.version",
        "import:fastapi.translation_key: Optional[str] = Query(None",
        "import:fastapi.response_model=TranslationListResponse)\nasync def list_translations(\n    page: int = Query(1",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.APIRouter",
        "import:fastapi.Translation.translation_key.ilike(search_term)"
      ]
    },
    "GET:/users/preferences": {
      "method": "GET",
      "path": "/users/preferences",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 478,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by translation key\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new translation.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == translation_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.ge=1",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.description=\"Search in translation values\")",
        "import:fastapi.translation_notes=translation.translation_notes",
        "import:fastapi.or_",
        "import:fastapi.is_primary=preference.is_primary",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.translation_context=translation.translation_context",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.Translation.translation_key == translation_data.translation_key",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.user_id=str(preference.user_id)",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.language_id: Optional[str] = Query(None",
        "import:fastapi.is_primary=existing_preference.is_primary",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.translation_key=translation.translation_key",
        "import:fastapi.description=\"Filter by language ID\")",
        "import:fastapi.response_model=TranslationResponse)\nasync def create_translation(\n    translation_data: TranslationCreateRequest = Body(...)",
        "import:fastapi.detail=f\"Translation with key '{translation_data.translation_key}' already exists for this language and version\"\n        )\n    \n    # Create new translation\n    translation = Translation(**translation_data.dict())\n    db.add(translation)\n    db.commit()\n    db.refresh(translation)\n    \n    logger.info(f\"Translation created: {current_user.username} - {translation_data.translation_key}\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.direction=language.direction",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.is_approved=translation.is_approved",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n@router.get(\"/translations\"",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Translation.translation_context.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get translations\n    translations = query.order_by(Translation.translation_key).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    translation_responses = []\n    for translation in translations:\n        translation_responses.append(TranslationResponse(\n            id=str(translation.id)",
        "import:fastapi.Path",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List translations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Translation)\n    \n    # Apply filters\n    if language_id:\n        query = query.filter(Translation.language_id == language_id)\n    \n    if translation_key:\n        query = query.filter(Translation.translation_key == translation_key)\n    \n    if context:\n        query = query.filter(Translation.translation_context == context)\n    \n    if is_approved is not None:\n        query = query.filter(Translation.is_approved == is_approved)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Translation.translation_value.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.updated_at=translation.updated_at\n        ))\n    \n    return TranslationListResponse(\n        translations=translation_responses",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.UserLanguagePreference.language_id == preference_data.language_id\n        )\n    ).first()\n    \n    if existing_preference:\n        # Update existing preference\n        update_data = preference_data.dict(exclude_unset=True)\n        for field",
        "import:fastapi.created_at=preference.created_at",
        "import:fastapi.is_secondary=existing_preference.is_secondary",
        "import:fastapi.created_at=translation.created_at",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.is_secondary=preference.is_secondary",
        "function:create_user_language_preference",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.response_model=TranslationResponse)\nasync def get_translation(\n    translation_id: str = Path(...",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.language_id=str(translation.language_id)",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n# ============================================================================\n# USER LANGUAGE PREFERENCES\n# ============================================================================\n\n@router.post(\"/users/preferences\"",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.field):\n                setattr(existing_preference",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/translations/{translation_id}\"",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.context: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/translations\"",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if translation key already exists for this language and version\n    existing_translation = db.query(Translation).filter(\n        and_(\n            Translation.language_id == translation_data.language_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.updated_at=preference.updated_at\n    )",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by context\")",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.value)\n        \n        existing_preference.updated_at = datetime.utcnow()\n        db.commit()\n        db.refresh(existing_preference)\n        \n        logger.info(f\"User language preference updated: {current_user.username} - {language.language_code}\")\n        \n        return UserLanguagePreferenceResponse(\n            id=str(existing_preference.id)",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.description=\"Filter by approval status\")",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.is_approved: Optional[bool] = Query(None",
        "import:fastapi.Translation.version == translation_data.version\n        )\n    ).first()\n    \n    if existing_translation:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.response_model=UserLanguagePreferenceResponse)\nasync def create_user_language_preference(\n    preference_data: UserLanguagePreferenceCreateRequest = Body(...)",
        "import:fastapi.proficiency_level=existing_preference.proficiency_level",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.language_id=str(preference.language_id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.value in update_data.items():\n            if hasattr(existing_preference",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"Translation not found\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.language_id=str(existing_preference.language_id)",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if preference already exists\n    existing_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.proficiency_level=preference.proficiency_level",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Translation ID\")",
        "import:fastapi.approved_by=translation.approved_by",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific translation by ID.\n    \"\"\"\n    translation = db.query(Translation).filter(Translation.id == translation_id).first()\n    \n    if not translation:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=existing_preference.updated_at\n        )\n    \n    # Create new preference\n    preference = UserLanguagePreference(**preference_data.dict())\n    preference.user_id = current_user.id\n    db.add(preference)\n    db.commit()\n    db.refresh(preference)\n    \n    logger.info(f\"User language preference created: {current_user.username} - {language.language_code}\")\n    \n    return UserLanguagePreferenceResponse(\n        id=str(preference.id)",
        "import:fastapi.approved_at=translation.approved_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create or update user language preference.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == preference_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.translation_value=translation.translation_value",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.version=translation.version",
        "import:fastapi.user_id=str(existing_preference.user_id)",
        "import:fastapi.translation_key: Optional[str] = Query(None",
        "import:fastapi.response_model=TranslationListResponse)\nasync def list_translations(\n    page: int = Query(1",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.created_at=existing_preference.created_at",
        "import:fastapi.APIRouter",
        "import:fastapi.Translation.translation_key.ilike(search_term)"
      ]
    },
    "POST:/toggle": {
      "method": "POST",
      "path": "/toggle",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 518,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by translation key\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.total_pages=1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new translation.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == translation_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.ge=1",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.description=\"Search in translation values\")",
        "import:fastapi.translation_notes=translation.translation_notes",
        "import:fastapi.or_",
        "import:fastapi.is_primary=preference.is_primary",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.translation_context=translation.translation_context",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.Translation.translation_key == translation_data.translation_key",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.user_id=str(preference.user_id)",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.language_id: Optional[str] = Query(None",
        "import:fastapi.is_primary=existing_preference.is_primary",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.translation_key=translation.translation_key",
        "import:fastapi.response_model=UserLanguagePreferenceListResponse)\nasync def get_user_language_preferences(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by language ID\")",
        "import:fastapi.has_prev=False\n    )\n\n\n# ============================================================================\n# LANGUAGE TOGGLE AND SWITCHING\n# ============================================================================",
        "import:fastapi.updated_at=preference.updated_at\n        ))\n    \n    return UserLanguagePreferenceListResponse(\n        preferences=preference_responses",
        "import:fastapi.response_model=TranslationResponse)\nasync def create_translation(\n    translation_data: TranslationCreateRequest = Body(...)",
        "import:fastapi.detail=f\"Translation with key '{translation_data.translation_key}' already exists for this language and version\"\n        )\n    \n    # Create new translation\n    translation = Translation(**translation_data.dict())\n    db.add(translation)\n    db.commit()\n    db.refresh(translation)\n    \n    logger.info(f\"Translation created: {current_user.username} - {translation_data.translation_key}\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.direction=language.direction",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.page_size=len(preference_responses)",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.is_approved=translation.is_approved",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n@router.get(\"/translations\"",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Translation.translation_context.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get translations\n    translations = query.order_by(Translation.translation_key).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    translation_responses = []\n    for translation in translations:\n        translation_responses.append(TranslationResponse(\n            id=str(translation.id)",
        "import:fastapi.Path",
        "function:get_user_language_preferences",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List translations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Translation)\n    \n    # Apply filters\n    if language_id:\n        query = query.filter(Translation.language_id == language_id)\n    \n    if translation_key:\n        query = query.filter(Translation.translation_key == translation_key)\n    \n    if context:\n        query = query.filter(Translation.translation_context == context)\n    \n    if is_approved is not None:\n        query = query.filter(Translation.is_approved == is_approved)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Translation.translation_value.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.updated_at=preference.updated_at\n    )\n\n\n@router.get(\"/users/preferences\"",
        "import:fastapi.updated_at=translation.updated_at\n        ))\n    \n    return TranslationListResponse(\n        translations=translation_responses",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.UserLanguagePreference.language_id == preference_data.language_id\n        )\n    ).first()\n    \n    if existing_preference:\n        # Update existing preference\n        update_data = preference_data.dict(exclude_unset=True)\n        for field",
        "import:fastapi.created_at=preference.created_at",
        "import:fastapi.total=len(preference_responses)",
        "import:fastapi.is_secondary=existing_preference.is_secondary",
        "import:fastapi.created_at=translation.created_at",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.is_secondary=preference.is_secondary",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.response_model=TranslationResponse)\nasync def get_translation(\n    translation_id: str = Path(...",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.language_id=str(translation.language_id)",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n# ============================================================================\n# USER LANGUAGE PREFERENCES\n# ============================================================================\n\n@router.post(\"/users/preferences\"",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.field):\n                setattr(existing_preference",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.has_next=False",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/translations/{translation_id}\"",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.context: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/translations\"",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if translation key already exists for this language and version\n    existing_translation = db.query(Translation).filter(\n        and_(\n            Translation.language_id == translation_data.language_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get current user's language preferences.\n    \"\"\"\n    preferences = db.query(UserLanguagePreference).filter(\n        UserLanguagePreference.user_id == current_user.id\n    ).all()\n    \n    preference_responses = []\n    for preference in preferences:\n        preference_responses.append(UserLanguagePreferenceResponse(\n            id=str(preference.id)",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by context\")",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.value)\n        \n        existing_preference.updated_at = datetime.utcnow()\n        db.commit()\n        db.refresh(existing_preference)\n        \n        logger.info(f\"User language preference updated: {current_user.username} - {language.language_code}\")\n        \n        return UserLanguagePreferenceResponse(\n            id=str(existing_preference.id)",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.description=\"Filter by approval status\")",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.is_approved: Optional[bool] = Query(None",
        "import:fastapi.Translation.version == translation_data.version\n        )\n    ).first()\n    \n    if existing_translation:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.response_model=UserLanguagePreferenceResponse)\nasync def create_user_language_preference(\n    preference_data: UserLanguagePreferenceCreateRequest = Body(...)",
        "import:fastapi.proficiency_level=existing_preference.proficiency_level",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.language_id=str(preference.language_id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.value in update_data.items():\n            if hasattr(existing_preference",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"Translation not found\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.language_id=str(existing_preference.language_id)",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if preference already exists\n    existing_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.proficiency_level=preference.proficiency_level",
        "import:fastapi.page=1",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Translation ID\")",
        "import:fastapi.approved_by=translation.approved_by",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific translation by ID.\n    \"\"\"\n    translation = db.query(Translation).filter(Translation.id == translation_id).first()\n    \n    if not translation:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=existing_preference.updated_at\n        )\n    \n    # Create new preference\n    preference = UserLanguagePreference(**preference_data.dict())\n    preference.user_id = current_user.id\n    db.add(preference)\n    db.commit()\n    db.refresh(preference)\n    \n    logger.info(f\"User language preference created: {current_user.username} - {language.language_code}\")\n    \n    return UserLanguagePreferenceResponse(\n        id=str(preference.id)",
        "import:fastapi.approved_at=translation.approved_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create or update user language preference.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == preference_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.translation_value=translation.translation_value",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.version=translation.version",
        "import:fastapi.user_id=str(existing_preference.user_id)",
        "import:fastapi.translation_key: Optional[str] = Query(None",
        "import:fastapi.response_model=TranslationListResponse)\nasync def list_translations(\n    page: int = Query(1",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.created_at=existing_preference.created_at",
        "import:fastapi.APIRouter",
        "import:fastapi.Translation.translation_key.ilike(search_term)"
      ]
    },
    "GET:/current": {
      "method": "GET",
      "path": "/current",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 600,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by translation key\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.request: Request = None",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.total_pages=1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new translation.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == translation_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.ge=1",
        "import:fastapi.language_id=language.id",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.description=\"Search in translation values\")",
        "import:fastapi.\"language_code\": language.language_code",
        "import:fastapi.translation_notes=translation.translation_notes",
        "import:fastapi.or_",
        "import:fastapi.is_primary=preference.is_primary",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.translation_context=translation.translation_context",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.Translation.translation_key == translation_data.translation_key",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.user_id=str(preference.user_id)",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.language_id: Optional[str] = Query(None",
        "import:fastapi.is_primary=existing_preference.is_primary",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.translation_key=translation.translation_key",
        "import:fastapi.UserLanguagePreference.language_id == language.id\n        )\n    ).first()\n    \n    if existing_preference:\n        # Update existing preference\n        existing_preference.is_primary = True\n        existing_preference.updated_at = datetime.utcnow()\n        \n        # Set other preferences as secondary\n        db.query(UserLanguagePreference).filter(\n            and_(\n                UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.response_model=UserLanguagePreferenceListResponse)\nasync def get_user_language_preferences(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by language ID\")",
        "import:fastapi.\"is_secondary\": True})\n    \n    db.commit()\n    \n    # Track language usage analytics\n    _track_language_usage(db",
        "import:fastapi.\"time_format\": language.time_format",
        "import:fastapi.updated_at=preference.updated_at\n        ))\n    \n    return UserLanguagePreferenceListResponse(\n        preferences=preference_responses",
        "import:fastapi.response_model=TranslationResponse)\nasync def create_translation(\n    translation_data: TranslationCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Toggle user's interface language.\n    \n    This is the main endpoint for the French/English language toggle feature.\n    \"\"\"\n    # Get language by code\n    language = db.query(Language).filter(\n        and_(\n            Language.language_code == toggle_data.language_code",
        "import:fastapi.detail=f\"Translation with key '{translation_data.translation_key}' already exists for this language and version\"\n        )\n    \n    # Create new translation\n    translation = Translation(**translation_data.dict())\n    db.add(translation)\n    db.commit()\n    db.refresh(translation)\n    \n    logger.info(f\"Translation created: {current_user.username} - {translation_data.translation_key}\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.direction=language.direction",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.\"is_secondary\": True})\n    else:\n        # Create new preference\n        new_preference = UserLanguagePreference(\n            user_id=current_user.id",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.page_size=len(preference_responses)",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.is_approved=translation.is_approved",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n@router.get(\"/translations\"",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Translation.translation_context.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get translations\n    translations = query.order_by(Translation.translation_key).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    translation_responses = []\n    for translation in translations:\n        translation_responses.append(TranslationResponse(\n            id=str(translation.id)",
        "import:fastapi.has_prev=False\n    )\n\n\n# ============================================================================\n# LANGUAGE TOGGLE AND SWITCHING\n# ============================================================================\n\n@router.post(\"/toggle\")\nasync def toggle_user_language(\n    toggle_data: LanguageToggleRequest = Body(...)",
        "import:fastapi.Path",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.is_primary=True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List translations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Translation)\n    \n    # Apply filters\n    if language_id:\n        query = query.filter(Translation.language_id == language_id)\n    \n    if translation_key:\n        query = query.filter(Translation.translation_key == translation_key)\n    \n    if context:\n        query = query.filter(Translation.translation_context == context)\n    \n    if is_approved is not None:\n        query = query.filter(Translation.is_approved == is_approved)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Translation.translation_value.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.UserLanguagePreference.id != existing_preference.id\n            )\n        ).update({\"is_primary\": False",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.updated_at=preference.updated_at\n    )\n\n\n@router.get(\"/users/preferences\"",
        "import:fastapi.updated_at=translation.updated_at\n        ))\n    \n    return TranslationListResponse(\n        translations=translation_responses",
        "import:fastapi.\"date_format\": language.date_format",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.current_user.id)\n    \n    logger.info(f\"User language toggled: {current_user.username} - {toggle_data.language_code}\")\n    \n    return {\n        \"message\": f\"Language switched to {language.language_name_native}\"",
        "import:fastapi.UserLanguagePreference.language_id == preference_data.language_id\n        )\n    ).first()\n    \n    if existing_preference:\n        # Update existing preference\n        update_data = preference_data.dict(exclude_unset=True)\n        for field",
        "import:fastapi.created_at=preference.created_at",
        "import:fastapi.total=len(preference_responses)",
        "import:fastapi.\"language_name_native\": language.language_name_native",
        "import:fastapi.is_secondary=existing_preference.is_secondary",
        "import:fastapi.created_at=translation.created_at",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.is_secondary=preference.is_secondary",
        "import:fastapi.detail=f\"Language '{toggle_data.language_code}' not found or not active\"\n        )\n    \n    # Update or create user preference\n    existing_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.response_model=TranslationResponse)\nasync def get_translation(\n    translation_id: str = Path(...",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.language_id=str(translation.language_id)",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n# ============================================================================\n# USER LANGUAGE PREFERENCES\n# ============================================================================\n\n@router.post(\"/users/preferences\"",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.is_secondary=False",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.field):\n                setattr(existing_preference",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.has_next=False",
        "import:fastapi.proficiency_level=\"fluent\"\n        )\n        db.add(new_preference)\n        \n        # Set other preferences as secondary\n        db.query(UserLanguagePreference).filter(\n            UserLanguagePreference.user_id == current_user.id\n        ).update({\"is_primary\": False",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/translations/{translation_id}\"",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.context: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/translations\"",
        "import:fastapi.\"currency_code\": language.currency_code\n    }",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if translation key already exists for this language and version\n    existing_translation = db.query(Translation).filter(\n        and_(\n            Translation.language_id == translation_data.language_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get current user's language preferences.\n    \"\"\"\n    preferences = db.query(UserLanguagePreference).filter(\n        UserLanguagePreference.user_id == current_user.id\n    ).all()\n    \n    preference_responses = []\n    for preference in preferences:\n        preference_responses.append(UserLanguagePreferenceResponse(\n            id=str(preference.id)",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by context\")",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.value)\n        \n        existing_preference.updated_at = datetime.utcnow()\n        db.commit()\n        db.refresh(existing_preference)\n        \n        logger.info(f\"User language preference updated: {current_user.username} - {language.language_code}\")\n        \n        return UserLanguagePreferenceResponse(\n            id=str(existing_preference.id)",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.Language.is_active == True\n        )\n    ).first()\n    \n    if not language:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.language.id",
        "import:fastapi.description=\"Filter by approval status\")",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.is_approved: Optional[bool] = Query(None",
        "import:fastapi.Translation.version == translation_data.version\n        )\n    ).first()\n    \n    if existing_translation:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.response_model=UserLanguagePreferenceResponse)\nasync def create_user_language_preference(\n    preference_data: UserLanguagePreferenceCreateRequest = Body(...)",
        "import:fastapi.proficiency_level=existing_preference.proficiency_level",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.language_id=str(preference.language_id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.value in update_data.items():\n            if hasattr(existing_preference",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.\"number_format\": language.number_format",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"Translation not found\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.language_id=str(existing_preference.language_id)",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if preference already exists\n    existing_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.proficiency_level=preference.proficiency_level",
        "import:fastapi.page=1",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Translation ID\")",
        "import:fastapi.approved_by=translation.approved_by",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.\"language_name\": language.language_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific translation by ID.\n    \"\"\"\n    translation = db.query(Translation).filter(Translation.id == translation_id).first()\n    \n    if not translation:\n        raise HTTPException(status_code=404",
        "function:toggle_user_language",
        "import:fastapi.updated_at=existing_preference.updated_at\n        )\n    \n    # Create new preference\n    preference = UserLanguagePreference(**preference_data.dict())\n    preference.user_id = current_user.id\n    db.add(preference)\n    db.commit()\n    db.refresh(preference)\n    \n    logger.info(f\"User language preference created: {current_user.username} - {language.language_code}\")\n    \n    return UserLanguagePreferenceResponse(\n        id=str(preference.id)",
        "import:fastapi.approved_at=translation.approved_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create or update user language preference.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == preference_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.translation_value=translation.translation_value",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.version=translation.version",
        "import:fastapi.user_id=str(existing_preference.user_id)",
        "import:fastapi.translation_key: Optional[str] = Query(None",
        "import:fastapi.response_model=TranslationListResponse)\nasync def list_translations(\n    page: int = Query(1",
        "import:fastapi.\"direction\": language.direction",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.created_at=existing_preference.created_at",
        "import:fastapi.APIRouter",
        "import:fastapi.Translation.translation_key.ilike(search_term)"
      ]
    },
    "GET:/translate/{translation_key}": {
      "method": "GET",
      "path": "/translate/{translation_key}",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 655,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by translation key\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.\"is_default\": language.is_default",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.request: Request = None",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.total_pages=1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new translation.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == translation_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"number_format\": default_language.number_format",
        "import:fastapi.ge=1",
        "import:fastapi.language_id=language.id",
        "import:fastapi.\"currency_code\": default_language.currency_code\n        }\n    \n    # Get language details\n    language = db.query(Language).filter(Language.id == primary_preference.language_id).first()\n    \n    return {\n        \"language_code\": language.language_code",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.description=\"Search in translation values\")",
        "import:fastapi.\"language_code\": language.language_code",
        "import:fastapi.translation_notes=translation.translation_notes",
        "import:fastapi.\"is_default\": True",
        "import:fastapi.or_",
        "import:fastapi.is_primary=preference.is_primary",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.translation_context=translation.translation_context",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.Translation.translation_key == translation_data.translation_key",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.user_id=str(preference.user_id)",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.language_id: Optional[str] = Query(None",
        "import:fastapi.is_primary=existing_preference.is_primary",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.translation_key=translation.translation_key",
        "import:fastapi.UserLanguagePreference.language_id == language.id\n        )\n    ).first()\n    \n    if existing_preference:\n        # Update existing preference\n        existing_preference.is_primary = True\n        existing_preference.updated_at = datetime.utcnow()\n        \n        # Set other preferences as secondary\n        db.query(UserLanguagePreference).filter(\n            and_(\n                UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.response_model=UserLanguagePreferenceListResponse)\nasync def get_user_language_preferences(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by language ID\")",
        "import:fastapi.\"is_secondary\": True})\n    \n    db.commit()\n    \n    # Track language usage analytics\n    _track_language_usage(db",
        "import:fastapi.\"time_format\": language.time_format",
        "import:fastapi.updated_at=preference.updated_at\n        ))\n    \n    return UserLanguagePreferenceListResponse(\n        preferences=preference_responses",
        "import:fastapi.response_model=TranslationResponse)\nasync def create_translation(\n    translation_data: TranslationCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Toggle user's interface language.\n    \n    This is the main endpoint for the French/English language toggle feature.\n    \"\"\"\n    # Get language by code\n    language = db.query(Language).filter(\n        and_(\n            Language.language_code == toggle_data.language_code",
        "import:fastapi.detail=f\"Translation with key '{translation_data.translation_key}' already exists for this language and version\"\n        )\n    \n    # Create new translation\n    translation = Translation(**translation_data.dict())\n    db.add(translation)\n    db.commit()\n    db.refresh(translation)\n    \n    logger.info(f\"Translation created: {current_user.username} - {translation_data.translation_key}\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "function:get_current_user_language",
        "import:fastapi.direction=language.direction",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.\"is_secondary\": True})\n    else:\n        # Create new preference\n        new_preference = UserLanguagePreference(\n            user_id=current_user.id",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.page_size=len(preference_responses)",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.is_approved=translation.is_approved",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n@router.get(\"/translations\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get current user's active language preference.\n    \"\"\"\n    # Get primary language preference\n    primary_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Translation.translation_context.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get translations\n    translations = query.order_by(Translation.translation_key).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    translation_responses = []\n    for translation in translations:\n        translation_responses.append(TranslationResponse(\n            id=str(translation.id)",
        "import:fastapi.has_prev=False\n    )\n\n\n# ============================================================================\n# LANGUAGE TOGGLE AND SWITCHING\n# ============================================================================\n\n@router.post(\"/toggle\")\nasync def toggle_user_language(\n    toggle_data: LanguageToggleRequest = Body(...)",
        "import:fastapi.Path",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.is_primary=True",
        "import:fastapi.\"proficiency_level\": primary_preference.proficiency_level\n    }\n\n\n# ============================================================================\n# TRANSLATION UTILITIES\n# ============================================================================",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List translations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Translation)\n    \n    # Apply filters\n    if language_id:\n        query = query.filter(Translation.language_id == language_id)\n    \n    if translation_key:\n        query = query.filter(Translation.translation_key == translation_key)\n    \n    if context:\n        query = query.filter(Translation.translation_context == context)\n    \n    if is_approved is not None:\n        query = query.filter(Translation.is_approved == is_approved)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Translation.translation_value.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.UserLanguagePreference.id != existing_preference.id\n            )\n        ).update({\"is_primary\": False",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.updated_at=preference.updated_at\n    )\n\n\n@router.get(\"/users/preferences\"",
        "import:fastapi.updated_at=translation.updated_at\n        ))\n    \n    return TranslationListResponse(\n        translations=translation_responses",
        "import:fastapi.\"date_format\": language.date_format",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.current_user.id)\n    \n    logger.info(f\"User language toggled: {current_user.username} - {toggle_data.language_code}\")\n    \n    return {\n        \"message\": f\"Language switched to {language.language_name_native}\"",
        "import:fastapi.UserLanguagePreference.language_id == preference_data.language_id\n        )\n    ).first()\n    \n    if existing_preference:\n        # Update existing preference\n        update_data = preference_data.dict(exclude_unset=True)\n        for field",
        "import:fastapi.created_at=preference.created_at",
        "import:fastapi.total=len(preference_responses)",
        "import:fastapi.\"language_name_native\": language.language_name_native",
        "import:fastapi.is_secondary=existing_preference.is_secondary",
        "import:fastapi.created_at=translation.created_at",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.is_secondary=preference.is_secondary",
        "import:fastapi.detail=f\"Language '{toggle_data.language_code}' not found or not active\"\n        )\n    \n    # Update or create user preference\n    existing_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.response_model=TranslationResponse)\nasync def get_translation(\n    translation_id: str = Path(...",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.language_id=str(translation.language_id)",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n# ============================================================================\n# USER LANGUAGE PREFERENCES\n# ============================================================================\n\n@router.post(\"/users/preferences\"",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.is_secondary=False",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.field):\n                setattr(existing_preference",
        "import:fastapi.currency_code=language.currency_code",
        "import:fastapi.has_next=False",
        "import:fastapi.proficiency_level=\"fluent\"\n        )\n        db.add(new_preference)\n        \n        # Set other preferences as secondary\n        db.query(UserLanguagePreference).filter(\n            UserLanguagePreference.user_id == current_user.id\n        ).update({\"is_primary\": False",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/translations/{translation_id}\"",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.context: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/translations\"",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if translation key already exists for this language and version\n    existing_translation = db.query(Translation).filter(\n        and_(\n            Translation.language_id == translation_data.language_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get current user's language preferences.\n    \"\"\"\n    preferences = db.query(UserLanguagePreference).filter(\n        UserLanguagePreference.user_id == current_user.id\n    ).all()\n    \n    preference_responses = []\n    for preference in preferences:\n        preference_responses.append(UserLanguagePreferenceResponse(\n            id=str(preference.id)",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by context\")",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.UserLanguagePreference.is_primary == True\n        )\n    ).first()\n    \n    if not primary_preference:\n        # Get default language\n        default_language = db.query(Language).filter(Language.is_default == True).first()\n        if not default_language:\n            default_language = db.query(Language).filter(Language.language_code == \"en\").first()\n        \n        return {\n            \"language_code\": default_language.language_code",
        "import:fastapi.value)\n        \n        existing_preference.updated_at = datetime.utcnow()\n        db.commit()\n        db.refresh(existing_preference)\n        \n        logger.info(f\"User language preference updated: {current_user.username} - {language.language_code}\")\n        \n        return UserLanguagePreferenceResponse(\n            id=str(existing_preference.id)",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.Language.is_active == True\n        )\n    ).first()\n    \n    if not language:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.language.id",
        "import:fastapi.\"currency_code\": language.currency_code\n    }\n\n\n@router.get(\"/current\")\nasync def get_current_user_language(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by approval status\")",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.is_approved: Optional[bool] = Query(None",
        "import:fastapi.\"direction\": default_language.direction",
        "import:fastapi.Translation.version == translation_data.version\n        )\n    ).first()\n    \n    if existing_translation:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.response_model=UserLanguagePreferenceResponse)\nasync def create_user_language_preference(\n    preference_data: UserLanguagePreferenceCreateRequest = Body(...)",
        "import:fastapi.proficiency_level=existing_preference.proficiency_level",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.language_id=str(preference.language_id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.value in update_data.items():\n            if hasattr(existing_preference",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.\"number_format\": language.number_format",
        "import:fastapi.\"language_name_native\": default_language.language_name_native",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"Translation not found\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.language_id=str(existing_preference.language_id)",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if preference already exists\n    existing_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.\"language_name\": default_language.language_name",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.proficiency_level=preference.proficiency_level",
        "import:fastapi.page=1",
        "import:fastapi.\"currency_code\": language.currency_code",
        "import:fastapi.\"date_format\": default_language.date_format",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Translation ID\")",
        "import:fastapi.approved_by=translation.approved_by",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.\"language_name\": language.language_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific translation by ID.\n    \"\"\"\n    translation = db.query(Translation).filter(Translation.id == translation_id).first()\n    \n    if not translation:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=existing_preference.updated_at\n        )\n    \n    # Create new preference\n    preference = UserLanguagePreference(**preference_data.dict())\n    preference.user_id = current_user.id\n    db.add(preference)\n    db.commit()\n    db.refresh(preference)\n    \n    logger.info(f\"User language preference created: {current_user.username} - {language.language_code}\")\n    \n    return UserLanguagePreferenceResponse(\n        id=str(preference.id)",
        "import:fastapi.approved_at=translation.approved_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create or update user language preference.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == preference_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.translation_value=translation.translation_value",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.version=translation.version",
        "import:fastapi.user_id=str(existing_preference.user_id)",
        "import:fastapi.translation_key: Optional[str] = Query(None",
        "import:fastapi.response_model=TranslationListResponse)\nasync def list_translations(\n    page: int = Query(1",
        "import:fastapi.\"direction\": language.direction",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.\"time_format\": default_language.time_format",
        "import:fastapi.created_at=existing_preference.created_at",
        "import:fastapi.APIRouter",
        "import:fastapi.Translation.translation_key.ilike(search_term)"
      ]
    },
    "POST:/translate/search": {
      "method": "POST",
      "path": "/translate/search",
      "file": "services/api-gateway/app/api/v1/language_support.py",
      "line": 733,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.LanguageAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.language_support import (\n    LanguageResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.TranslationResponse",
        "import:fastapi.LanguageStatistics",
        "import:fastapi.\"version\": translation.version\n    }",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by translation key\")",
        "import:fastapi.language_name=language.language_name",
        "import:fastapi.response_model=LanguageResponse)\nasync def create_language(\n    language_data: LanguageCreateRequest = Body(...)",
        "import:fastapi.LanguageToggleRequest",
        "import:fastapi.Request\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.\"is_default\": language.is_default",
        "import:fastapi.UserLanguagePreference",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.request: Request = None",
        "import:fastapi.UserLanguagePreferenceCreateRequest",
        "import:fastapi.language_code: LanguageCodeEnum = Query(...",
        "import:fastapi.total_pages=1",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new translation.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == translation_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"number_format\": default_language.number_format",
        "import:fastapi.ge=1",
        "import:fastapi.language_id=language.id",
        "import:fastapi.\"currency_code\": default_language.currency_code\n        }\n    \n    # Get language details\n    language = db.query(Language).filter(Language.id == primary_preference.language_id).first()\n    \n    return {\n        \"language_code\": language.language_code",
        "import:fastapi.func\nfrom typing import Optional\nfrom datetime import datetime\nimport math\n\nfrom app.database import get_db\nfrom app.models.language_support import (\n    Language",
        "import:fastapi.field):\n            setattr(language",
        "import:fastapi.TranslationSearchRequest",
        "import:fastapi.le=100",
        "import:fastapi.description=\"Search in translation values\")",
        "import:fastapi.\"language_code\": language.language_code",
        "import:fastapi.translation_notes=translation.translation_notes",
        "import:fastapi.\"is_default\": True",
        "import:fastapi.or_",
        "import:fastapi.\"proficiency_level\": primary_preference.proficiency_level\n    }\n\n\n# ============================================================================\n# TRANSLATION UTILITIES\n# ============================================================================\n\n@router.get(\"/translate/{translation_key}\")\nasync def get_translation_by_key(\n    translation_key: str = Path(...",
        "import:fastapi.is_primary=preference.is_primary",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.get(\"/languages\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.translation_context=translation.translation_context",
        "import:fastapi.field",
        "import:fastapi.detail=\"Language not found\")\n    \n    # If setting as default",
        "import:fastapi.Translation.translation_key == translation_data.translation_key",
        "import:fastapi.value in update_data.items():\n        if hasattr(language",
        "import:fastapi.user_id=str(preference.user_id)",
        "import:fastapi.UserLanguagePreferenceListResponse",
        "import:fastapi.response_model=LanguageListResponse)\nasync def list_languages(\n    page: int = Query(1",
        "import:fastapi.description=\"Search in language names\")",
        "import:fastapi.language_id: Optional[str] = Query(None",
        "import:fastapi.is_primary=existing_preference.is_primary",
        "import:fastapi.HTTPException",
        "import:fastapi.Translation",
        "import:fastapi.\"translated_value\": fallback_translation.translation_value",
        "import:fastapi.LanguageCreateRequest",
        "import:fastapi.translation_key=translation.translation_key",
        "import:fastapi.UserLanguagePreference.language_id == language.id\n        )\n    ).first()\n    \n    if existing_preference:\n        # Update existing preference\n        existing_preference.is_primary = True\n        existing_preference.updated_at = datetime.utcnow()\n        \n        # Set other preferences as secondary\n        db.query(UserLanguagePreference).filter(\n            and_(\n                UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.response_model=UserLanguagePreferenceListResponse)\nasync def get_user_language_preferences(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by language ID\")",
        "import:fastapi.\"is_secondary\": True})\n    \n    db.commit()\n    \n    # Track language usage analytics\n    _track_language_usage(db",
        "import:fastapi.\"time_format\": language.time_format",
        "import:fastapi.updated_at=preference.updated_at\n        ))\n    \n    return UserLanguagePreferenceListResponse(\n        preferences=preference_responses",
        "import:fastapi.response_model=TranslationResponse)\nasync def create_translation(\n    translation_data: TranslationCreateRequest = Body(...)",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Toggle user's interface language.\n    \n    This is the main endpoint for the French/English language toggle feature.\n    \"\"\"\n    # Get language by code\n    language = db.query(Language).filter(\n        and_(\n            Language.language_code == toggle_data.language_code",
        "import:fastapi.\"is_fallback\": False",
        "import:fastapi.detail=f\"Translation with key '{translation_data.translation_key}' already exists for this language and version\"\n        )\n    \n    # Create new translation\n    translation = Translation(**translation_data.dict())\n    db.add(translation)\n    db.commit()\n    db.refresh(translation)\n    \n    logger.info(f\"Translation created: {current_user.username} - {translation_data.translation_key}\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.LanguageCodeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# LANGUAGE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/languages\"",
        "import:fastapi.direction=language.direction",
        "import:fastapi.\"is_fallback\": True",
        "import:fastapi.is_default: Optional[bool] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.\"is_secondary\": True})\n    else:\n        # Create new preference\n        new_preference = UserLanguagePreference(\n            user_id=current_user.id",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific language by ID.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Translation key\")",
        "import:fastapi.LanguageUpdateRequest",
        "import:fastapi.page_size=len(preference_responses)",
        "import:fastapi.Translation.is_approved == True\n        )\n    )\n    \n    if context:\n        query = query.filter(Translation.translation_context == context)\n    \n    # Get latest approved version\n    translation = query.order_by(desc(Translation.version)).first()\n    \n    if not translation:\n        # Return fallback (usually English)\n        fallback_language = db.query(Language).filter(Language.language_code == \"en\").first()\n        if fallback_language:\n            fallback_translation = db.query(Translation).filter(\n                and_(\n                    Translation.language_id == fallback_language.id",
        "import:fastapi.\"language_code\": \"en\"",
        "import:fastapi.UserLanguagePreferenceResponse",
        "import:fastapi.is_approved=translation.is_approved",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n@router.get(\"/translations\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get current user's active language preference.\n    \"\"\"\n    # Get primary language preference\n    primary_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.Language.language_name_native.ilike(search_term)",
        "import:fastapi.Depends",
        "import:fastapi.Translation.translation_context.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get translations\n    translations = query.order_by(Translation.translation_key).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    translation_responses = []\n    for translation in translations:\n        translation_responses.append(TranslationResponse(\n            id=str(translation.id)",
        "import:fastapi.has_prev=False\n    )\n\n\n# ============================================================================\n# LANGUAGE TOGGLE AND SWITCHING\n# ============================================================================\n\n@router.post(\"/toggle\")\nasync def toggle_user_language(\n    toggle_data: LanguageToggleRequest = Body(...)",
        "import:fastapi.Path",
        "import:fastapi.UserLanguagePreferenceUpdateRequest",
        "import:fastapi.is_primary=True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List translations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Translation)\n    \n    # Apply filters\n    if language_id:\n        query = query.filter(Translation.language_id == language_id)\n    \n    if translation_key:\n        query = query.filter(Translation.translation_key == translation_key)\n    \n    if context:\n        query = query.filter(Translation.translation_context == context)\n    \n    if is_approved is not None:\n        query = query.filter(Translation.is_approved == is_approved)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Translation.translation_value.ilike(search_term)",
        "import:fastapi.page=page",
        "import:fastapi.is_active=language.is_active",
        "import:fastapi.UserLanguagePreference.id != existing_preference.id\n            )\n        ).update({\"is_primary\": False",
        "import:fastapi.\"context\": context\n        }\n    \n    return {\n        \"translation_key\": translation_key",
        "import:fastapi.language_code=language.language_code",
        "import:fastapi.\"translated_value\": translation_key",
        "import:fastapi.updated_at=preference.updated_at\n    )\n\n\n@router.get(\"/users/preferences\"",
        "import:fastapi.updated_at=translation.updated_at\n        ))\n    \n    return TranslationListResponse(\n        translations=translation_responses",
        "import:fastapi.\"date_format\": language.date_format",
        "import:fastapi.\"context\": fallback_translation.translation_context\n                }\n        \n        # Return key as fallback\n        return {\n            \"translation_key\": translation_key",
        "import:fastapi.\"language_code\": language_code",
        "import:fastapi.time_format=language.time_format",
        "import:fastapi.current_user.id)\n    \n    logger.info(f\"User language toggled: {current_user.username} - {toggle_data.language_code}\")\n    \n    return {\n        \"message\": f\"Language switched to {language.language_name_native}\"",
        "import:fastapi.UserLanguagePreference.language_id == preference_data.language_id\n        )\n    ).first()\n    \n    if existing_preference:\n        # Update existing preference\n        update_data = preference_data.dict(exclude_unset=True)\n        for field",
        "import:fastapi.created_at=preference.created_at",
        "import:fastapi.total=len(preference_responses)",
        "import:fastapi.\"language_name_native\": language.language_name_native",
        "import:fastapi.is_secondary=existing_preference.is_secondary",
        "import:fastapi.description=\"Translation context\")",
        "import:fastapi.created_at=translation.created_at",
        "import:fastapi.Language.language_code.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get languages\n    languages = query.order_by(Language.language_code).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    language_responses = []\n    for language in languages:\n        language_responses.append(LanguageResponse(\n            id=str(language.id)",
        "import:fastapi.is_secondary=preference.is_secondary",
        "import:fastapi.detail=f\"Language '{toggle_data.language_code}' not found or not active\"\n        )\n    \n    # Update or create user preference\n    existing_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.response_model=LanguageResponse)\nasync def get_language(\n    language_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/languages/{language_id}\"",
        "import:fastapi.response_model=TranslationResponse)\nasync def get_translation(\n    translation_id: str = Path(...",
        "import:fastapi.Translation.translation_key == translation_key",
        "import:fastapi.language_name_native=language.language_name_native",
        "import:fastapi.language_id=str(translation.language_id)",
        "import:fastapi.updated_at=translation.updated_at\n    )\n\n\n# ============================================================================\n# USER LANGUAGE PREFERENCES\n# ============================================================================\n\n@router.post(\"/users/preferences\"",
        "import:fastapi.LanguageListResponse",
        "import:fastapi.is_secondary=False",
        "import:fastapi.response_model=LanguageResponse)\nasync def update_language(\n    language_id: str = Path(...",
        "import:fastapi.field):\n                setattr(existing_preference",
        "import:fastapi.currency_code=language.currency_code",
        "function:get_translation_by_key",
        "import:fastapi.has_next=False",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/translations/{translation_id}\"",
        "import:fastapi.proficiency_level=\"fluent\"\n        )\n        db.add(new_preference)\n        \n        # Set other preferences as secondary\n        db.query(UserLanguagePreference).filter(\n            UserLanguagePreference.user_id == current_user.id\n        ).update({\"is_primary\": False",
        "import:fastapi.TranslationListResponse",
        "import:fastapi.created_at=language.created_at",
        "import:fastapi.context: Optional[str] = Query(None",
        "import:fastapi.\"translated_value\": translation.translation_value",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n# ============================================================================\n# TRANSLATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/translations\"",
        "import:fastapi.\"context\": translation.translation_context",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if translation key already exists for this language and version\n    existing_translation = db.query(Translation).filter(\n        and_(\n            Translation.language_id == translation_data.language_id",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new supported language.\n    \n    This creates a new language configuration for the system.\n    \"\"\"\n    # Check if language code already exists\n    existing_language = db.query(Language).filter(\n        Language.language_code == language_data.language_code\n    ).first()\n    \n    if existing_language:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.Query",
        "import:fastapi.number_format=language.number_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Get current user's language preferences.\n    \"\"\"\n    preferences = db.query(UserLanguagePreference).filter(\n        UserLanguagePreference.user_id == current_user.id\n    ).all()\n    \n    preference_responses = []\n    for preference in preferences:\n        preference_responses.append(UserLanguagePreferenceResponse(\n            id=str(preference.id)",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Filter by context\")",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Update language fields\n    update_data = language_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.UserLanguagePreference.is_primary == True\n        )\n    ).first()\n    \n    if not primary_preference:\n        # Get default language\n        default_language = db.query(Language).filter(Language.is_default == True).first()\n        if not default_language:\n            default_language = db.query(Language).filter(Language.language_code == \"en\").first()\n        \n        return {\n            \"language_code\": default_language.language_code",
        "import:fastapi.value)\n        \n        existing_preference.updated_at = datetime.utcnow()\n        db.commit()\n        db.refresh(existing_preference)\n        \n        logger.info(f\"User language preference updated: {current_user.username} - {language.language_code}\")\n        \n        return UserLanguagePreferenceResponse(\n            id=str(existing_preference.id)",
        "import:fastapi.updated_at=language.updated_at\n        ))\n    \n    return LanguageListResponse(\n        languages=language_responses",
        "import:fastapi.Language.is_active == True\n        )\n    ).first()\n    \n    if not language:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.language.id",
        "import:fastapi.\"currency_code\": language.currency_code\n    }\n\n\n@router.get(\"/current\")\nasync def get_current_user_language(\n    db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by approval status\")",
        "import:fastapi.detail=\"Language not found\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.is_approved: Optional[bool] = Query(None",
        "import:fastapi.\"direction\": default_language.direction",
        "import:fastapi.Translation.version == translation_data.version\n        )\n    ).first()\n    \n    if existing_translation:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.response_model=UserLanguagePreferenceResponse)\nasync def create_user_language_preference(\n    preference_data: UserLanguagePreferenceCreateRequest = Body(...)",
        "import:fastapi.proficiency_level=existing_preference.proficiency_level",
        "import:fastapi.value)\n    \n    language.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language updated: {current_user.username} - {language.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.language_id=str(preference.language_id)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.value in update_data.items():\n            if hasattr(existing_preference",
        "import:fastapi.TranslationCreateRequest",
        "import:fastapi.\"number_format\": language.number_format",
        "import:fastapi.\"language_name_native\": default_language.language_name_native",
        "import:fastapi.description=\"Filter by default status\")",
        "import:fastapi.detail=\"Translation not found\")\n    \n    return TranslationResponse(\n        id=str(translation.id)",
        "import:fastapi.updated_at=language.updated_at\n    )\n\n\n@router.put(\"/languages/{language_id}\"",
        "import:fastapi.language_id=str(existing_preference.language_id)",
        "import:fastapi.date_format=language.date_format",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a language configuration.\n    \"\"\"\n    language = db.query(Language).filter(Language.id == language_id).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"Language not found\")\n    \n    # Check if preference already exists\n    existing_preference = db.query(UserLanguagePreference).filter(\n        and_(\n            UserLanguagePreference.user_id == current_user.id",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.\"language_name\": default_language.language_name",
        "import:fastapi.detail=f\"Language with code '{language_data.language_code}' already exists\"\n        )\n    \n    # If this is set as default",
        "import:fastapi.proficiency_level=preference.proficiency_level",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get translation by key for a specific language.\n    \n    This is used by the frontend to get translated text.\n    \"\"\"\n    # Get language\n    language = db.query(Language).filter(\n        and_(\n            Language.language_code == language_code",
        "import:fastapi.page=1",
        "import:fastapi.\"currency_code\": language.currency_code",
        "import:fastapi.\"date_format\": default_language.date_format",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Translation ID\")",
        "import:fastapi.approved_by=translation.approved_by",
        "import:fastapi.Translation.is_approved == True\n                )\n            ).order_by(desc(Translation.version)).first()\n            \n            if fallback_translation:\n                return {\n                    \"translation_key\": translation_key",
        "import:fastapi.unset other defaults\n    if language_data.is_default:\n        db.query(Language).filter(Language.is_default == True).update({\"is_default\": False})\n    \n    # Create new language\n    language = Language(**language_data.dict())\n    db.add(language)\n    db.commit()\n    db.refresh(language)\n    \n    logger.info(f\"Language created: {current_user.username} - {language_data.language_code}\")\n    \n    return LanguageResponse(\n        id=str(language.id)",
        "import:fastapi.\"language_name\": language.language_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List supported languages with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Language)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(Language.is_active == is_active)\n    \n    if is_default is not None:\n        query = query.filter(Language.is_default == is_default)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Language.language_name.ilike(search_term)",
        "import:fastapi.description=\"Language ID\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific translation by ID.\n    \"\"\"\n    translation = db.query(Translation).filter(Translation.id == translation_id).first()\n    \n    if not translation:\n        raise HTTPException(status_code=404",
        "import:fastapi.Language.is_active == True\n        )\n    ).first()\n    \n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=existing_preference.updated_at\n        )\n    \n    # Create new preference\n    preference = UserLanguagePreference(**preference_data.dict())\n    preference.user_id = current_user.id\n    db.add(preference)\n    db.commit()\n    db.refresh(preference)\n    \n    logger.info(f\"User language preference created: {current_user.username} - {language.language_code}\")\n    \n    return UserLanguagePreferenceResponse(\n        id=str(preference.id)",
        "import:fastapi.approved_at=translation.approved_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create or update user language preference.\n    \"\"\"\n    # Verify language exists\n    language = db.query(Language).filter(Language.id == preference_data.language_id).first()\n    if not language:\n        raise HTTPException(status_code=404",
        "import:fastapi.is_default=language.is_default",
        "import:fastapi.translation_value=translation.translation_value",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.version=translation.version",
        "import:fastapi.description=\"Language code\")",
        "import:fastapi.user_id=str(existing_preference.user_id)",
        "import:fastapi.translation_key: Optional[str] = Query(None",
        "import:fastapi.response_model=TranslationListResponse)\nasync def list_translations(\n    page: int = Query(1",
        "import:fastapi.\"direction\": language.direction",
        "import:fastapi.Body",
        "import:fastapi.language_data: LanguageUpdateRequest = Body(...)",
        "import:fastapi.\"time_format\": default_language.time_format",
        "import:fastapi.created_at=existing_preference.created_at",
        "import:fastapi.APIRouter",
        "import:fastapi.Translation.translation_key.ilike(search_term)",
        "import:fastapi.detail=f\"Language '{language_code}' not found\")\n    \n    # Build query for translation\n    query = db.query(Translation).filter(\n        and_(\n            Translation.language_id == language.id"
      ]
    },
    "POST:/postal-code": {
      "method": "POST",
      "path": "/postal-code",
      "file": "services/api-gateway/app/api/v1/user_profiles.py",
      "line": 110,
      "dependencies": [
        "import:fastapi.\"analytics\": mock_analytics",
        "import:fastapi.\"push\": False",
        "import:fastapi.\"bills_supported\": 23",
        "import:fastapi.\"geographic_interest\": {\n            \"primary_constituency\": \"Toronto Centre\"",
        "import:fastapi.\"engagement_score\": 8.7\n        }",
        "import:fastapi.description=\"User ID for analytics\")",
        "import:fastapi.\"activity_breakdown\": {\n            \"by_month\": {\n                \"2024-11\": 12",
        "import:fastapi.\"British Columbia\": 23",
        "import:fastapi.\"by_time_of_day\": {\n                \"morning\": 23",
        "import:fastapi.\"evening\": 67",
        "import:fastapi.\"period\": f\"{date_from} to {date_to}\" if date_from and date_to else \"All time\"",
        "import:fastapi.\"favorite_mps\": [\"Hon. Member Smith\"",
        "import:fastapi.\"votes_analyzed\": 67",
        "import:fastapi.\"Health\"",
        "import:fastapi.\"voting_guides_read\": 5",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.\"committee_work_understood\": \"Intermediate\"",
        "import:fastapi.\"2024-12\": 18",
        "import:fastapi.\"Green\"]",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.\"engagement_summary\": {\n            \"total_visits\": 156",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": 45",
        "import:fastapi.\"generated_at\": \"2025-01-15T10:30:00Z\"\n    }",
        "import:fastapi.\"favorite_parties\": [\"Liberal\"",
        "import:fastapi.\"Economy\"",
        "import:fastapi.\"Quebec\": 18",
        "import:fastapi.\"debates_read\": 45\n        }",
        "import:fastapi.\"sms\": False\n            }\n        }",
        "import:fastapi.\"debates\": 28",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.Politician",
        "import:fastapi.\"bill_process_knowledge\": \"Advanced\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"night\": 21\n            }\n        }",
        "import:fastapi.\"Justice\"]",
        "import:fastapi.\"social_engagement\": {\n            \"shares\": 23",
        "import:fastapi.\"active_days\": 45",
        "import:fastapi.\"bills_bookmarked\": 15",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would come from user activity tracking\n    mock_analytics = {\n        \"user_id\": user_id",
        "import:fastapi.\"preferences\": {\n            \"favorite_topics\": [\"Environment\"",
        "function:get_user_analytics",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.create mock user analytics data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"followers\": 12",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"province_breakdown\": {\n                \"Ontario\": 45",
        "import:fastapi.\"following\": 8\n        }",
        "import:fastapi.\"2025-01\": 25\n            }",
        "import:fastapi.\"learning_progress\": {\n            \"parliamentary_education_modules\": 3",
        "import:fastapi.\"notification_preferences\": {\n                \"email\": True",
        "import:fastapi.\"votes\": 34",
        "import:fastapi.\"committees\": 26\n            }",
        "import:fastapi.\"Other\": 2\n            }\n        }",
        "import:fastapi.Party",
        "import:fastapi.List",
        "import:fastapi.\"secondary_constituencies\": [\"Vancouver Centre\"",
        "import:fastapi.\"content_interaction\": {\n            \"bills_viewed\": 89",
        "import:fastapi.\"Hon. Member Johnson\"]",
        "import:fastapi.\"afternoon\": 45",
        "import:fastapi.\"comments\": 45",
        "import:fastapi.\"Montreal Centre\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/analytics\")\nasync def get_user_analytics(\n    user_id: str = Query(...",
        "import:fastapi.\"last_activity\": \"2025-01-15\"",
        "import:fastapi.Dict",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get comprehensive user analytics and statistics.\n    Provides insights into user engagement with parliamentary content.\n    \"\"\"\n    # For now",
        "import:fastapi.\"mps\": 23",
        "import:fastapi.APIRouter",
        "import:fastapi.\"Alberta\": 12",
        "import:fastapi.\"mps_researched\": 34",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/constituency/{postal_code}": {
      "method": "GET",
      "path": "/constituency/{postal_code}",
      "file": "services/api-gateway/app/api/v1/user_profiles.py",
      "line": 169,
      "dependencies": [
        "function:update_postal_code",
        "import:fastapi.\"push\": False",
        "import:fastapi.\"favorite_mps\": [\"Hon. Member Smith\"",
        "import:fastapi.\"facebook\": \"MemberSmithMP\"",
        "import:fastapi.\"postal_code\": postal_code",
        "import:fastapi.\"committee_work_understood\": \"Intermediate\"",
        "import:fastapi.\"debates\": 28",
        "import:fastapi.create mock MP data based on postal code\n    # In a full implementation",
        "import:fastapi.Politician",
        "import:fastapi.\"bill_process_knowledge\": \"Advanced\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"province\": \"Ontario\"",
        "import:fastapi.\"Justice\"]",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.\"median_income\": 75000",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"learning_progress\": {\n            \"parliamentary_education_modules\": 3",
        "import:fastapi.\"notification_preferences\": {\n                \"email\": True",
        "import:fastapi.\"committees\": 26\n            }",
        "import:fastapi.\"comments\": 45",
        "import:fastapi.\"Transit\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get comprehensive user analytics and statistics.\n    Provides insights into user engagement with parliamentary content.\n    \"\"\"\n    # For now",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"analytics\": mock_analytics",
        "import:fastapi.\"updated_at\": \"2025-01-15T10:30:00Z\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.detail=\"Invalid postal code format\")\n    \n    # For now",
        "import:fastapi.\"British Columbia\": 23",
        "import:fastapi.\"bills_supported\": 23",
        "import:fastapi.\"engagement_score\": 8.7\n        }",
        "import:fastapi.description=\"User ID for analytics\")",
        "import:fastapi.\"activity_breakdown\": {\n            \"by_month\": {\n                \"2024-11\": 12",
        "import:fastapi.\"constituency\": \"Toronto Centre\"",
        "import:fastapi.\"constituency_office\": \"416-555-1234\"",
        "import:fastapi.\"riding_name\": \"Toronto Centre\"",
        "import:fastapi.\"instagram\": \"membersmithmp\"\n            }\n        }",
        "import:fastapi.\"Green\"]",
        "import:fastapi.\"email\": \"member.smith@parl.gc.ca\"",
        "import:fastapi.\"debates_read\": 45\n        }",
        "import:fastapi.\"sms\": False\n            }\n        }",
        "import:fastapi.\"night\": 21\n            }\n        }",
        "import:fastapi.\"bills_bookmarked\": 15",
        "import:fastapi.this would come from user activity tracking\n    mock_analytics = {\n        \"user_id\": user_id",
        "import:fastapi.\"preferences\": {\n            \"favorite_topics\": [\"Environment\"",
        "import:fastapi.\"following\": 8\n        }",
        "import:fastapi.Depends",
        "import:fastapi.create mock user analytics data\n    # In a full implementation",
        "import:fastapi.\"constituency_id\": \"35061\"",
        "import:fastapi.\"2025-01\": 25\n            }",
        "import:fastapi.\"party\": \"Liberal\"",
        "import:fastapi.Party",
        "import:fastapi.\"Hon. Member Johnson\"]",
        "import:fastapi.this would query the database for the MP\n    mock_mp_data = {\n        \"user_id\": user_id",
        "import:fastapi.\"evening\": 67",
        "import:fastapi.\"period\": f\"{date_from} to {date_to}\" if date_from and date_to else \"All time\"",
        "import:fastapi.\"votes_analyzed\": 67",
        "import:fastapi.\"key_issues\": [\"Housing\"",
        "import:fastapi.\"Healthcare\"]\n        }",
        "import:fastapi.\"mp_details\": {\n            \"id\": \"123\"",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.\"engagement_summary\": {\n            \"total_visits\": 156",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": 45",
        "import:fastapi.\"favorite_parties\": [\"Liberal\"",
        "import:fastapi.\"Economy\"",
        "import:fastapi.\"Quebec\": 18",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"area_km2\": 12.5",
        "import:fastapi.\"social_engagement\": {\n            \"shares\": 23",
        "import:fastapi.\"followers\": 12",
        "import:fastapi.Query",
        "import:fastapi.\"province_breakdown\": {\n                \"Ontario\": 45",
        "import:fastapi.description=\"New postal code\")",
        "import:fastapi.\"mp_found\": True",
        "import:fastapi.\"website\": \"https://membersmith.liberal.ca\"\n            }",
        "import:fastapi.\"votes\": 34",
        "import:fastapi.\"secondary_constituencies\": [\"Vancouver Centre\"",
        "import:fastapi.\"content_interaction\": {\n            \"bills_viewed\": 89",
        "import:fastapi.\"data\": mock_mp_data\n    }",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/analytics\")\nasync def get_user_analytics(\n    user_id: str = Query(...",
        "import:fastapi.\"generated_at\": \"2025-01-15T10:30:00Z\"\n    }\n\n\n@router.post(\"/postal-code\")\nasync def update_postal_code(\n    user_id: str = Body(...",
        "import:fastapi.\"mps_researched\": 34",
        "import:fastapi.\"constituency_info\": {\n            \"population\": 125000",
        "import:fastapi.\"Montreal Centre\"]",
        "import:fastapi.\"geographic_interest\": {\n            \"primary_constituency\": \"Toronto Centre\"",
        "import:fastapi.\"Environment\"",
        "import:fastapi.\"by_time_of_day\": {\n                \"morning\": 23",
        "import:fastapi.\"education_level\": \"High\"\n            }",
        "import:fastapi.\"Health\"",
        "import:fastapi.\"voting_guides_read\": 5",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.\"2024-12\": 18",
        "import:fastapi.\"social_media\": {\n                \"twitter\": \"@MemberSmith\"",
        "import:fastapi.\"message\": \"Postal code updated successfully\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user's postal code and find their MP.\n    \"\"\"\n    # Validate postal code format (Canadian format)\n    if not postal_code or len(postal_code) < 6:\n        raise HTTPException(status_code=400",
        "import:fastapi.postal_code: str = Body(...",
        "import:fastapi.\"name\": \"Hon. Member Smith\"",
        "import:fastapi.\"active_days\": 45",
        "import:fastapi.\"demographics\": {\n                \"median_age\": 35",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"contact_info\": {\n                \"parliament_office\": \"613-992-1234\"",
        "import:fastapi.\"Other\": 2\n            }\n        }",
        "import:fastapi.List",
        "import:fastapi.\"afternoon\": 45",
        "import:fastapi.\"last_activity\": \"2025-01-15\"",
        "import:fastapi.Dict",
        "import:fastapi.\"mps\": 23",
        "import:fastapi.APIRouter",
        "import:fastapi.\"Alberta\": 12",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/user/{user_id}/activity": {
      "method": "GET",
      "path": "/user/{user_id}/activity",
      "file": "services/api-gateway/app/api/v1/user_profiles.py",
      "line": 256,
      "dependencies": [
        "import:fastapi.\"push\": False",
        "import:fastapi.\"favorite_mps\": [\"Hon. Member Smith\"",
        "import:fastapi.\"facebook\": \"MemberSmithMP\"",
        "import:fastapi.\"current_mp\": {\n            \"id\": \"123\"",
        "import:fastapi.\"postal_code\": postal_code",
        "import:fastapi.\"committee_work_understood\": \"Intermediate\"",
        "import:fastapi.\"debates\": 28",
        "import:fastapi.create mock MP data based on postal code\n    # In a full implementation",
        "import:fastapi.Politician",
        "import:fastapi.\"term\": \"2015-2019\"",
        "import:fastapi.\"Mandarin\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get constituency information by postal code.\n    \"\"\"\n    # Validate postal code format\n    if not postal_code or len(postal_code) < 6:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"bill_process_knowledge\": \"Advanced\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"province\": \"Ontario\"",
        "import:fastapi.\"Justice\"]",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.\"median_income\": 75000",
        "import:fastapi.create mock constituency data\n    # In a full implementation",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_constituency_data = {\n        \"postal_code\": postal_code",
        "import:fastapi.\"2015\": {\"winner\": \"Liberal\"",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"learning_progress\": {\n            \"parliamentary_education_modules\": 3",
        "import:fastapi.\"density_per_km2\": 10000",
        "import:fastapi.\"notification_preferences\": {\n                \"email\": True",
        "import:fastapi.\"committees\": 26\n            }",
        "import:fastapi.\"margin\": \"18.7%\"",
        "import:fastapi.\"comments\": 45",
        "import:fastapi.\"Transit\"",
        "import:fastapi.\"federal_riding\": \"35061\"",
        "import:fastapi.\"election_history\": {\n            \"2021\": {\"winner\": \"Liberal\"",
        "import:fastapi.\"Yonge-Dundas Square\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get comprehensive user analytics and statistics.\n    Provides insights into user engagement with parliamentary content.\n    \"\"\"\n    # For now",
        "import:fastapi.\"Royal Ontario Museum\"",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"analytics\": mock_analytics",
        "import:fastapi.\"updated_at\": \"2025-01-15T10:30:00Z\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.detail=\"Invalid postal code format\")\n    \n    # For now",
        "import:fastapi.\"British Columbia\": 23",
        "import:fastapi.\"bills_supported\": 23",
        "import:fastapi.\"engagement_score\": 8.7\n        }",
        "import:fastapi.description=\"User ID for analytics\")",
        "import:fastapi.\"activity_breakdown\": {\n            \"by_month\": {\n                \"2024-11\": 12",
        "import:fastapi.\"constituency\": \"Toronto Centre\"",
        "import:fastapi.\"constituency_office\": \"416-555-1234\"",
        "import:fastapi.\"riding_name\": \"Toronto Centre\"",
        "import:fastapi.\"provincial_riding\": \"35061\"",
        "import:fastapi.\"previous_mps\": [\n            {\n                \"name\": \"Hon. Member Brown\"",
        "import:fastapi.\"Economic development\"\n        ]",
        "import:fastapi.\"party_color\": \"#FF9999\"",
        "import:fastapi.\"instagram\": \"membersmithmp\"\n            }\n        }",
        "import:fastapi.\"Green\"]",
        "import:fastapi.\"email\": \"member.smith@parl.gc.ca\"",
        "import:fastapi.\"debates_read\": 45\n        }",
        "import:fastapi.\"sms\": False\n            }\n        }",
        "import:fastapi.\"night\": 21\n            }\n        }",
        "import:fastapi.\"bills_bookmarked\": 15",
        "import:fastapi.this would come from user activity tracking\n    mock_analytics = {\n        \"user_id\": user_id",
        "import:fastapi.\"preferences\": {\n            \"favorite_topics\": [\"Environment\"",
        "function:get_constituency_by_postal_code",
        "import:fastapi.\"following\": 8\n        }",
        "import:fastapi.Depends",
        "import:fastapi.create mock user analytics data\n    # In a full implementation",
        "import:fastapi.\"constituency_id\": \"35061\"",
        "import:fastapi.\"term\": \"2019-2021\"",
        "import:fastapi.\"2025-01\": 25\n            }",
        "import:fastapi.\"constituency\": {\n            \"id\": \"35061\"",
        "import:fastapi.\"party\": \"Liberal\"",
        "import:fastapi.Party",
        "import:fastapi.\"elected_date\": \"2021-09-20\"",
        "import:fastapi.\"Hon. Member Johnson\"]",
        "import:fastapi.\"languages\": [\"English\"",
        "import:fastapi.\"name\": \"Toronto Centre\"",
        "import:fastapi.\"key_issues\": [\n            \"Housing affordability\"",
        "import:fastapi.this would query the database for the MP\n    mock_mp_data = {\n        \"user_id\": user_id",
        "import:fastapi.\"median_age\": 35",
        "import:fastapi.\"committee_memberships\": [\n                \"Standing Committee on Finance\"",
        "import:fastapi.\"evening\": 67",
        "import:fastapi.\"period\": f\"{date_from} to {date_to}\" if date_from and date_to else \"All time\"",
        "import:fastapi.\"party\": \"Conservative\"",
        "import:fastapi.\"votes_analyzed\": 67",
        "import:fastapi.\"key_issues\": [\"Housing\"",
        "import:fastapi.\"margin\": \"15.2%\"",
        "import:fastapi.\"margin\": \"2.1%\"",
        "import:fastapi.\"Healthcare\"]\n        }",
        "import:fastapi.\"mp_details\": {\n            \"id\": \"123\"",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.\"engagement_summary\": {\n            \"total_visits\": 156",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": 45",
        "import:fastapi.\"notable_places\": [\n            \"University of Toronto\"",
        "import:fastapi.\"favorite_parties\": [\"Liberal\"",
        "import:fastapi.\"Economy\"",
        "import:fastapi.\"Quebec\": 18",
        "import:fastapi.\"education_level\": \"High\"",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"term_start\": \"2021-11-22\"",
        "import:fastapi.\"area_km2\": 12.5",
        "import:fastapi.\"social_engagement\": {\n            \"shares\": 23",
        "import:fastapi.\"followers\": 12",
        "import:fastapi.Query",
        "import:fastapi.\"province_breakdown\": {\n                \"Ontario\": 45",
        "import:fastapi.{\n                \"name\": \"Hon. Member Davis\"",
        "import:fastapi.\"municipal_ward\": \"Ward 13\"\n        }",
        "import:fastapi.description=\"New postal code\")",
        "import:fastapi.\"mp_found\": True",
        "import:fastapi.\"website\": \"https://membersmith.liberal.ca\"\n            }",
        "import:fastapi.\"votes\": 34",
        "import:fastapi.\"turnout\": \"70.1%\"}\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"secondary_constituencies\": [\"Vancouver Centre\"",
        "import:fastapi.\"content_interaction\": {\n            \"bills_viewed\": 89",
        "import:fastapi.\"current_status\": \"Former MP\"\n            }",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/analytics\")\nasync def get_user_analytics(\n    user_id: str = Query(...",
        "import:fastapi.\"generated_at\": \"2025-01-15T10:30:00Z\"\n    }\n\n\n@router.post(\"/postal-code\")\nasync def update_postal_code(\n    user_id: str = Body(...",
        "import:fastapi.\"mps_researched\": 34",
        "import:fastapi.\"constituency_info\": {\n            \"population\": 125000",
        "import:fastapi.\"Montreal Centre\"]",
        "import:fastapi.\"2019\": {\"winner\": \"Conservative\"",
        "import:fastapi.\"geographic_interest\": {\n            \"primary_constituency\": \"Toronto Centre\"",
        "import:fastapi.\"Environmental protection\"",
        "import:fastapi.\"Environment\"",
        "import:fastapi.\"by_time_of_day\": {\n                \"morning\": 23",
        "import:fastapi.\"education_level\": \"High\"\n            }",
        "import:fastapi.\"turnout\": \"65.2%\"}",
        "import:fastapi.\"Health\"",
        "import:fastapi.\"voting_guides_read\": 5",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.\"2024-12\": 18",
        "import:fastapi.\"social_media\": {\n                \"twitter\": \"@MemberSmith\"",
        "import:fastapi.\"message\": \"Postal code updated successfully\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user's postal code and find their MP.\n    \"\"\"\n    # Validate postal code format (Canadian format)\n    if not postal_code or len(postal_code) < 6:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"French\"",
        "import:fastapi.\"data\": mock_constituency_data\n    }",
        "import:fastapi.\"Standing Committee on Health\"\n            ]\n        }",
        "import:fastapi.postal_code: str = Body(...",
        "import:fastapi.\"St. Lawrence Market\"\n        ]",
        "import:fastapi.\"name\": \"Hon. Member Smith\"",
        "import:fastapi.\"Healthcare access\"",
        "import:fastapi.\"demographics\": {\n            \"population\": 125000",
        "import:fastapi.\"Spanish\"]\n        }",
        "import:fastapi.\"active_days\": 45",
        "import:fastapi.\"Eaton Centre\"",
        "import:fastapi.\"demographics\": {\n                \"median_age\": 35",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"contact_info\": {\n                \"parliament_office\": \"613-992-1234\"",
        "import:fastapi.\"Other\": 2\n            }\n        }",
        "import:fastapi.\"data\": mock_mp_data\n    }\n\n\n@router.get(\"/constituency/{postal_code}\")\nasync def get_constituency_by_postal_code(\n    postal_code: str",
        "import:fastapi.List",
        "import:fastapi.\"afternoon\": 45",
        "import:fastapi.\"Public transit\"",
        "import:fastapi.\"last_activity\": \"2025-01-15\"",
        "import:fastapi.\"turnout\": \"68.5%\"}",
        "import:fastapi.\"experience\": \"2nd term\"",
        "import:fastapi.Dict",
        "import:fastapi.\"mps\": 23",
        "import:fastapi.\"current_status\": \"Former MP\"\n            }\n        ]",
        "import:fastapi.APIRouter",
        "import:fastapi.\"Alberta\": 12",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/user/{user_id}/preferences": {
      "method": "GET",
      "path": "/user/{user_id}/preferences",
      "file": "services/api-gateway/app/api/v1/user_profiles.py",
      "line": 381,
      "dependencies": [
        "import:fastapi.\"push\": False",
        "import:fastapi.\"interaction_details\": {\n                \"time_spent\": \"12 minutes\"",
        "import:fastapi.\"content_type\": \"bill\"",
        "import:fastapi.\"favorite_mps\": [\"Hon. Member Smith\"",
        "import:fastapi.\"content_type\": \"vote\"",
        "import:fastapi.\"facebook\": \"MemberSmithMP\"",
        "import:fastapi.\"current_mp\": {\n            \"id\": \"123\"",
        "import:fastapi.\"postal_code\": postal_code",
        "import:fastapi.\"committee_work_understood\": \"Intermediate\"",
        "import:fastapi.\"mps\": [\"Hon. Member Smith\"",
        "import:fastapi.\"activity_type\": \"vote_analysis\"",
        "import:fastapi.\"browser\": \"Safari\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"content_title\": \"Environmental Protection Act\"",
        "import:fastapi.\"related_content\": {\n                \"bills\": [\"C-123\"]",
        "import:fastapi.\"debates\": 28",
        "import:fastapi.create mock MP data based on postal code\n    # In a full implementation",
        "import:fastapi.Politician",
        "import:fastapi.\"term\": \"2015-2019\"",
        "import:fastapi.\"Mandarin\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get constituency information by postal code.\n    \"\"\"\n    # Validate postal code format\n    if not postal_code or len(postal_code) < 6:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"bill_process_knowledge\": \"Advanced\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"province\": \"Ontario\"",
        "import:fastapi.ge=1",
        "import:fastapi.\"Justice\"]",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.\"content_summary\": \"Viewed Bill C-123 on environmental protection\"",
        "import:fastapi.\"median_income\": 75000",
        "import:fastapi.create mock constituency data\n    # In a full implementation",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_constituency_data = {\n        \"postal_code\": postal_code",
        "import:fastapi.\"2015\": {\"winner\": \"Liberal\"",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"data\": mock_constituency_data\n    }\n\n\n@router.get(\"/user/{user_id}/activity\")\nasync def get_user_activity(\n    user_id: str",
        "import:fastapi.le=100",
        "import:fastapi.\"searched\"",
        "import:fastapi.\"learning_progress\": {\n            \"parliamentary_education_modules\": 3",
        "import:fastapi.\"pages_viewed\": 4",
        "import:fastapi.\"density_per_km2\": 10000",
        "import:fastapi.\"notification_preferences\": {\n                \"email\": True",
        "import:fastapi.\"committees\": 26\n            }",
        "import:fastapi.\"pages_viewed\": 5",
        "import:fastapi.\"margin\": \"18.7%\"",
        "import:fastapi.\"comments\": 45",
        "import:fastapi.\"Transit\"",
        "import:fastapi.\"federal_riding\": \"35061\"",
        "import:fastapi.\"interaction_details\": {\n                \"time_spent\": \"8 minutes\"",
        "import:fastapi.\"election_history\": {\n            \"2021\": {\"winner\": \"Liberal\"",
        "import:fastapi.\"Yonge-Dundas Square\"",
        "import:fastapi.\"actions_taken\": [\"analyzed\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get comprehensive user analytics and statistics.\n    Provides insights into user engagement with parliamentary content.\n    \"\"\"\n    # For now",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }\n    }",
        "import:fastapi.\"content_title\": \"Hon. Member Johnson\"",
        "import:fastapi.\"Royal Ontario Museum\"",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"analytics\": mock_analytics",
        "import:fastapi.\"updated_at\": \"2025-01-15T10:30:00Z\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.detail=\"Invalid postal code format\")\n    \n    # For now",
        "import:fastapi.\"actions_taken\": [\"read\"",
        "import:fastapi.\"British Columbia\": 23",
        "import:fastapi.\"bills_supported\": 23",
        "import:fastapi.create mock user activity data\n    # In a full implementation",
        "import:fastapi.\"engagement_score\": 8.7\n        }",
        "import:fastapi.description=\"User ID for analytics\")",
        "import:fastapi.\"activity_breakdown\": {\n            \"by_month\": {\n                \"2024-11\": 12",
        "import:fastapi.\"constituency\": \"Toronto Centre\"",
        "import:fastapi.\"constituency_office\": \"416-555-1234\"",
        "import:fastapi.\"riding_name\": \"Toronto Centre\"",
        "import:fastapi.\"provincial_riding\": \"35061\"",
        "import:fastapi.\"previous_mps\": [\n            {\n                \"name\": \"Hon. Member Brown\"",
        "import:fastapi.\"Economic development\"\n        ]",
        "import:fastapi.\"party_color\": \"#FF9999\"",
        "import:fastapi.\"instagram\": \"membersmithmp\"\n            }\n        }",
        "import:fastapi.\"Green\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed user activity timeline.\n    \"\"\"\n    # For now",
        "import:fastapi.\"interaction_details\": {\n                \"time_spent\": \"5 minutes\"",
        "import:fastapi.\"email\": \"member.smith@parl.gc.ca\"",
        "import:fastapi.\"activity_date\": \"2025-01-14T16:45:00Z\"",
        "import:fastapi.\"debates_read\": 45\n        }",
        "import:fastapi.\"sms\": False\n            }\n        }",
        "import:fastapi.\"C-124\"]",
        "import:fastapi.\"metadata\": {\n                \"device\": \"Desktop\"",
        "import:fastapi.\"night\": 21\n            }\n        }",
        "import:fastapi.\"content_id\": \"456\"",
        "import:fastapi.\"shared\"",
        "import:fastapi.\"content_title\": \"Vote on Bill C-123\"",
        "import:fastapi.\"bills_bookmarked\": 15",
        "import:fastapi.this would come from user activity tracking\n    mock_analytics = {\n        \"user_id\": user_id",
        "import:fastapi.\"preferences\": {\n            \"favorite_topics\": [\"Environment\"",
        "import:fastapi.\"following\": 8\n        }",
        "import:fastapi.Depends",
        "import:fastapi.create mock user analytics data\n    # In a full implementation",
        "import:fastapi.\"constituency_id\": \"35061\"",
        "import:fastapi.\"term\": \"2019-2021\"",
        "function:get_user_activity",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"2025-01\": 25\n            }",
        "import:fastapi.\"activity_type\": \"bill_view\"",
        "import:fastapi.\"constituency\": {\n            \"id\": \"35061\"",
        "import:fastapi.\"party\": \"Liberal\"",
        "import:fastapi.Party",
        "import:fastapi.\"elected_date\": \"2021-09-20\"",
        "import:fastapi.\"Hon. Member Johnson\"]",
        "import:fastapi.ON\"\n            }\n        }",
        "import:fastapi.\"commented\"]\n            }",
        "import:fastapi.\"content_summary\": \"Analyzed voting patterns and party positions\"",
        "import:fastapi.\"languages\": [\"English\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"name\": \"Toronto Centre\"",
        "import:fastapi.\"key_issues\": [\n            \"Housing affordability\"",
        "import:fastapi.this would query the database for the MP\n    mock_mp_data = {\n        \"user_id\": user_id",
        "import:fastapi.\"filters_applied\": {\n            \"activity_type\": activity_type",
        "import:fastapi.\"committees\": [\"Standing Committee on Environment\"]\n            }",
        "import:fastapi.\"median_age\": 35",
        "import:fastapi.\"committee_memberships\": [\n                \"Standing Committee on Finance\"",
        "import:fastapi.\"evening\": 67",
        "import:fastapi.\"period\": f\"{date_from} to {date_to}\" if date_from and date_to else \"All time\"",
        "import:fastapi.activity_type: Optional[str] = Query(None",
        "import:fastapi.\"party\": \"Conservative\"",
        "import:fastapi.\"votes_analyzed\": 67",
        "import:fastapi.\"browser\": \"Chrome\"",
        "import:fastapi.\"key_issues\": [\"Housing\"",
        "import:fastapi.\"margin\": \"15.2%\"",
        "import:fastapi.\"related_content\": {\n                \"bills\": [\"C-123\"",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"margin\": \"2.1%\"",
        "import:fastapi.this would come from user activity tracking\n    mock_activities = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"content_id\": \"789\"",
        "import:fastapi.\"Healthcare\"]\n        }",
        "import:fastapi.\"mp_details\": {\n            \"id\": \"123\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.\"engagement_summary\": {\n            \"total_visits\": 156",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": 45",
        "import:fastapi.\"notable_places\": [\n            \"University of Toronto\"",
        "import:fastapi.\"favorite_parties\": [\"Liberal\"",
        "import:fastapi.\"Economy\"",
        "import:fastapi.\"Quebec\": 18",
        "import:fastapi.\"education_level\": \"High\"",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"term_start\": \"2021-11-22\"",
        "import:fastapi.\"area_km2\": 12.5",
        "import:fastapi.\"social_engagement\": {\n            \"shares\": 23",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"content_summary\": \"Researched MP profile and voting record\"",
        "import:fastapi.\"results\": paginated_activities",
        "import:fastapi.\"followers\": 12",
        "import:fastapi.Query",
        "import:fastapi.\"pages_viewed\": 3",
        "import:fastapi.\"province_breakdown\": {\n                \"Ontario\": 45",
        "import:fastapi.{\n                \"name\": \"Hon. Member Davis\"",
        "import:fastapi.\"municipal_ward\": \"Ward 13\"\n        }",
        "import:fastapi.description=\"New postal code\")",
        "import:fastapi.\"mp_found\": True",
        "import:fastapi.\"website\": \"https://membersmith.liberal.ca\"\n            }",
        "import:fastapi.\"votes\": 34",
        "import:fastapi.\"turnout\": \"70.1%\"}\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"location\": \"Toronto",
        "import:fastapi.\"content_type\": \"mp\"",
        "import:fastapi.\"metadata\": {\n                \"device\": \"Mobile\"",
        "import:fastapi.\"secondary_constituencies\": [\"Vancouver Centre\"",
        "import:fastapi.\"content_interaction\": {\n            \"bills_viewed\": 89",
        "import:fastapi.\"current_status\": \"Former MP\"\n            }",
        "import:fastapi.\"content_id\": \"123\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/analytics\")\nasync def get_user_analytics(\n    user_id: str = Query(...",
        "import:fastapi.\"generated_at\": \"2025-01-15T10:30:00Z\"\n    }\n\n\n@router.post(\"/postal-code\")\nasync def update_postal_code(\n    user_id: str = Body(...",
        "import:fastapi.\"mps\": [\"Hon. Member Smith\"]",
        "import:fastapi.\"votes\": [\"V-123\"",
        "import:fastapi.ON\"\n            }\n        }\n    ]\n    \n    # Apply filters\n    filtered_activities = mock_activities\n    \n    if activity_type:\n        filtered_activities = [\n            activity for activity in filtered_activities\n            if activity[\"activity_type\"] == activity_type\n        ]\n    \n    # Apply pagination\n    total = len(filtered_activities)\n    offset = (page - 1) * page_size\n    paginated_activities = filtered_activities[offset:offset + page_size]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"mps_researched\": 34",
        "import:fastapi.\"constituency_info\": {\n            \"population\": 125000",
        "import:fastapi.\"Montreal Centre\"]",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"2019\": {\"winner\": \"Conservative\"",
        "import:fastapi.\"geographic_interest\": {\n            \"primary_constituency\": \"Toronto Centre\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\"Environmental protection\"",
        "import:fastapi.\"Environment\"",
        "import:fastapi.\"bookmarked\"]\n            }",
        "import:fastapi.\"by_time_of_day\": {\n                \"morning\": 23",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"NDP\"]\n            }",
        "import:fastapi.\"education_level\": \"High\"\n            }",
        "import:fastapi.\"turnout\": \"65.2%\"}",
        "import:fastapi.\"Health\"",
        "import:fastapi.\"Conservative\"",
        "import:fastapi.\"voting_guides_read\": 5",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.\"2024-12\": 18",
        "import:fastapi.\"activity_type\": \"mp_research\"",
        "import:fastapi.\"social_media\": {\n                \"twitter\": \"@MemberSmith\"",
        "import:fastapi.\"message\": \"Postal code updated successfully\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user's postal code and find their MP.\n    \"\"\"\n    # Validate postal code format (Canadian format)\n    if not postal_code or len(postal_code) < 6:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"French\"",
        "import:fastapi.\"Standing Committee on Health\"\n            ]\n        }",
        "import:fastapi.postal_code: str = Body(...",
        "import:fastapi.\"St. Lawrence Market\"\n        ]",
        "import:fastapi.\"name\": \"Hon. Member Smith\"",
        "import:fastapi.\"Healthcare access\"",
        "import:fastapi.\"demographics\": {\n            \"population\": 125000",
        "import:fastapi.\"Spanish\"]\n        }",
        "import:fastapi.\"active_days\": 45",
        "import:fastapi.\"Eaton Centre\"",
        "import:fastapi.\"browser\": \"Firefox\"",
        "import:fastapi.\"demographics\": {\n                \"median_age\": 35",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"compared\"]\n            }",
        "import:fastapi.\"contact_info\": {\n                \"parliament_office\": \"613-992-1234\"",
        "import:fastapi.description=\"Type of activity to filter\")",
        "import:fastapi.\"Other\": 2\n            }\n        }",
        "import:fastapi.\"data\": mock_mp_data\n    }\n\n\n@router.get(\"/constituency/{postal_code}\")\nasync def get_constituency_by_postal_code(\n    postal_code: str",
        "import:fastapi.List",
        "import:fastapi.\"activity_date\": \"2025-01-15T14:30:00Z\"",
        "import:fastapi.\"afternoon\": 45",
        "import:fastapi.\"Public transit\"",
        "import:fastapi.\"activity_date\": \"2025-01-15T10:15:00Z\"",
        "import:fastapi.\"last_activity\": \"2025-01-15\"",
        "import:fastapi.\"turnout\": \"68.5%\"}",
        "import:fastapi.\"experience\": \"2nd term\"",
        "import:fastapi.Dict",
        "import:fastapi.\"mps\": 23",
        "import:fastapi.\"current_status\": \"Former MP\"\n            }\n        ]",
        "import:fastapi.\"committees\": [\"Standing Committee on Finance\"]\n            }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"Alberta\": 12",
        "import:fastapi.\"parties\": [\"Liberal\"",
        "import:fastapi.\"V-124\"]",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "PUT:/user/{user_id}/preferences": {
      "method": "PUT",
      "path": "/user/{user_id}/preferences",
      "file": "services/api-gateway/app/api/v1/user_profiles.py",
      "line": 445,
      "dependencies": [
        "import:fastapi.\"push\": False",
        "import:fastapi.\"interaction_details\": {\n                \"time_spent\": \"12 minutes\"",
        "import:fastapi.\"content_type\": \"bill\"",
        "import:fastapi.\"favorite_mps\": [\"Hon. Member Smith\"",
        "import:fastapi.\"content_type\": \"vote\"",
        "import:fastapi.\"facebook\": \"MemberSmithMP\"",
        "import:fastapi.\"current_mp\": {\n            \"id\": \"123\"",
        "import:fastapi.\"postal_code\": postal_code",
        "import:fastapi.\"notification_settings\": {\n            \"email\": {\n                \"enabled\": True",
        "import:fastapi.\"committee_work_understood\": \"Intermediate\"",
        "import:fastapi.\"mps\": [\"Hon. Member Smith\"",
        "import:fastapi.\"activity_type\": \"vote_analysis\"",
        "import:fastapi.\"committee_reports\"]\n            }",
        "import:fastapi.\"push\": {\n                \"enabled\": False",
        "import:fastapi.\"browser\": \"Safari\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"content_title\": \"Environmental Protection Act\"",
        "import:fastapi.\"Justice\"",
        "import:fastapi.\"related_content\": {\n                \"bills\": [\"C-123\"]",
        "import:fastapi.\"debates\": 28",
        "import:fastapi.create mock MP data based on postal code\n    # In a full implementation",
        "import:fastapi.Politician",
        "import:fastapi.\"term\": \"2015-2019\"",
        "import:fastapi.\"Mandarin\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get constituency information by postal code.\n    \"\"\"\n    # Validate postal code format\n    if not postal_code or len(postal_code) < 6:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"bill_process_knowledge\": \"Advanced\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"province\": \"Ontario\"",
        "import:fastapi.ge=1",
        "import:fastapi.\"activity_sharing\": \"friends_only\"",
        "import:fastapi.\"Justice\"]",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.\"content_summary\": \"Viewed Bill C-123 on environmental protection\"",
        "import:fastapi.\"median_income\": 75000",
        "import:fastapi.create mock constituency data\n    # In a full implementation",
        "import:fastapi.Any\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_constituency_data = {\n        \"postal_code\": postal_code",
        "import:fastapi.\"2015\": {\"winner\": \"Liberal\"",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"data\": mock_constituency_data\n    }\n\n\n@router.get(\"/user/{user_id}/activity\")\nasync def get_user_activity(\n    user_id: str",
        "import:fastapi.le=100",
        "import:fastapi.\"searched\"",
        "import:fastapi.\"learning_progress\": {\n            \"parliamentary_education_modules\": 3",
        "import:fastapi.\"pages_viewed\": 4",
        "import:fastapi.\"density_per_km2\": 10000",
        "import:fastapi.\"notification_preferences\": {\n                \"email\": True",
        "import:fastapi.\"committees\": 26\n            }",
        "import:fastapi.\"pages_viewed\": 5",
        "import:fastapi.\"margin\": \"18.7%\"",
        "import:fastapi.\"comments\": 45",
        "import:fastapi.\"Transit\"",
        "import:fastapi.\"federal_riding\": \"35061\"",
        "import:fastapi.\"interaction_details\": {\n                \"time_spent\": \"8 minutes\"",
        "import:fastapi.\"election_history\": {\n            \"2021\": {\"winner\": \"Liberal\"",
        "import:fastapi.\"Yonge-Dundas Square\"",
        "import:fastapi.\"actions_taken\": [\"analyzed\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get comprehensive user analytics and statistics.\n    Provides insights into user engagement with parliamentary content.\n    \"\"\"\n    # For now",
        "import:fastapi.\"content_title\": \"Hon. Member Johnson\"",
        "import:fastapi.\"Royal Ontario Museum\"",
        "import:fastapi.HTTPException",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"analytics\": mock_analytics",
        "import:fastapi.\"updated_at\": \"2025-01-15T10:30:00Z\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.detail=\"Invalid postal code format\")\n    \n    # For now",
        "import:fastapi.\"actions_taken\": [\"read\"",
        "import:fastapi.\"British Columbia\": 23",
        "import:fastapi.\"bills_supported\": 23",
        "import:fastapi.create mock user activity data\n    # In a full implementation",
        "import:fastapi.\"engagement_score\": 8.7\n        }",
        "import:fastapi.description=\"User ID for analytics\")",
        "import:fastapi.\"activity_breakdown\": {\n            \"by_month\": {\n                \"2024-11\": 12",
        "import:fastapi.\"constituency\": \"Toronto Centre\"",
        "import:fastapi.\"constituency_office\": \"416-555-1234\"",
        "import:fastapi.\"preferences\": mock_preferences\n    }",
        "import:fastapi.\"riding_name\": \"Toronto Centre\"",
        "import:fastapi.\"provincial_riding\": \"35061\"",
        "import:fastapi.\"previous_mps\": [\n            {\n                \"name\": \"Hon. Member Brown\"",
        "import:fastapi.\"content_preferences\": {\n            \"favorite_topics\": [\"Environment\"",
        "import:fastapi.create mock user preferences\n    # In a full implementation",
        "import:fastapi.\"Economic development\"\n        ]",
        "import:fastapi.\"party_color\": \"#FF9999\"",
        "import:fastapi.\"instagram\": \"membersmithmp\"\n            }\n        }",
        "import:fastapi.\"breaking_news\"]\n            }",
        "import:fastapi.\"excluded_topics\": [\"Sports\"",
        "import:fastapi.\"Green\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed user activity timeline.\n    \"\"\"\n    # For now",
        "import:fastapi.\"interaction_details\": {\n                \"time_spent\": \"5 minutes\"",
        "import:fastapi.\"email\": \"member.smith@parl.gc.ca\"",
        "import:fastapi.\"activity_date\": \"2025-01-14T16:45:00Z\"",
        "import:fastapi.\"debates_read\": 45\n        }",
        "import:fastapi.\"sms\": False\n            }\n        }",
        "import:fastapi.\"C-124\"]",
        "import:fastapi.\"types\": []\n            }\n        }",
        "import:fastapi.\"Hon. Member Davis\"]",
        "import:fastapi.\"display_preferences\": {\n            \"theme\": \"light\"",
        "import:fastapi.\"metadata\": {\n                \"device\": \"Desktop\"",
        "import:fastapi.\"night\": 21\n            }\n        }",
        "import:fastapi.\"content_id\": \"456\"",
        "import:fastapi.\"shared\"",
        "import:fastapi.\"content_title\": \"Vote on Bill C-123\"",
        "import:fastapi.\"show_advanced_features\": True",
        "import:fastapi.\"bills_bookmarked\": 15",
        "import:fastapi.\"frequency\": \"never\"",
        "import:fastapi.\"content_difficulty\": \"Intermediate\"\n        }",
        "import:fastapi.this would come from user activity tracking\n    mock_analytics = {\n        \"user_id\": user_id",
        "import:fastapi.\"preferences\": {\n            \"favorite_topics\": [\"Environment\"",
        "import:fastapi.\"following\": 8\n        }",
        "import:fastapi.Depends",
        "import:fastapi.create mock user analytics data\n    # In a full implementation",
        "import:fastapi.\"constituency_id\": \"35061\"",
        "import:fastapi.\"term\": \"2019-2021\"",
        "import:fastapi.\"Education\"]",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"2025-01\": 25\n            }",
        "import:fastapi.\"activity_type\": \"bill_view\"",
        "import:fastapi.\"constituency\": {\n            \"id\": \"35061\"",
        "import:fastapi.\"party\": \"Liberal\"",
        "import:fastapi.Party",
        "import:fastapi.\"elected_date\": \"2021-09-20\"",
        "import:fastapi.\"show_analytics\": True",
        "import:fastapi.\"Hon. Member Johnson\"]",
        "import:fastapi.ON\"\n            }\n        }",
        "import:fastapi.\"Entertainment\"]",
        "import:fastapi.\"commented\"]\n            }",
        "import:fastapi.\"content_summary\": \"Analyzed voting patterns and party positions\"",
        "import:fastapi.\"languages\": [\"English\"",
        "import:fastapi.\"types\": [\"urgent_alerts\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"name\": \"Toronto Centre\"",
        "import:fastapi.\"key_issues\": [\n            \"Housing affordability\"",
        "import:fastapi.this would query the database for the MP\n    mock_mp_data = {\n        \"user_id\": user_id",
        "import:fastapi.\"filters_applied\": {\n            \"activity_type\": activity_type",
        "import:fastapi.\"accessibility\": {\n            \"high_contrast\": False",
        "import:fastapi.\"committees\": [\"Standing Committee on Environment\"]\n            }",
        "import:fastapi.\"median_age\": 35",
        "import:fastapi.\"committee_memberships\": [\n                \"Standing Committee on Finance\"",
        "import:fastapi.\"evening\": 67",
        "import:fastapi.\"period\": f\"{date_from} to {date_to}\" if date_from and date_to else \"All time\"",
        "import:fastapi.activity_type: Optional[str] = Query(None",
        "import:fastapi.\"sms\": {\n                \"enabled\": False",
        "import:fastapi.\"party\": \"Conservative\"",
        "import:fastapi.\"votes_analyzed\": 67",
        "import:fastapi.\"browser\": \"Chrome\"",
        "import:fastapi.\"privacy_settings\": {\n            \"profile_visibility\": \"public\"",
        "import:fastapi.\"key_issues\": [\"Housing\"",
        "import:fastapi.\"margin\": \"15.2%\"",
        "import:fastapi.\"related_content\": {\n                \"bills\": [\"C-123\"",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"margin\": \"2.1%\"",
        "import:fastapi.this would come from user activity tracking\n    mock_activities = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"content_id\": \"789\"",
        "import:fastapi.\"Healthcare\"]\n        }",
        "import:fastapi.\"mp_details\": {\n            \"id\": \"123\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"Hon. Member Johnson\"",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.\"engagement_summary\": {\n            \"total_visits\": 156",
        "import:fastapi.\"by_content_type\": {\n                \"bills\": 45",
        "import:fastapi.\"notable_places\": [\n            \"University of Toronto\"",
        "import:fastapi.\"favorite_parties\": [\"Liberal\"",
        "import:fastapi.\"Economy\"",
        "import:fastapi.\"Quebec\": 18",
        "import:fastapi.\"education_level\": \"High\"",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"term_start\": \"2021-11-22\"",
        "import:fastapi.\"frequency\": \"daily\"",
        "import:fastapi.\"area_km2\": 12.5",
        "import:fastapi.\"social_engagement\": {\n            \"shares\": 23",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.\"content_summary\": \"Researched MP profile and voting record\"",
        "import:fastapi.\"results\": paginated_activities",
        "import:fastapi.\"followers\": 12",
        "import:fastapi.Query",
        "import:fastapi.this would come from user settings\n    mock_preferences = {\n        \"user_id\": user_id",
        "import:fastapi.\"pages_viewed\": 3",
        "import:fastapi.\"province_breakdown\": {\n                \"Ontario\": 45",
        "import:fastapi.{\n                \"name\": \"Hon. Member Davis\"",
        "import:fastapi.\"municipal_ward\": \"Ward 13\"\n        }",
        "import:fastapi.description=\"New postal code\")",
        "import:fastapi.\"mp_found\": True",
        "import:fastapi.\"website\": \"https://membersmith.liberal.ca\"\n            }",
        "import:fastapi.\"votes\": 34",
        "import:fastapi.\"turnout\": \"70.1%\"}\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"location\": \"Toronto",
        "import:fastapi.\"content_type\": \"mp\"",
        "import:fastapi.\"metadata\": {\n                \"device\": \"Mobile\"",
        "import:fastapi.\"secondary_constituencies\": [\"Vancouver Centre\"",
        "import:fastapi.\"content_interaction\": {\n            \"bills_viewed\": 89",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }\n    }\n\n\n@router.get(\"/user/{user_id}/preferences\")\nasync def get_user_preferences(\n    user_id: str",
        "function:get_user_preferences",
        "import:fastapi.\"current_status\": \"Former MP\"\n            }",
        "import:fastapi.\"content_id\": \"123\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/analytics\")\nasync def get_user_analytics(\n    user_id: str = Query(...",
        "import:fastapi.\"generated_at\": \"2025-01-15T10:30:00Z\"\n    }\n\n\n@router.post(\"/postal-code\")\nasync def update_postal_code(\n    user_id: str = Body(...",
        "import:fastapi.\"mps\": [\"Hon. Member Smith\"]",
        "import:fastapi.\"votes\": [\"V-123\"",
        "import:fastapi.ON\"\n            }\n        }\n    ]\n    \n    # Apply filters\n    filtered_activities = mock_activities\n    \n    if activity_type:\n        filtered_activities = [\n            activity for activity in filtered_activities\n            if activity[\"activity_type\"] == activity_type\n        ]\n    \n    # Apply pagination\n    total = len(filtered_activities)\n    offset = (page - 1) * page_size\n    paginated_activities = filtered_activities[offset:offset + page_size]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"keyboard_navigation\": True",
        "import:fastapi.\"mps_researched\": 34",
        "import:fastapi.\"constituency_info\": {\n            \"population\": 125000",
        "import:fastapi.\"Montreal Centre\"]",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"third_party_sharing\": False\n        }",
        "import:fastapi.\"2019\": {\"winner\": \"Conservative\"",
        "import:fastapi.\"geographic_interest\": {\n            \"primary_constituency\": \"Toronto Centre\"",
        "import:fastapi.\"Green\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\"Environmental protection\"",
        "import:fastapi.\"reduced_motion\": False\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"Environment\"",
        "import:fastapi.\"bookmarked\"]\n            }",
        "import:fastapi.\"by_time_of_day\": {\n                \"morning\": 23",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"NDP\"]\n            }",
        "import:fastapi.\"font_size\": \"medium\"",
        "import:fastapi.\"education_level\": \"High\"\n            }",
        "import:fastapi.\"turnout\": \"65.2%\"}",
        "import:fastapi.\"show_social_features\": False\n        }",
        "import:fastapi.\"Health\"",
        "import:fastapi.\"Conservative\"",
        "import:fastapi.\"voting_guides_read\": 5",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.\"2024-12\": 18",
        "import:fastapi.\"activity_type\": \"mp_research\"",
        "import:fastapi.\"social_media\": {\n                \"twitter\": \"@MemberSmith\"",
        "import:fastapi.\"message\": \"Postal code updated successfully\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user's postal code and find their MP.\n    \"\"\"\n    # Validate postal code format (Canadian format)\n    if not postal_code or len(postal_code) < 6:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"language_preference\": \"English\"",
        "import:fastapi.\"French\"",
        "import:fastapi.\"Standing Committee on Health\"\n            ]\n        }",
        "import:fastapi.postal_code: str = Body(...",
        "import:fastapi.\"St. Lawrence Market\"\n        ]",
        "import:fastapi.\"name\": \"Hon. Member Smith\"",
        "import:fastapi.\"Healthcare access\"",
        "import:fastapi.\"mp_activity\"",
        "import:fastapi.\"demographics\": {\n            \"population\": 125000",
        "import:fastapi.\"Spanish\"]\n        }",
        "import:fastapi.\"active_days\": 45",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get user preferences and settings.\n    \"\"\"\n    # For now",
        "import:fastapi.\"data_collection\": True",
        "import:fastapi.\"Eaton Centre\"",
        "import:fastapi.\"screen_reader\": False",
        "import:fastapi.\"browser\": \"Firefox\"",
        "import:fastapi.\"demographics\": {\n                \"median_age\": 35",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"compared\"]\n            }",
        "import:fastapi.\"contact_info\": {\n                \"parliament_office\": \"613-992-1234\"",
        "import:fastapi.description=\"Type of activity to filter\")",
        "import:fastapi.\"Other\": 2\n            }\n        }",
        "import:fastapi.\"data\": mock_mp_data\n    }\n\n\n@router.get(\"/constituency/{postal_code}\")\nasync def get_constituency_by_postal_code(\n    postal_code: str",
        "import:fastapi.List",
        "import:fastapi.\"activity_date\": \"2025-01-15T14:30:00Z\"",
        "import:fastapi.\"afternoon\": 45",
        "import:fastapi.\"types\": [\"bill_updates\"",
        "import:fastapi.\"Public transit\"",
        "import:fastapi.\"activity_date\": \"2025-01-15T10:15:00Z\"",
        "import:fastapi.\"last_activity\": \"2025-01-15\"",
        "import:fastapi.\"turnout\": \"68.5%\"}",
        "import:fastapi.\"experience\": \"2nd term\"",
        "import:fastapi.Dict",
        "import:fastapi.\"mps\": 23",
        "import:fastapi.\"current_status\": \"Former MP\"\n            }\n        ]",
        "import:fastapi.\"committees\": [\"Standing Committee on Finance\"]\n            }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"Alberta\": 12",
        "import:fastapi.\"parties\": [\"Liberal\"",
        "import:fastapi.\"frequency\": \"realtime\"",
        "import:fastapi.\"NDP\"]",
        "import:fastapi.\"V-124\"]",
        "import:fastapi.\"vote_results\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/{member_id}": {
      "method": "GET",
      "path": "/{member_id}",
      "file": "services/api-gateway/app/api/v1/members.py",
      "line": 106,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Show only current MPs\")",
        "import:fastapi.pages=total_pages\n    )\n    \n    return {\n        \"members\": member_summaries",
        "import:fastapi.MemberProfileResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.\"pagination\": pagination\n    }",
        "import:fastapi.MemberListResponse",
        "import:fastapi.MemberSuggestionsResponse",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.province=member.jurisdiction.province if member.jurisdiction else None",
        "import:fastapi.description=\"Province filter\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.MemberDetail",
        "import:fastapi.party_slug=member.party.short_name if member.party else None",
        "import:fastapi.description=\"Search query for member name\")",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if province:\n        query = query.filter(Member.jurisdiction.has(Jurisdiction.province == province))\n    \n    if party:\n        query = query.filter(Party.name.ilike(f\"%{party}%\"))\n    \n    if current_only:\n        query = query.filter(Member.end_date.is_(None))\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on member names\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.first_name=member.first_name",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    members = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    member_summaries = []\n    for member in members:\n        member_summaries.append(MemberSummary(\n            id=str(member.id)",
        "import:fastapi.start_date=member.start_date",
        "import:fastapi.members.first_name || ' ' || members.last_name\n            ) @@ plainto_tsquery('english'",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import List",
        "import:fastapi.MemberDetailResponse",
        "import:fastapi.Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Member",
        "import:fastapi.Vote",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.party_name=member.party.name if member.party else None",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.full_name=member.full_name or f\"{member.first_name} {member.last_name}\"",
        "import:fastapi.total=total",
        "import:fastapi.response_model=MemberListResponse)\nasync def list_members(\n    q: Optional[str] = Query(None",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.isouter=True).join(Member.party",
        "import:fastapi.Party",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List Members of Parliament with optional filtering and search.\n    \n    Supports:\n    - Full-text search on member names\n    - Filtering by province\n    - Filtering by party\n    - Filtering by current status\n    - Pagination\n    \"\"\"\n    \n    # Build base query - join with jurisdiction and party info\n    query = db.query(Member).join(Member.jurisdiction",
        "import:fastapi.last_name=member.last_name",
        "import:fastapi.MemberSummaryResponse",
        "import:fastapi.end_date=member.end_date\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.Pagination",
        "import:fastapi.description=\"Party slug filter\")",
        "import:fastapi.constituency=member.district",
        "function:list_members",
        "import:fastapi.APIRouter",
        "import:fastapi.is_current=member.end_date is None",
        "import:fastapi.current_only: bool = Query(True",
        "import:fastapi.MemberProfile",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.Jurisdiction\nfrom app.schemas.members import (\n    MemberSummary",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/by-postal-code/{postal_code}": {
      "method": "GET",
      "path": "/by-postal-code/{postal_code}",
      "file": "services/api-gateway/app/api/v1/members.py",
      "line": 155,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Show only current MPs\")",
        "import:fastapi.party_name=member.party.name_en",
        "import:fastapi.province=riding.province if riding else None",
        "import:fastapi.pages=total_pages\n    )\n    \n    return {\n        \"members\": member_summaries",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get riding info\n    riding = db.query(Riding).filter(Riding.id == member.riding_id).first()\n    \n    # Get sponsored bills\n    sponsored_bills = db.query(Bill).filter(Bill.sponsor_member_id == member_id).all()\n    \n    # Get recent votes\n    recent_votes = db.query(\n        Vote",
        "function:get_member_detail",
        "import:fastapi.party_slug=member.party.slug",
        "import:fastapi.MemberProfileResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.MemberListResponse",
        "import:fastapi.Bill\n    ).join(\n        Bill",
        "import:fastapi.MemberSuggestionsResponse",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.province=member.jurisdiction.province if member.jurisdiction else None",
        "import:fastapi.response_model=MemberDetailResponse)\nasync def get_member_detail(\n    member_id: int",
        "import:fastapi.recent_votes_count=len(recent_votes)\n    )\n    \n    return MemberDetailResponse(member=member_detail)",
        "import:fastapi.description=\"Province filter\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.MemberDetail",
        "import:fastapi.party_slug=member.party.short_name if member.party else None",
        "import:fastapi.description=\"Search query for member name\")",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if province:\n        query = query.filter(Member.jurisdiction.has(Jurisdiction.province == province))\n    \n    if party:\n        query = query.filter(Party.name.ilike(f\"%{party}%\"))\n    \n    if current_only:\n        query = query.filter(Member.end_date.is_(None))\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on member names\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.first_name=member.first_name",
        "import:fastapi.sponsored_bills_count=len(sponsored_bills)",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    members = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    member_summaries = []\n    for member in members:\n        member_summaries.append(MemberSummary(\n            id=str(member.id)",
        "import:fastapi.start_date=member.start_date",
        "import:fastapi.Vote.votequestion.bill_id == Bill.id\n    ).filter(\n        Vote.member_id == member_id\n    ).order_by(\n        Vote.date.desc()\n    ).limit(10).all()\n    \n    member_detail = MemberDetail(\n        id=str(member.id)",
        "import:fastapi.members.first_name || ' ' || members.last_name\n            ) @@ plainto_tsquery('english'",
        "import:fastapi.ge=1",
        "import:fastapi.first_name=member.politician.name_given",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import List",
        "import:fastapi.MemberDetailResponse",
        "import:fastapi.Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Member",
        "import:fastapi.Vote",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.party_name=member.party.name if member.party else None",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.full_name=member.full_name or f\"{member.first_name} {member.last_name}\"",
        "import:fastapi.total=total",
        "import:fastapi.response_model=MemberListResponse)\nasync def list_members(\n    q: Optional[str] = Query(None",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.isouter=True).join(Member.party",
        "import:fastapi.Party",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List Members of Parliament with optional filtering and search.\n    \n    Supports:\n    - Full-text search on member names\n    - Filtering by province\n    - Filtering by party\n    - Filtering by current status\n    - Pagination\n    \"\"\"\n    \n    # Build base query - join with jurisdiction and party info\n    query = db.query(Member).join(Member.jurisdiction",
        "import:fastapi.last_name=member.last_name",
        "import:fastapi.MemberSummaryResponse",
        "import:fastapi.end_date=member.end_date\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.\"pagination\": pagination\n    }\n\n\n@router.get(\"/{member_id}\"",
        "import:fastapi.Pagination",
        "import:fastapi.description=\"Party slug filter\")",
        "import:fastapi.full_name=f\"{member.politician.name_given} {member.politician.name_family}\"",
        "import:fastapi.end_date=member.end_date",
        "import:fastapi.constituency=member.district",
        "import:fastapi.constituency=riding.name_en if riding else None",
        "import:fastapi.last_name=member.politician.name_family",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific Member of Parliament.\n    \"\"\"\n    member = db.query(Member).filter(Member.id == member_id).first()\n    \n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.APIRouter",
        "import:fastapi.is_current=member.end_date is None",
        "import:fastapi.current_only: bool = Query(True",
        "import:fastapi.MemberProfile",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.Jurisdiction\nfrom app.schemas.members import (\n    MemberSummary",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/{member_id}/votes": {
      "method": "GET",
      "path": "/{member_id}/votes",
      "file": "services/api-gateway/app/api/v1/members.py",
      "line": 430,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.'Provincial and Municipal Governments'\n        ]",
        "import:fastapi.'constituency': rep.get('district_name'",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n    \n    return MemberSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.cp.name_given\n        LIMIT :limit\n    \"\"\")\n    \n    results = db.execute(suggestions_query",
        "import:fastapi.fall back to basic information\n            representatives['federal'] = {\n                'level': 'federal'",
        "import:fastapi.current_members=current_members",
        "import:fastapi.detail=\"Invalid postal code format. Use format: A1A1A1 or A1A 1A1\")\n    \n    # Format postal code with space\n    formatted_postal_code = f\"{postal_code_clean[:3]} {postal_code_clean[3:]}\"\n    \n    representatives = {}\n    \n    try:\n        # Import httpx for external API calls\n        import httpx\n        \n        # Call Represent Canada API for comprehensive representative information\n        represent_api_url = f\"https://represent.opennorth.ca/postcodes/{postal_code_clean}/\"\n        \n        with httpx.Client(timeout=10.0) as client:\n            response = client.get(represent_api_url)\n        \n        if response.status_code == 200:\n            data = response.json()\n            \n            # Process federal representatives\n            if include_federal and 'representatives_centroid' in data:\n                federal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') == 'MP':\n                        federal_reps.append({\n                            'level': 'federal'",
        "import:fastapi.similarity(cp.name_given || ' ' || cp.name_family",
        "import:fastapi.Member.politician_id == Member.politician_id).join(\n        Bill",
        "import:fastapi.count in province_counts}",
        "import:fastapi.[{}])[0].get('address'",
        "import:fastapi.description=\"Province filter\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.party_slug=member.party.short_name if member.party else None",
        "import:fastapi.'suggestions': [\n                'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.sponsored_bills_count=len(sponsored_bills)",
        "import:fastapi.' '",
        "import:fastapi.province_breakdown={province: count for province",
        "import:fastapi.members.first_name || ' ' || members.last_name\n            ) @@ plainto_tsquery('english'",
        "import:fastapi.ge=1",
        "import:fastapi.'Councillor'",
        "import:fastapi.party_name=member.party.name if member.party else None",
        "import:fastapi.'unknown')}\"",
        "import:fastapi.'message': f'No municipal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.le=100",
        "import:fastapi.Member.politician.name_family\n    ).order_by(db.func.count(Bill.id).desc()).limit(10).all()\n    \n    return MemberSummaryResponse(\n        total_members=total_members",
        "import:fastapi.'MHA']:\n                        provincial_reps.append({\n                            'level': 'provincial'",
        "import:fastapi.end_date=member.end_date\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.end_date=member.end_date",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                ]\n            }\n    \n    except Exception as e:\n        # Fallback to basic information if API call fails\n        representatives['federal'] = {\n            'level': 'federal'",
        "import:fastapi.up-to-date representative information.\n    This endpoint implements the postal code search functionality required by\n    checklist items 51-70 and integrates with Feature F007: Multi-Level Government.\n    \"\"\"\n    \n    # Validate postal code format (Canadian postal code pattern)\n    import re\n    postal_code_clean = postal_code.upper().replace(\" \"",
        "import:fastapi.Jurisdiction\nfrom app.schemas.members import (\n    MemberSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Include federal representatives\")",
        "import:fastapi.'urls': {\n                                'profile': rep.get('url'",
        "import:fastapi.'message': f'No provincial representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.description=\"Show only current MPs\")",
        "import:fastapi.'Parliament of Canada'",
        "import:fastapi.cp.name_family",
        "import:fastapi.pages=total_pages\n    )\n    \n    return {\n        \"members\": member_summaries",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n            ]\n        }\n    \n    if not representatives:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if provincial_reps:\n                    representatives['provincial'] = provincial_reps\n                else:\n                    representatives['provincial'] = {\n                        'level': 'provincial'",
        "import:fastapi.response_model=MemberSummaryResponse)\nasync def get_member_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about Members of Parliament.\n    \"\"\"\n    # Get total MPs\n    total_members = db.query(Member).count()\n    \n    # Current MPs\n    current_members = db.query(Member).filter(\n        Member.end_date.is_(None)\n    ).count()\n    \n    # MPs by party\n    party_counts = db.query(\n        Party.name_en",
        "import:fastapi.Member.politician.name_family).label('full_name')",
        "import:fastapi.'postal_code': formatted_postal_code",
        "import:fastapi.'Contact office for details')\n                            }",
        "import:fastapi.MemberProfileResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.MemberListResponse",
        "import:fastapi.'message': f'Unable to determine representatives for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact your city/town hall for assistance'\n                        ]\n                    }\n        \n        else:\n            # If Represent API doesn't have data",
        "import:fastapi.[{}])[0].get('tel'",
        "import:fastapi.db.func.count(Bill.id).label('bill_count')\n    ).join(Member",
        "import:fastapi.province=member.jurisdiction.province if member.jurisdiction else None",
        "import:fastapi.response_model=MemberDetailResponse)\nasync def get_member_detail(\n    member_id: int",
        "import:fastapi.'MLA'",
        "import:fastapi.'contact_info': {\n                                'office': rep.get('offices'",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    members = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    member_summaries = []\n    for member in members:\n        member_summaries.append(MemberSummary(\n            id=str(member.id)",
        "import:fastapi.description=\"Search query for member suggestions\")",
        "import:fastapi.response_model=MemberSuggestionsResponse)\nasync def get_member_suggestions(\n    q: str = Query(...",
        "import:fastapi.# Dynamic timestamp\n        'accuracy_note': 'Representative information is sourced from the Represent Canada API and is updated regularly'\n    }\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.'Reeve']:\n                        municipal_reps.append({\n                            'level': 'municipal'",
        "import:fastapi.'Provincial Legislature') if rep.get('offices') else 'Provincial Legislature'",
        "import:fastapi.detail=\"No representatives found for the specified postal code and levels\"\n        )\n    \n    return {\n        'postal_code': formatted_postal_code",
        "import:fastapi.min_length=1",
        "function:get_member_summary_stats",
        "import:fastapi.'party_slug': rep.get('party_slug'",
        "import:fastapi.'unknown')}@parl.gc.ca\")\n                            }",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.Party",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List Members of Parliament with optional filtering and search.\n    \n    Supports:\n    - Full-text search on member names\n    - Filtering by province\n    - Filtering by party\n    - Filtering by current status\n    - Pagination\n    \"\"\"\n    \n    # Build base query - join with jurisdiction and party info\n    query = db.query(Member).join(Member.jurisdiction",
        "import:fastapi.include_federal: bool = Query(True",
        "import:fastapi.full_name=f\"{member.politician.name_given} {member.politician.name_family}\"",
        "import:fastapi.'Unknown')",
        "import:fastapi.le=50",
        "import:fastapi.count in party_counts}",
        "import:fastapi.current_only: bool = Query(True",
        "import:fastapi.description=\"Include provincial representatives\")",
        "import:fastapi.db.func.count(Member.id)\n    ).join(Member).group_by(Party.name_en).all()\n    \n    # MPs by province\n    province_counts = db.query(\n        Riding.province",
        "import:fastapi.province=riding.province if riding else None",
        "import:fastapi.db.func.count(Member.id)\n    ).join(Member).filter(\n        Member.end_date.is_(None)\n    ).group_by(Riding.province).all()\n    \n    # Top bill sponsors\n    top_sponsors = db.query(\n        db.func.concat(Member.politician.name_given",
        "import:fastapi.'province': rep.get('province'",
        "import:fastapi.'profile': f\"/api/v1/members/profile/{rep.get('id')}\" if rep.get('id') else None\n                            }\n                        })\n                \n                if federal_reps:\n                    representatives['federal'] = federal_reps\n                else:\n                    representatives['federal'] = {\n                        'level': 'federal'",
        "import:fastapi.ON K1A 0A6'",
        "import:fastapi.'suggestions': [\n                            'Visit your provincial government website to find your MLA/MPP/MNA'",
        "import:fastapi.party_slug=member.party.slug",
        "import:fastapi.{\"query\": q",
        "import:fastapi.MemberSuggestionsResponse",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.MemberDetail",
        "import:fastapi.Member.id == Bill.sponsor_member_id\n    ).group_by(\n        Member.politician_id",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if province:\n        query = query.filter(Member.jurisdiction.has(Jurisdiction.province == province))\n    \n    if party:\n        query = query.filter(Party.name.ilike(f\"%{party}%\"))\n    \n    if current_only:\n        query = query.filter(Member.end_date.is_(None))\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on member names\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.Vote.votequestion.bill_id == Bill.id\n    ).filter(\n        Vote.member_id == member_id\n    ).order_by(\n        Vote.date.desc()\n    ).limit(10).all()\n    \n    member_detail = MemberDetail(\n        id=str(member.id)",
        "import:fastapi.'unknown')",
        "import:fastapi.first_name=member.politician.name_given",
        "import:fastapi.MemberDetailResponse",
        "import:fastapi.Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Member",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Include municipal representatives\")",
        "import:fastapi.Query",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get member name suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return MemberSuggestionsResponse(suggestions=[])\n    \n    # Use trigram similarity for fuzzy matching on politician names\n    suggestions_query = text(\"\"\"\n        SELECT em.id",
        "import:fastapi.'suggestions': [\n                    'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.'MNA'",
        "import:fastapi.full_name=member.full_name or f\"{member.first_name} {member.last_name}\"",
        "import:fastapi.total=total",
        "import:fastapi.'suggestions': [\n                            'Visit your municipal government website to find your councillor'",
        "import:fastapi.'Municipal Office') if rep.get('offices') else 'Municipal Office'",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.isouter=True).join(Member.party",
        "import:fastapi.\"pagination\": pagination\n    }\n\n\n@router.get(\"/{member_id}\"",
        "import:fastapi.description=\"Party slug filter\")",
        "import:fastapi.'urls': {\n                                'parliament': f\"https://www.ourcommons.ca/members/en/{rep.get('slug'",
        "import:fastapi.constituency=member.district",
        "import:fastapi.constituency=riding.name_en if riding else None",
        "import:fastapi.last_name=member.politician.name_family",
        "import:fastapi.\"count\": sponsor.bill_count} for sponsor in top_sponsors]\n    )",
        "import:fastapi.is_current=member.end_date is None",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific Member of Parliament.\n    \"\"\"\n    member = db.query(Member).filter(Member.id == member_id).first()\n    \n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.'member_id': rep.get('id')",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.party_name=member.party.name_en",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get riding info\n    riding = db.query(Riding).filter(Riding.id == member.riding_id).first()\n    \n    # Get sponsored bills\n    sponsored_bills = db.query(Bill).filter(Bill.sponsor_member_id == member_id).all()\n    \n    # Get recent votes\n    recent_votes = db.query(\n        Vote",
        "import:fastapi.'representatives': representatives",
        "import:fastapi.'contact_info': {\n                                'hill_office': 'House of Commons",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find Members of Parliament and other representatives by postal code.\n    \n    Uses the Represent Canada API for accurate",
        "import:fastapi.'full_name': rep.get('name'",
        "import:fastapi.Bill\n    ).join(\n        Bill",
        "import:fastapi.\"full_name\": f\"{row.name_given} {row.name_family}\"",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if municipal_reps:\n                    representatives['municipal'] = municipal_reps\n                else:\n                    representatives['municipal'] = {\n                        'level': 'municipal'",
        "import:fastapi.'suggestions': [\n                            'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.'613-992-4793') if rep.get('offices') else '613-992-4793'",
        "import:fastapi.'Independent')",
        "import:fastapi.description=\"Search query for member name\")",
        "import:fastapi.first_name=member.first_name",
        "import:fastapi.'party': rep.get('party_name'",
        "import:fastapi.'data_sources': [\n            'Represent Canada API'",
        "import:fastapi.start_date=member.start_date",
        "import:fastapi.postal_code_clean):\n        raise HTTPException(status_code=400",
        "import:fastapi.f\"{rep.get('slug'",
        "import:fastapi.'last_updated': '2025-08-22'",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import List",
        "import:fastapi.'phone': rep.get('offices'",
        "import:fastapi.'Contact office for details') if rep.get('offices') else 'Contact office for details'",
        "import:fastapi.Vote",
        "import:fastapi.Ottawa",
        "import:fastapi.cp.name_given",
        "import:fastapi.include_municipal: bool = Query(False",
        "import:fastapi.Member.politician.name_given",
        "import:fastapi.recent_votes_count=len(recent_votes)\n    )\n    \n    return MemberDetailResponse(member=member_detail)\n\n\n@router.get(\"/by-postal-code/{postal_code}\")\nasync def get_members_by_postal_code(\n    postal_code: str",
        "import:fastapi.'Contact your provincial elections office for assistance'\n                        ]\n                    }\n            \n            # Process municipal representatives\n            if include_municipal and 'representatives_centroid' in data:\n                municipal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['Mayor'",
        "import:fastapi.response_model=MemberListResponse)\nasync def list_members(\n    q: Optional[str] = Query(None",
        "import:fastapi.include_provincial: bool = Query(False",
        "import:fastapi.top_sponsors=[{\"name\": sponsor.full_name",
        "import:fastapi.party_breakdown={party: count for party",
        "import:fastapi.last_name=member.last_name",
        "import:fastapi.MemberSummaryResponse",
        "import:fastapi.\"\")\n    if not re.match(r'^[A-Z]\\d[A-Z]\\d[A-Z]\\d$'",
        "import:fastapi.:query) as sim\n        FROM core_member em\n        JOIN core_politician cp ON em.politician_id = cp.id\n        WHERE cp.name_given || ' ' || cp.name_family % :query\n        ORDER BY sim DESC",
        "import:fastapi.Pagination",
        "import:fastapi.\"limit\": limit})\n    \n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Municipality')",
        "import:fastapi.'message': f'No federal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                        ]\n                    }\n            \n            # Process provincial representatives\n            if include_provincial and 'representatives_centroid' in data:\n                provincial_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['MPP'",
        "import:fastapi.'email': rep.get('email'",
        "import:fastapi.APIRouter",
        "import:fastapi.MemberProfile"
      ]
    },
    "GET:/{member_id}/committees": {
      "method": "GET",
      "path": "/{member_id}/committees",
      "file": "services/api-gateway/app/api/v1/members.py",
      "line": 498,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.'Provincial and Municipal Governments'\n        ]",
        "import:fastapi.'constituency': rep.get('district_name'",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n    \n    return MemberSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.cp.name_given\n        LIMIT :limit\n    \"\"\")\n    \n    results = db.execute(suggestions_query",
        "import:fastapi.fall back to basic information\n            representatives['federal'] = {\n                'level': 'federal'",
        "import:fastapi.current_members=current_members",
        "import:fastapi.detail=\"Invalid postal code format. Use format: A1A1A1 or A1A 1A1\")\n    \n    # Format postal code with space\n    formatted_postal_code = f\"{postal_code_clean[:3]} {postal_code_clean[3:]}\"\n    \n    representatives = {}\n    \n    try:\n        # Import httpx for external API calls\n        import httpx\n        \n        # Call Represent Canada API for comprehensive representative information\n        represent_api_url = f\"https://represent.opennorth.ca/postcodes/{postal_code_clean}/\"\n        \n        with httpx.Client(timeout=10.0) as client:\n            response = client.get(represent_api_url)\n        \n        if response.status_code == 200:\n            data = response.json()\n            \n            # Process federal representatives\n            if include_federal and 'representatives_centroid' in data:\n                federal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') == 'MP':\n                        federal_reps.append({\n                            'level': 'federal'",
        "import:fastapi.similarity(cp.name_given || ' ' || cp.name_family",
        "import:fastapi.Member.politician_id == Member.politician_id).join(\n        Bill",
        "import:fastapi.count in province_counts}",
        "import:fastapi.# Simplified - would come from actual vote records\n            \"vote_result\": vote.result",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get voting records for a specific member.\n    \"\"\"\n    # Verify member exists\n    member = db.query(Member).filter(Member.id == member_id).first()\n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.[{}])[0].get('address'",
        "import:fastapi.description=\"Province filter\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.party_slug=member.party.short_name if member.party else None",
        "import:fastapi.'suggestions': [\n                'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.sponsored_bills_count=len(sponsored_bills)",
        "import:fastapi.\"vote_description\": vote.description",
        "import:fastapi.' '",
        "import:fastapi.province_breakdown={province: count for province",
        "import:fastapi.members.first_name || ' ' || members.last_name\n            ) @@ plainto_tsquery('english'",
        "import:fastapi.ge=1",
        "import:fastapi.'Councillor'",
        "import:fastapi.party_name=member.party.name if member.party else None",
        "import:fastapi.'unknown')}\"",
        "import:fastapi.# Simplified\n            \"vote_confidence\": \"medium\"",
        "import:fastapi.'message': f'No municipal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.le=100",
        "import:fastapi.Member.politician.name_family\n    ).order_by(db.func.count(Bill.id).desc()).limit(10).all()\n    \n    return MemberSummaryResponse(\n        total_members=total_members",
        "import:fastapi.'MHA']:\n                        provincial_reps.append({\n                            'level': 'provincial'",
        "import:fastapi.\"vote_date\": vote.date",
        "import:fastapi.end_date=member.end_date\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.end_date=member.end_date",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                ]\n            }\n    \n    except Exception as e:\n        # Fallback to basic information if API call fails\n        representatives['federal'] = {\n            'level': 'federal'",
        "import:fastapi.up-to-date representative information.\n    This endpoint implements the postal code search functionality required by\n    checklist items 51-70 and integrates with Feature F007: Multi-Level Government.\n    \"\"\"\n    \n    # Validate postal code format (Canadian postal code pattern)\n    import re\n    postal_code_clean = postal_code.upper().replace(\" \"",
        "import:fastapi.Jurisdiction\nfrom app.schemas.members import (\n    MemberSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Include federal representatives\")",
        "import:fastapi.'urls': {\n                                'profile': rep.get('url'",
        "import:fastapi.'message': f'No provincial representatives found for postal code {formatted_postal_code}'",
        "function:get_member_votes",
        "import:fastapi.description=\"Show only current MPs\")",
        "import:fastapi.'Parliament of Canada'",
        "import:fastapi.cp.name_family",
        "import:fastapi.pages=total_pages\n    )\n    \n    return {\n        \"members\": member_summaries",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n            ]\n        }\n    \n    if not representatives:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.\"vote_context\": f\"Vote on {vote.votequestion.bill.name_en if vote.votequestion.bill else 'Unknown Bill'}\"",
        "import:fastapi.\"related_amendment\": None",
        "import:fastapi.\"party_position\": \"for\"",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if provincial_reps:\n                    representatives['provincial'] = provincial_reps\n                else:\n                    representatives['provincial'] = {\n                        'level': 'provincial'",
        "import:fastapi.response_model=MemberSummaryResponse)\nasync def get_member_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about Members of Parliament.\n    \"\"\"\n    # Get total MPs\n    total_members = db.query(Member).count()\n    \n    # Current MPs\n    current_members = db.query(Member).filter(\n        Member.end_date.is_(None)\n    ).count()\n    \n    # MPs by party\n    party_counts = db.query(\n        Party.name_en",
        "import:fastapi.Member.politician.name_family).label('full_name')",
        "import:fastapi.'postal_code': formatted_postal_code",
        "import:fastapi.# Simplified\n            \"whip_status\": \"free\"",
        "import:fastapi.'Contact office for details')\n                            }",
        "import:fastapi.MemberProfileResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.MemberListResponse",
        "import:fastapi.'message': f'Unable to determine representatives for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact your city/town hall for assistance'\n                        ]\n                    }\n        \n        else:\n            # If Represent API doesn't have data",
        "import:fastapi.[{}])[0].get('tel'",
        "import:fastapi.db.func.count(Bill.id).label('bill_count')\n    ).join(Member",
        "import:fastapi.province=member.jurisdiction.province if member.jurisdiction else None",
        "import:fastapi.response_model=MemberDetailResponse)\nasync def get_member_detail(\n    member_id: int",
        "import:fastapi.'MLA'",
        "import:fastapi.'contact_info': {\n                                'office': rep.get('offices'",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    members = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    member_summaries = []\n    for member in members:\n        member_summaries.append(MemberSummary(\n            id=str(member.id)",
        "import:fastapi.# Simplified\n            \"opposition_position\": \"neutral\"",
        "import:fastapi.description=\"Search query for member suggestions\")",
        "import:fastapi.response_model=MemberSuggestionsResponse)\nasync def get_member_suggestions(\n    q: str = Query(...",
        "import:fastapi.# Dynamic timestamp\n        'accuracy_note': 'Representative information is sourced from the Represent Canada API and is updated regularly'\n    }\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.'Reeve']:\n                        municipal_reps.append({\n                            'level': 'municipal'",
        "import:fastapi.'Provincial Legislature') if rep.get('offices') else 'Provincial Legislature'",
        "import:fastapi.detail=\"No representatives found for the specified postal code and levels\"\n        )\n    \n    return {\n        'postal_code': formatted_postal_code",
        "import:fastapi.\"vote_type\": \"yes\"",
        "import:fastapi.min_length=1",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }",
        "import:fastapi.'party_slug': rep.get('party_slug'",
        "import:fastapi.'unknown')}@parl.gc.ca\")\n                            }",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.Party",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List Members of Parliament with optional filtering and search.\n    \n    Supports:\n    - Full-text search on member names\n    - Filtering by province\n    - Filtering by party\n    - Filtering by current status\n    - Pagination\n    \"\"\"\n    \n    # Build base query - join with jurisdiction and party info\n    query = db.query(Member).join(Member.jurisdiction",
        "import:fastapi.include_federal: bool = Query(True",
        "import:fastapi.full_name=f\"{member.politician.name_given} {member.politician.name_family}\"",
        "import:fastapi.# Simplified\n            \"constituency_impact\": None",
        "import:fastapi.'Unknown')",
        "import:fastapi.le=50",
        "import:fastapi.count in party_counts}",
        "import:fastapi.current_only: bool = Query(True",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get vote records for this member\n    # Note: This is a simplified implementation. In a full system",
        "import:fastapi.description=\"Include provincial representatives\")",
        "import:fastapi.db.func.count(Member.id)\n    ).join(Member).group_by(Party.name_en).all()\n    \n    # MPs by province\n    province_counts = db.query(\n        Riding.province",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.province=riding.province if riding else None",
        "import:fastapi.db.func.count(Member.id)\n    ).join(Member).filter(\n        Member.end_date.is_(None)\n    ).group_by(Riding.province).all()\n    \n    # Top bill sponsors\n    top_sponsors = db.query(\n        db.func.concat(Member.politician.name_given",
        "import:fastapi.'province': rep.get('province'",
        "import:fastapi.'profile': f\"/api/v1/members/profile/{rep.get('id')}\" if rep.get('id') else None\n                            }\n                        })\n                \n                if federal_reps:\n                    representatives['federal'] = federal_reps\n                else:\n                    representatives['federal'] = {\n                        'level': 'federal'",
        "import:fastapi.ON K1A 0A6'",
        "import:fastapi.'suggestions': [\n                            'Visit your provincial government website to find your MLA/MPP/MNA'",
        "import:fastapi.party_slug=member.party.slug",
        "import:fastapi.{\"query\": q",
        "import:fastapi.\"bill_number\": vote.votequestion.bill.number if vote.votequestion.bill else \"Unknown\"",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.MemberSuggestionsResponse",
        "import:fastapi.# there would be a separate vote record table linking members to votes\n    votes_query = db.query(Vote).join(\n        Vote.votequestion.bill\n    ).filter(\n        Vote.member_id == member_id\n    )\n    \n    # Get total count for pagination\n    total = votes_query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = votes_query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_results = []\n    for vote in votes:\n        vote_results.append({\n            \"id\": str(vote.id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"government_position\": \"neutral\"",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.MemberDetail",
        "import:fastapi.Member.id == Bill.sponsor_member_id\n    ).group_by(\n        Member.politician_id",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if province:\n        query = query.filter(Member.jurisdiction.has(Jurisdiction.province == province))\n    \n    if party:\n        query = query.filter(Party.name.ilike(f\"%{party}%\"))\n    \n    if current_only:\n        query = query.filter(Member.end_date.is_(None))\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on member names\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.Vote.votequestion.bill_id == Bill.id\n    ).filter(\n        Vote.member_id == member_id\n    ).order_by(\n        Vote.date.desc()\n    ).limit(10).all()\n    \n    member_detail = MemberDetail(\n        id=str(member.id)",
        "import:fastapi.'unknown')",
        "import:fastapi.first_name=member.politician.name_given",
        "import:fastapi.MemberDetailResponse",
        "import:fastapi.Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Member",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Include municipal representatives\")",
        "import:fastapi.Query",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get member name suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return MemberSuggestionsResponse(suggestions=[])\n    \n    # Use trigram similarity for fuzzy matching on politician names\n    suggestions_query = text(\"\"\"\n        SELECT em.id",
        "import:fastapi.'suggestions': [\n                    'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.\"committee_recommendation\": None",
        "import:fastapi.'MNA'",
        "import:fastapi.full_name=member.full_name or f\"{member.first_name} {member.last_name}\"",
        "import:fastapi.total=total",
        "import:fastapi.'suggestions': [\n                            'Visit your municipal government website to find your councillor'",
        "import:fastapi.'Municipal Office') if rep.get('offices') else 'Municipal Office'",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.isouter=True).join(Member.party",
        "import:fastapi.\"pagination\": pagination\n    }\n\n\n@router.get(\"/{member_id}\"",
        "import:fastapi.description=\"Party slug filter\")",
        "import:fastapi.'urls': {\n                                'parliament': f\"https://www.ourcommons.ca/members/en/{rep.get('slug'",
        "import:fastapi.constituency=member.district",
        "import:fastapi.constituency=riding.name_en if riding else None",
        "import:fastapi.last_name=member.politician.name_family",
        "import:fastapi.is_current=member.end_date is None",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific Member of Parliament.\n    \"\"\"\n    member = db.query(Member).filter(Member.id == member_id).first()\n    \n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.'member_id': rep.get('id')",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.party_name=member.party.name_en",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get riding info\n    riding = db.query(Riding).filter(Riding.id == member.riding_id).first()\n    \n    # Get sponsored bills\n    sponsored_bills = db.query(Bill).filter(Bill.sponsor_member_id == member_id).all()\n    \n    # Get recent votes\n    recent_votes = db.query(\n        Vote",
        "import:fastapi.\"total\": total",
        "import:fastapi.'representatives': representatives",
        "import:fastapi.'contact_info': {\n                                'hill_office': 'House of Commons",
        "import:fastapi.\"count\": sponsor.bill_count} for sponsor in top_sponsors]\n    )\n\n\n@router.get(\"/{member_id}/votes\")\nasync def get_member_votes(\n    member_id: int",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find Members of Parliament and other representatives by postal code.\n    \n    Uses the Represent Canada API for accurate",
        "import:fastapi.'full_name': rep.get('name'",
        "import:fastapi.Bill\n    ).join(\n        Bill",
        "import:fastapi.\"full_name\": f\"{row.name_given} {row.name_family}\"",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if municipal_reps:\n                    representatives['municipal'] = municipal_reps\n                else:\n                    representatives['municipal'] = {\n                        'level': 'municipal'",
        "import:fastapi.'suggestions': [\n                            'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.\"bill_title\": vote.votequestion.bill.name_en if vote.votequestion.bill else \"Unknown\"",
        "import:fastapi.'613-992-4793') if rep.get('offices') else '613-992-4793'",
        "import:fastapi.\"bill_id\": str(vote.votequestion.bill_id)",
        "import:fastapi.'Independent')",
        "import:fastapi.description=\"Search query for member name\")",
        "import:fastapi.first_name=member.first_name",
        "import:fastapi.'party': rep.get('party_name'",
        "import:fastapi.'data_sources': [\n            'Represent Canada API'",
        "import:fastapi.start_date=member.start_date",
        "import:fastapi.postal_code_clean):\n        raise HTTPException(status_code=400",
        "import:fastapi.f\"{rep.get('slug'",
        "import:fastapi.'last_updated': '2025-08-22'",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import List",
        "import:fastapi.'phone': rep.get('offices'",
        "import:fastapi.'Contact office for details') if rep.get('offices') else 'Contact office for details'",
        "import:fastapi.Vote",
        "import:fastapi.# Simplified\n            \"source\": \"Parliament of Canada\"\n        })\n    \n    return {\n        \"results\": vote_results",
        "import:fastapi.Ottawa",
        "import:fastapi.cp.name_given",
        "import:fastapi.include_municipal: bool = Query(False",
        "import:fastapi.Member.politician.name_given",
        "import:fastapi.recent_votes_count=len(recent_votes)\n    )\n    \n    return MemberDetailResponse(member=member_detail)\n\n\n@router.get(\"/by-postal-code/{postal_code}\")\nasync def get_members_by_postal_code(\n    postal_code: str",
        "import:fastapi.'Contact your provincial elections office for assistance'\n                        ]\n                    }\n            \n            # Process municipal representatives\n            if include_municipal and 'representatives_centroid' in data:\n                municipal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['Mayor'",
        "import:fastapi.response_model=MemberListResponse)\nasync def list_members(\n    q: Optional[str] = Query(None",
        "import:fastapi.include_provincial: bool = Query(False",
        "import:fastapi.top_sponsors=[{\"name\": sponsor.full_name",
        "import:fastapi.party_breakdown={party: count for party",
        "import:fastapi.last_name=member.last_name",
        "import:fastapi.MemberSummaryResponse",
        "import:fastapi.\"\")\n    if not re.match(r'^[A-Z]\\d[A-Z]\\d[A-Z]\\d$'",
        "import:fastapi.:query) as sim\n        FROM core_member em\n        JOIN core_politician cp ON em.politician_id = cp.id\n        WHERE cp.name_given || ' ' || cp.name_family % :query\n        ORDER BY sim DESC",
        "import:fastapi.Pagination",
        "import:fastapi.\"limit\": limit})\n    \n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Municipality')",
        "import:fastapi.'message': f'No federal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                        ]\n                    }\n            \n            # Process provincial representatives\n            if include_provincial and 'representatives_centroid' in data:\n                provincial_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['MPP'",
        "import:fastapi.'email': rep.get('email'",
        "import:fastapi.APIRouter",
        "import:fastapi.MemberProfile",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/{member_id}/activity": {
      "method": "GET",
      "path": "/{member_id}/activity",
      "file": "services/api-gateway/app/api/v1/members.py",
      "line": 568,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.'Provincial and Municipal Governments'\n        ]",
        "import:fastapi.'constituency': rep.get('district_name'",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n    \n    return MemberSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.cp.name_given\n        LIMIT :limit\n    \"\"\")\n    \n    results = db.execute(suggestions_query",
        "import:fastapi.fall back to basic information\n            representatives['federal'] = {\n                'level': 'federal'",
        "import:fastapi.current_members=current_members",
        "import:fastapi.detail=\"Invalid postal code format. Use format: A1A1A1 or A1A 1A1\")\n    \n    # Format postal code with space\n    formatted_postal_code = f\"{postal_code_clean[:3]} {postal_code_clean[3:]}\"\n    \n    representatives = {}\n    \n    try:\n        # Import httpx for external API calls\n        import httpx\n        \n        # Call Represent Canada API for comprehensive representative information\n        represent_api_url = f\"https://represent.opennorth.ca/postcodes/{postal_code_clean}/\"\n        \n        with httpx.Client(timeout=10.0) as client:\n            response = client.get(represent_api_url)\n        \n        if response.status_code == 200:\n            data = response.json()\n            \n            # Process federal representatives\n            if include_federal and 'representatives_centroid' in data:\n                federal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') == 'MP':\n                        federal_reps.append({\n                            'level': 'federal'",
        "import:fastapi.similarity(cp.name_given || ' ' || cp.name_family",
        "import:fastapi.Member.politician_id == Member.politician_id).join(\n        Bill",
        "import:fastapi.\"role\": \"member\"",
        "import:fastapi.count in province_counts}",
        "import:fastapi.# Simplified - would come from actual vote records\n            \"vote_result\": vote.result",
        "import:fastapi.\"amendments_proposed\": 5",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get voting records for a specific member.\n    \"\"\"\n    # Verify member exists\n    member = db.query(Member).filter(Member.id == member_id).first()\n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"source\": \"Parliament of Canada\"\n        }\n    ]\n    \n    # Apply pagination\n    total = len(mock_committees)\n    offset = (page - 1) * page_size\n    paginated_committees = mock_committees[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_committees",
        "import:fastapi.[{}])[0].get('address'",
        "import:fastapi.description=\"Province filter\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.party_slug=member.party.short_name if member.party else None",
        "import:fastapi.'suggestions': [\n                'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "function:get_member_committees",
        "import:fastapi.sponsored_bills_count=len(sponsored_bills)",
        "import:fastapi.\"vote_description\": vote.description",
        "import:fastapi.' '",
        "import:fastapi.province_breakdown={province: count for province",
        "import:fastapi.members.first_name || ' ' || members.last_name\n            ) @@ plainto_tsquery('english'",
        "import:fastapi.ge=1",
        "import:fastapi.'Councillor'",
        "import:fastapi.party_name=member.party.name if member.party else None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get committee memberships for a specific member.\n    \"\"\"\n    # Verify member exists\n    member = db.query(Member).filter(Member.id == member_id).first()\n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.'unknown')}\"",
        "import:fastapi.# Simplified\n            \"vote_confidence\": \"medium\"",
        "import:fastapi.'message': f'No municipal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.\"description\": \"Studies matters related to finance",
        "import:fastapi.le=100",
        "import:fastapi.Member.politician.name_family\n    ).order_by(db.func.count(Bill.id).desc()).limit(10).all()\n    \n    return MemberSummaryResponse(\n        total_members=total_members",
        "import:fastapi.'MHA']:\n                        provincial_reps.append({\n                            'level': 'provincial'",
        "import:fastapi.\"vote_date\": vote.date",
        "import:fastapi.\"committee_type\": \"standing\"",
        "import:fastapi.end_date=member.end_date\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.\"description\": \"Studies matters related to health policy",
        "import:fastapi.end_date=member.end_date",
        "import:fastapi.\"end_date\": member.end_date",
        "import:fastapi.and public health\"",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                ]\n            }\n    \n    except Exception as e:\n        # Fallback to basic information if API call fails\n        representatives['federal'] = {\n            'level': 'federal'",
        "import:fastapi.up-to-date representative information.\n    This endpoint implements the postal code search functionality required by\n    checklist items 51-70 and integrates with Feature F007: Multi-Level Government.\n    \"\"\"\n    \n    # Validate postal code format (Canadian postal code pattern)\n    import re\n    postal_code_clean = postal_code.upper().replace(\" \"",
        "import:fastapi.healthcare delivery",
        "import:fastapi.Jurisdiction\nfrom app.schemas.members import (\n    MemberSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Include federal representatives\")",
        "import:fastapi.'urls': {\n                                'profile': rep.get('url'",
        "import:fastapi.'message': f'No provincial representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.description=\"Show only current MPs\")",
        "import:fastapi.'Parliament of Canada'",
        "import:fastapi.cp.name_family",
        "import:fastapi.pages=total_pages\n    )\n    \n    return {\n        \"members\": member_summaries",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n            ]\n        }\n    \n    if not representatives:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.\"vote_context\": f\"Vote on {vote.votequestion.bill.name_en if vote.votequestion.bill else 'Unknown Bill'}\"",
        "import:fastapi.\"related_amendment\": None",
        "import:fastapi.\"party_position\": \"for\"",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if provincial_reps:\n                    representatives['provincial'] = provincial_reps\n                else:\n                    representatives['provincial'] = {\n                        'level': 'provincial'",
        "import:fastapi.response_model=MemberSummaryResponse)\nasync def get_member_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about Members of Parliament.\n    \"\"\"\n    # Get total MPs\n    total_members = db.query(Member).count()\n    \n    # Current MPs\n    current_members = db.query(Member).filter(\n        Member.end_date.is_(None)\n    ).count()\n    \n    # MPs by party\n    party_counts = db.query(\n        Party.name_en",
        "import:fastapi.Member.politician.name_family).label('full_name')",
        "import:fastapi.'postal_code': formatted_postal_code",
        "import:fastapi.\"meeting_attendance\": 78",
        "import:fastapi.# Simplified\n            \"whip_status\": \"free\"",
        "import:fastapi.'Contact office for details')\n                            }",
        "import:fastapi.MemberProfileResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.\"jurisdiction\": \"Health and healthcare matters\"",
        "import:fastapi.MemberListResponse",
        "import:fastapi.'message': f'Unable to determine representatives for postal code {formatted_postal_code}'",
        "import:fastapi.\"name\": \"Standing Committee on Finance\"",
        "import:fastapi.'Contact your city/town hall for assistance'\n                        ]\n                    }\n        \n        else:\n            # If Represent API doesn't have data",
        "import:fastapi.[{}])[0].get('tel'",
        "import:fastapi.db.func.count(Bill.id).label('bill_count')\n    ).join(Member",
        "import:fastapi.province=member.jurisdiction.province if member.jurisdiction else None",
        "import:fastapi.response_model=MemberDetailResponse)\nasync def get_member_detail(\n    member_id: int",
        "import:fastapi.'MLA'",
        "import:fastapi.'contact_info': {\n                                'office': rep.get('offices'",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    members = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    member_summaries = []\n    for member in members:\n        member_summaries.append(MemberSummary(\n            id=str(member.id)",
        "import:fastapi.# Simplified\n            \"opposition_position\": \"neutral\"",
        "import:fastapi.description=\"Search query for member suggestions\")",
        "import:fastapi.\"total_meetings\": 100",
        "import:fastapi.response_model=MemberSuggestionsResponse)\nasync def get_member_suggestions(\n    q: str = Query(...",
        "import:fastapi.# Dynamic timestamp\n        'accuracy_note': 'Representative information is sourced from the Represent Canada API and is updated regularly'\n    }\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.'Reeve']:\n                        municipal_reps.append({\n                            'level': 'municipal'",
        "import:fastapi.\"amendments_passed\": 1",
        "import:fastapi.'Provincial Legislature') if rep.get('offices') else 'Provincial Legislature'",
        "import:fastapi.detail=\"No representatives found for the specified postal code and levels\"\n        )\n    \n    return {\n        'postal_code': formatted_postal_code",
        "import:fastapi.\"vote_type\": \"yes\"",
        "import:fastapi.min_length=1",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }",
        "import:fastapi.'party_slug': rep.get('party_slug'",
        "import:fastapi.\"jurisdiction\": \"Finance and economic matters\"",
        "import:fastapi.'unknown')}@parl.gc.ca\")\n                            }",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.Party",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List Members of Parliament with optional filtering and search.\n    \n    Supports:\n    - Full-text search on member names\n    - Filtering by province\n    - Filtering by party\n    - Filtering by current status\n    - Pagination\n    \"\"\"\n    \n    # Build base query - join with jurisdiction and party info\n    query = db.query(Member).join(Member.jurisdiction",
        "import:fastapi.include_federal: bool = Query(True",
        "import:fastapi.full_name=f\"{member.politician.name_given} {member.politician.name_family}\"",
        "import:fastapi.# Simplified\n            \"constituency_impact\": None",
        "import:fastapi.'Unknown')",
        "import:fastapi.le=50",
        "import:fastapi.count in party_counts}",
        "import:fastapi.\"meeting_attendance\": 85",
        "import:fastapi.current_only: bool = Query(True",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get vote records for this member\n    # Note: This is a simplified implementation. In a full system",
        "import:fastapi.and economic policy\"",
        "import:fastapi.description=\"Include provincial representatives\")",
        "import:fastapi.db.func.count(Member.id)\n    ).join(Member).group_by(Party.name_en).all()\n    \n    # MPs by province\n    province_counts = db.query(\n        Riding.province",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.province=riding.province if riding else None",
        "import:fastapi.db.func.count(Member.id)\n    ).join(Member).filter(\n        Member.end_date.is_(None)\n    ).group_by(Riding.province).all()\n    \n    # Top bill sponsors\n    top_sponsors = db.query(\n        db.func.concat(Member.politician.name_given",
        "import:fastapi.\"reports_contributed\": 2",
        "import:fastapi.'province': rep.get('province'",
        "import:fastapi.'profile': f\"/api/v1/members/profile/{rep.get('id')}\" if rep.get('id') else None\n                            }\n                        })\n                \n                if federal_reps:\n                    representatives['federal'] = federal_reps\n                else:\n                    representatives['federal'] = {\n                        'level': 'federal'",
        "import:fastapi.\"total_meetings\": 95",
        "import:fastapi.ON K1A 0A6'",
        "import:fastapi.'suggestions': [\n                            'Visit your provincial government website to find your MLA/MPP/MNA'",
        "import:fastapi.party_slug=member.party.slug",
        "import:fastapi.{\"query\": q",
        "import:fastapi.\"bill_number\": vote.votequestion.bill.number if vote.votequestion.bill else \"Unknown\"",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.MemberSuggestionsResponse",
        "import:fastapi.# there would be a separate vote record table linking members to votes\n    votes_query = db.query(Vote).join(\n        Vote.votequestion.bill\n    ).filter(\n        Vote.member_id == member_id\n    )\n    \n    # Get total count for pagination\n    total = votes_query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = votes_query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_results = []\n    for vote in votes:\n        vote_results.append({\n            \"id\": str(vote.id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"government_position\": \"neutral\"",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.MemberDetail",
        "import:fastapi.Member.id == Bill.sponsor_member_id\n    ).group_by(\n        Member.politician_id",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if province:\n        query = query.filter(Member.jurisdiction.has(Jurisdiction.province == province))\n    \n    if party:\n        query = query.filter(Party.name.ilike(f\"%{party}%\"))\n    \n    if current_only:\n        query = query.filter(Member.end_date.is_(None))\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on member names\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.Vote.votequestion.bill_id == Bill.id\n    ).filter(\n        Vote.member_id == member_id\n    ).order_by(\n        Vote.date.desc()\n    ).limit(10).all()\n    \n    member_detail = MemberDetail(\n        id=str(member.id)",
        "import:fastapi.'unknown')",
        "import:fastapi.first_name=member.politician.name_given",
        "import:fastapi.MemberDetailResponse",
        "import:fastapi.Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Member",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Include municipal representatives\")",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{member_id}/committees\")\nasync def get_member_committees(\n    member_id: int",
        "import:fastapi.Query",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get member name suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return MemberSuggestionsResponse(suggestions=[])\n    \n    # Use trigram similarity for fuzzy matching on politician names\n    suggestions_query = text(\"\"\"\n        SELECT em.id",
        "import:fastapi.'suggestions': [\n                    'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.\"committee_recommendation\": None",
        "import:fastapi.'MNA'",
        "import:fastapi.full_name=member.full_name or f\"{member.first_name} {member.last_name}\"",
        "import:fastapi.total=total",
        "import:fastapi.'suggestions': [\n                            'Visit your municipal government website to find your councillor'",
        "import:fastapi.banking",
        "import:fastapi.'Municipal Office') if rep.get('offices') else 'Municipal Office'",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.\"amendments_proposed\": 3",
        "import:fastapi.isouter=True).join(Member.party",
        "import:fastapi.\"pagination\": pagination\n    }\n\n\n@router.get(\"/{member_id}\"",
        "import:fastapi.this would come from a committee_members table\n    mock_committees = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.description=\"Party slug filter\")",
        "import:fastapi.'urls': {\n                                'parliament': f\"https://www.ourcommons.ca/members/en/{rep.get('slug'",
        "import:fastapi.constituency=member.district",
        "import:fastapi.constituency=riding.name_en if riding else None",
        "import:fastapi.last_name=member.politician.name_family",
        "import:fastapi.is_current=member.end_date is None",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific Member of Parliament.\n    \"\"\"\n    member = db.query(Member).filter(Member.id == member_id).first()\n    \n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.'member_id': rep.get('id')",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.party_name=member.party.name_en",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get riding info\n    riding = db.query(Riding).filter(Riding.id == member.riding_id).first()\n    \n    # Get sponsored bills\n    sponsored_bills = db.query(Bill).filter(Bill.sponsor_member_id == member_id).all()\n    \n    # Get recent votes\n    recent_votes = db.query(\n        Vote",
        "import:fastapi.\"total\": total",
        "import:fastapi.'representatives': representatives",
        "import:fastapi.'contact_info': {\n                                'hill_office': 'House of Commons",
        "import:fastapi.\"source\": \"Parliament of Canada\"\n        }",
        "import:fastapi.\"count\": sponsor.bill_count} for sponsor in top_sponsors]\n    )\n\n\n@router.get(\"/{member_id}/votes\")\nasync def get_member_votes(\n    member_id: int",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find Members of Parliament and other representatives by postal code.\n    \n    Uses the Represent Canada API for accurate",
        "import:fastapi.'full_name': rep.get('name'",
        "import:fastapi.Bill\n    ).join(\n        Bill",
        "import:fastapi.\"full_name\": f\"{row.name_given} {row.name_family}\"",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if municipal_reps:\n                    representatives['municipal'] = municipal_reps\n                else:\n                    representatives['municipal'] = {\n                        'level': 'municipal'",
        "import:fastapi.'suggestions': [\n                            'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.\"bill_title\": vote.votequestion.bill.name_en if vote.votequestion.bill else \"Unknown\"",
        "import:fastapi.'613-992-4793') if rep.get('offices') else '613-992-4793'",
        "import:fastapi.\"amendments_passed\": 2",
        "import:fastapi.\"start_date\": member.start_date or \"2020-01-01\"",
        "import:fastapi.\"bill_id\": str(vote.votequestion.bill_id)",
        "import:fastapi.\"reports_contributed\": 3",
        "import:fastapi.\"name\": \"Standing Committee on Health\"",
        "import:fastapi.'Independent')",
        "import:fastapi.description=\"Search query for member name\")",
        "import:fastapi.first_name=member.first_name",
        "import:fastapi.'party': rep.get('party_name'",
        "import:fastapi.'data_sources': [\n            'Represent Canada API'",
        "import:fastapi.start_date=member.start_date",
        "import:fastapi.postal_code_clean):\n        raise HTTPException(status_code=400",
        "import:fastapi.f\"{rep.get('slug'",
        "import:fastapi.'last_updated': '2025-08-22'",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import List",
        "import:fastapi.'phone': rep.get('offices'",
        "import:fastapi.'Contact office for details') if rep.get('offices') else 'Contact office for details'",
        "import:fastapi.detail=\"Member not found\")\n    \n    # For now",
        "import:fastapi.Vote",
        "import:fastapi.# Simplified\n            \"source\": \"Parliament of Canada\"\n        })\n    \n    return {\n        \"results\": vote_results",
        "import:fastapi.Ottawa",
        "import:fastapi.cp.name_given",
        "import:fastapi.include_municipal: bool = Query(False",
        "import:fastapi.Member.politician.name_given",
        "import:fastapi.recent_votes_count=len(recent_votes)\n    )\n    \n    return MemberDetailResponse(member=member_detail)\n\n\n@router.get(\"/by-postal-code/{postal_code}\")\nasync def get_members_by_postal_code(\n    postal_code: str",
        "import:fastapi.'Contact your provincial elections office for assistance'\n                        ]\n                    }\n            \n            # Process municipal representatives\n            if include_municipal and 'representatives_centroid' in data:\n                municipal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['Mayor'",
        "import:fastapi.response_model=MemberListResponse)\nasync def list_members(\n    q: Optional[str] = Query(None",
        "import:fastapi.include_provincial: bool = Query(False",
        "import:fastapi.top_sponsors=[{\"name\": sponsor.full_name",
        "import:fastapi.party_breakdown={party: count for party",
        "import:fastapi.last_name=member.last_name",
        "import:fastapi.MemberSummaryResponse",
        "import:fastapi.\"\")\n    if not re.match(r'^[A-Z]\\d[A-Z]\\d[A-Z]\\d$'",
        "import:fastapi.:query) as sim\n        FROM core_member em\n        JOIN core_politician cp ON em.politician_id = cp.id\n        WHERE cp.name_given || ' ' || cp.name_family % :query\n        ORDER BY sim DESC",
        "import:fastapi.Pagination",
        "import:fastapi.return mock committee data since the current schema doesn't have committee memberships\n    # In a full implementation",
        "import:fastapi.\"limit\": limit})\n    \n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Municipality')",
        "import:fastapi.'message': f'No federal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                        ]\n                    }\n            \n            # Process provincial representatives\n            if include_provincial and 'representatives_centroid' in data:\n                provincial_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['MPP'",
        "import:fastapi.'email': rep.get('email'",
        "import:fastapi.APIRouter",
        "import:fastapi.MemberProfile",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/{member_id}/profile": {
      "method": "GET",
      "path": "/{member_id}/profile",
      "file": "services/api-gateway/app/api/v1/members.py",
      "line": 669,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.'Provincial and Municipal Governments'\n        ]",
        "import:fastapi.'constituency': rep.get('district_name'",
        "import:fastapi.\"similarity\": float(row.sim)\n        })\n    \n    return MemberSuggestionsResponse(suggestions=suggestions)\n\n\n@router.get(\"/summary/stats\"",
        "import:fastapi.\"related_bill\": str(bill.id)",
        "import:fastapi.cp.name_given\n        LIMIT :limit\n    \"\"\")\n    \n    results = db.execute(suggestions_query",
        "import:fastapi.fall back to basic information\n            representatives['federal'] = {\n                'level': 'federal'",
        "import:fastapi.current_members=current_members",
        "import:fastapi.detail=\"Invalid postal code format. Use format: A1A1A1 or A1A 1A1\")\n    \n    # Format postal code with space\n    formatted_postal_code = f\"{postal_code_clean[:3]} {postal_code_clean[3:]}\"\n    \n    representatives = {}\n    \n    try:\n        # Import httpx for external API calls\n        import httpx\n        \n        # Call Represent Canada API for comprehensive representative information\n        represent_api_url = f\"https://represent.opennorth.ca/postcodes/{postal_code_clean}/\"\n        \n        with httpx.Client(timeout=10.0) as client:\n            response = client.get(represent_api_url)\n        \n        if response.status_code == 200:\n            data = response.json()\n            \n            # Process federal representatives\n            if include_federal and 'representatives_centroid' in data:\n                federal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') == 'MP':\n                        federal_reps.append({\n                            'level': 'federal'",
        "import:fastapi.similarity(cp.name_given || ' ' || cp.name_family",
        "import:fastapi.Member.politician_id == Member.politician_id).join(\n        Bill",
        "import:fastapi.\"role\": \"member\"",
        "import:fastapi.count in province_counts}",
        "import:fastapi.# Simplified - would come from actual vote records\n            \"vote_result\": vote.result",
        "import:fastapi.\"amendments_proposed\": 5",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get voting records for a specific member.\n    \"\"\"\n    # Verify member exists\n    member = db.query(Member).filter(Member.id == member_id).first()\n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"date\": member.start_date",
        "import:fastapi.\"source\": \"Parliament of Canada\"\n        }\n    ]\n    \n    # Apply pagination\n    total = len(mock_committees)\n    offset = (page - 1) * page_size\n    paginated_committees = mock_committees[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_committees",
        "import:fastapi.[{}])[0].get('address'",
        "import:fastapi.description=\"Province filter\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"sponsorship\"",
        "import:fastapi.party_slug=member.party.short_name if member.party else None",
        "import:fastapi.'suggestions': [\n                'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.sponsored_bills_count=len(sponsored_bills)",
        "import:fastapi.\"vote_description\": vote.description",
        "import:fastapi.' '",
        "import:fastapi.province_breakdown={province: count for province",
        "import:fastapi.members.first_name || ' ' || members.last_name\n            ) @@ plainto_tsquery('english'",
        "import:fastapi.ge=1",
        "import:fastapi.'Councillor'",
        "import:fastapi.party_name=member.party.name if member.party else None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get committee memberships for a specific member.\n    \"\"\"\n    # Verify member exists\n    member = db.query(Member).filter(Member.id == member_id).first()\n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.'unknown')}\"",
        "import:fastapi.# Simplified\n            \"vote_confidence\": \"medium\"",
        "import:fastapi.'message': f'No municipal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.\"description\": \"Studies matters related to finance",
        "import:fastapi.le=100",
        "import:fastapi.Member.politician.name_family\n    ).order_by(db.func.count(Bill.id).desc()).limit(10).all()\n    \n    return MemberSummaryResponse(\n        total_members=total_members",
        "import:fastapi.\"impact_assessment\": None",
        "import:fastapi.reverse=True)\n    \n    # Apply pagination\n    total = len(activity_items)\n    offset = (page - 1) * page_size\n    paginated_activity = activity_items[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_activity",
        "import:fastapi.'MHA']:\n                        provincial_reps.append({\n                            'level': 'provincial'",
        "import:fastapi.\"vote_date\": vote.date",
        "import:fastapi.\"tags\": [\"bill\"",
        "import:fastapi.\"committee_type\": \"standing\"",
        "import:fastapi.end_date=member.end_date\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.\"description\": \"Studies matters related to health policy",
        "import:fastapi.end_date=member.end_date",
        "import:fastapi.\"date\": bill.introduced or member.start_date",
        "import:fastapi.\"end_date\": member.end_date",
        "import:fastapi.and public health\"",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                ]\n            }\n    \n    except Exception as e:\n        # Fallback to basic information if API call fails\n        representatives['federal'] = {\n            'level': 'federal'",
        "import:fastapi.\"parliament\"]\n        })\n    \n    # Add sponsored bills activity\n    sponsored_bills = db.query(Bill).filter(Bill.sponsor_member_id == member_id).all()\n    for bill in sponsored_bills:\n        activity_items.append({\n            \"id\": f\"bill-{bill.id}\"",
        "import:fastapi.up-to-date representative information.\n    This endpoint implements the postal code search functionality required by\n    checklist items 51-70 and integrates with Feature F007: Multi-Level Government.\n    \"\"\"\n    \n    # Validate postal code format (Canadian postal code pattern)\n    import re\n    postal_code_clean = postal_code.upper().replace(\" \"",
        "import:fastapi.healthcare delivery",
        "import:fastapi.Jurisdiction\nfrom app.schemas.members import (\n    MemberSummary",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Include federal representatives\")",
        "import:fastapi.'urls': {\n                                'profile': rep.get('url'",
        "import:fastapi.\"related_debate\": None",
        "import:fastapi.'message': f'No provincial representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.description=\"Show only current MPs\")",
        "import:fastapi.'Parliament of Canada'",
        "import:fastapi.cp.name_family",
        "import:fastapi.pages=total_pages\n    )\n    \n    return {\n        \"members\": member_summaries",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n            ]\n        }\n    \n    if not representatives:\n        raise HTTPException(\n            status_code=404",
        "import:fastapi.\"vote_context\": f\"Vote on {vote.votequestion.bill.name_en if vote.votequestion.bill else 'Unknown Bill'}\"",
        "import:fastapi.\"related_amendment\": None",
        "import:fastapi.\"party_position\": \"for\"",
        "import:fastapi.\"related_bill\": None",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if provincial_reps:\n                    representatives['provincial'] = provincial_reps\n                else:\n                    representatives['provincial'] = {\n                        'level': 'provincial'",
        "import:fastapi.response_model=MemberSummaryResponse)\nasync def get_member_summary_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get summary statistics about Members of Parliament.\n    \"\"\"\n    # Get total MPs\n    total_members = db.query(Member).count()\n    \n    # Current MPs\n    current_members = db.query(Member).filter(\n        Member.end_date.is_(None)\n    ).count()\n    \n    # MPs by party\n    party_counts = db.query(\n        Party.name_en",
        "import:fastapi.Member.politician.name_family).label('full_name')",
        "import:fastapi.'postal_code': formatted_postal_code",
        "import:fastapi.\"meeting_attendance\": 78",
        "import:fastapi.# Simplified\n            \"whip_status\": \"free\"",
        "import:fastapi.'Contact office for details')\n                            }",
        "import:fastapi.MemberProfileResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.\"jurisdiction\": \"Health and healthcare matters\"",
        "import:fastapi.MemberListResponse",
        "import:fastapi.'message': f'Unable to determine representatives for postal code {formatted_postal_code}'",
        "import:fastapi.\"name\": \"Standing Committee on Finance\"",
        "import:fastapi.'Contact your city/town hall for assistance'\n                        ]\n                    }\n        \n        else:\n            # If Represent API doesn't have data",
        "import:fastapi.[{}])[0].get('tel'",
        "import:fastapi.db.func.count(Bill.id).label('bill_count')\n    ).join(Member",
        "import:fastapi.province=member.jurisdiction.province if member.jurisdiction else None",
        "import:fastapi.response_model=MemberDetailResponse)\nasync def get_member_detail(\n    member_id: int",
        "import:fastapi.\"media_coverage\": []",
        "import:fastapi.'MLA'",
        "import:fastapi.'contact_info': {\n                                'office': rep.get('offices'",
        "import:fastapi.\"public_response\": None",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    members = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    member_summaries = []\n    for member in members:\n        member_summaries.append(MemberSummary(\n            id=str(member.id)",
        "import:fastapi.# Simplified\n            \"opposition_position\": \"neutral\"",
        "import:fastapi.description=\"Search query for member suggestions\")",
        "import:fastapi.\"total_meetings\": 100",
        "import:fastapi.response_model=MemberSuggestionsResponse)\nasync def get_member_suggestions(\n    q: str = Query(...",
        "import:fastapi.# Dynamic timestamp\n        'accuracy_note': 'Representative information is sourced from the Represent Canada API and is updated regularly'\n    }\n\n\n@router.get(\"/suggestions\"",
        "import:fastapi.\"legislation\"]\n        })\n    \n    # Add recent votes activity\n    recent_votes = db.query(Vote).join(\n        Vote.votequestion.bill\n    ).filter(\n        Vote.member_id == member_id\n    ).limit(5).all()\n    \n    for vote in recent_votes:\n        activity_items.append({\n            \"id\": f\"vote-{vote.id}\"",
        "import:fastapi.'Reeve']:\n                        municipal_reps.append({\n                            'level': 'municipal'",
        "import:fastapi.\"tags\": [\"election\"",
        "import:fastapi.\"tags\": [\"vote\"",
        "import:fastapi.\"amendments_passed\": 1",
        "import:fastapi.'Provincial Legislature') if rep.get('offices') else 'Provincial Legislature'",
        "import:fastapi.detail=\"No representatives found for the specified postal code and levels\"\n        )\n    \n    return {\n        'postal_code': formatted_postal_code",
        "import:fastapi.\"vote_type\": \"yes\"",
        "import:fastapi.min_length=1",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }",
        "import:fastapi.'party_slug': rep.get('party_slug'",
        "import:fastapi.\"jurisdiction\": \"Finance and economic matters\"",
        "import:fastapi.'unknown')}@parl.gc.ca\")\n                            }",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.Party",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List Members of Parliament with optional filtering and search.\n    \n    Supports:\n    - Full-text search on member names\n    - Filtering by province\n    - Filtering by party\n    - Filtering by current status\n    - Pagination\n    \"\"\"\n    \n    # Build base query - join with jurisdiction and party info\n    query = db.query(Member).join(Member.jurisdiction",
        "import:fastapi.include_federal: bool = Query(True",
        "import:fastapi.full_name=f\"{member.politician.name_given} {member.politician.name_family}\"",
        "import:fastapi.# Simplified\n            \"constituency_impact\": None",
        "import:fastapi.'Unknown')",
        "import:fastapi.le=50",
        "import:fastapi.count in party_counts}",
        "import:fastapi.create mock activity data based on member information\n    # In a full implementation",
        "import:fastapi.\"date\": vote.date",
        "import:fastapi.\"meeting_attendance\": 85",
        "import:fastapi.current_only: bool = Query(True",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get vote records for this member\n    # Note: This is a simplified implementation. In a full system",
        "import:fastapi.and economic policy\"",
        "import:fastapi.description=\"Include provincial representatives\")",
        "import:fastapi.db.func.count(Member.id)\n    ).join(Member).group_by(Party.name_en).all()\n    \n    # MPs by province\n    province_counts = db.query(\n        Riding.province",
        "import:fastapi.\"title\": \"Elected to Parliament\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.province=riding.province if riding else None",
        "import:fastapi.db.func.count(Member.id)\n    ).join(Member).filter(\n        Member.end_date.is_(None)\n    ).group_by(Riding.province).all()\n    \n    # Top bill sponsors\n    top_sponsors = db.query(\n        db.func.concat(Member.politician.name_given",
        "import:fastapi.\"reports_contributed\": 2",
        "import:fastapi.'province': rep.get('province'",
        "import:fastapi.'profile': f\"/api/v1/members/profile/{rep.get('id')}\" if rep.get('id') else None\n                            }\n                        })\n                \n                if federal_reps:\n                    representatives['federal'] = federal_reps\n                else:\n                    representatives['federal'] = {\n                        'level': 'federal'",
        "import:fastapi.\"total_meetings\": 95",
        "import:fastapi.ON K1A 0A6'",
        "import:fastapi.'suggestions': [\n                            'Visit your provincial government website to find your MLA/MPP/MNA'",
        "import:fastapi.party_slug=member.party.slug",
        "import:fastapi.{\"query\": q",
        "import:fastapi.\"bill_number\": vote.votequestion.bill.number if vote.votequestion.bill else \"Unknown\"",
        "import:fastapi.\"related_committee\": None",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.MemberSuggestionsResponse",
        "import:fastapi.# there would be a separate vote record table linking members to votes\n    votes_query = db.query(Vote).join(\n        Vote.votequestion.bill\n    ).filter(\n        Vote.member_id == member_id\n    )\n    \n    # Get total count for pagination\n    total = votes_query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = votes_query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_results = []\n    for vote in votes:\n        vote_results.append({\n            \"id\": str(vote.id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.\"government_position\": \"neutral\"",
        "import:fastapi.description=\"Number of suggestions to return\")",
        "import:fastapi.MemberDetail",
        "import:fastapi.Member.id == Bill.sponsor_member_id\n    ).group_by(\n        Member.politician_id",
        "import:fastapi.\"description\": f\"Elected as Member of Parliament for {member.riding.name_en if member.riding else 'Unknown Riding'}\"",
        "import:fastapi.\"description\": f\"Participated in vote: {vote.description}\"",
        "import:fastapi.isouter=True)\n    \n    # Apply filters\n    if province:\n        query = query.filter(Member.jurisdiction.has(Jurisdiction.province == province))\n    \n    if party:\n        query = query.filter(Party.name.ilike(f\"%{party}%\"))\n    \n    if current_only:\n        query = query.filter(Member.end_date.is_(None))\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on member names\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.Vote.votequestion.bill_id == Bill.id\n    ).filter(\n        Vote.member_id == member_id\n    ).order_by(\n        Vote.date.desc()\n    ).limit(10).all()\n    \n    member_detail = MemberDetail(\n        id=str(member.id)",
        "import:fastapi.\"description\": f\"Introduced {bill.name_en}\"",
        "import:fastapi.'unknown')",
        "import:fastapi.first_name=member.politician.name_given",
        "import:fastapi.MemberDetailResponse",
        "import:fastapi.Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Member",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Include municipal representatives\")",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{member_id}/committees\")\nasync def get_member_committees(\n    member_id: int",
        "function:get_member_activity",
        "import:fastapi.Query",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get member name suggestions using trigram similarity.\n    \"\"\"\n    if not q or len(q.strip()) < 1:\n        return MemberSuggestionsResponse(suggestions=[])\n    \n    # Use trigram similarity for fuzzy matching on politician names\n    suggestions_query = text(\"\"\"\n        SELECT em.id",
        "import:fastapi.\"participation\"",
        "import:fastapi.'suggestions': [\n                    'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.\"committee_recommendation\": None",
        "import:fastapi.'MNA'",
        "import:fastapi.full_name=member.full_name or f\"{member.first_name} {member.last_name}\"",
        "import:fastapi.total=total",
        "import:fastapi.'suggestions': [\n                            'Visit your municipal government website to find your councillor'",
        "import:fastapi.banking",
        "import:fastapi.'Municipal Office') if rep.get('offices') else 'Municipal Office'",
        "import:fastapi.limit: int = Query(10",
        "import:fastapi.\"amendments_proposed\": 3",
        "import:fastapi.isouter=True).join(Member.party",
        "import:fastapi.\"pagination\": pagination\n    }\n\n\n@router.get(\"/{member_id}\"",
        "import:fastapi.this would come from a committee_members table\n    mock_committees = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.description=\"Party slug filter\")",
        "import:fastapi.'urls': {\n                                'parliament': f\"https://www.ourcommons.ca/members/en/{rep.get('slug'",
        "import:fastapi.constituency=member.district",
        "import:fastapi.\"democracy\"]\n        })\n    \n    # Sort by date (most recent first)\n    activity_items.sort(key=lambda x: x[\"date\"] or \"1900-01-01\"",
        "import:fastapi.constituency=riding.name_en if riding else None",
        "import:fastapi.last_name=member.politician.name_family",
        "import:fastapi.\"related_bill\": str(vote.votequestion.bill_id)",
        "import:fastapi.is_current=member.end_date is None",
        "import:fastapi.this would come from activity tracking tables\n    activity_items = []\n    \n    # Add member election/start activity\n    if member.start_date:\n        activity_items.append({\n            \"id\": f\"election-{member_id}\"",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific Member of Parliament.\n    \"\"\"\n    member = db.query(Member).filter(Member.id == member_id).first()\n    \n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.'member_id': rep.get('id')",
        "import:fastapi.\"has_prev\": page > 1\n        }\n    }\n\n\n@router.get(\"/{member_id}/activity\")\nasync def get_member_activity(\n    member_id: int",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"title\": f\"Sponsored Bill {bill.number}\"",
        "import:fastapi.party_name=member.party.name_en",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.detail=\"Member not found\")\n    \n    # Get riding info\n    riding = db.query(Riding).filter(Riding.id == member.riding_id).first()\n    \n    # Get sponsored bills\n    sponsored_bills = db.query(Bill).filter(Bill.sponsor_member_id == member_id).all()\n    \n    # Get recent votes\n    recent_votes = db.query(\n        Vote",
        "import:fastapi.\"total\": total",
        "import:fastapi.'representatives': representatives",
        "import:fastapi.\"title\": f\"Voted on {vote.votequestion.bill.name_en if vote.votequestion.bill else 'Unknown Bill'}\"",
        "import:fastapi.'contact_info': {\n                                'hill_office': 'House of Commons",
        "import:fastapi.\"source\": \"Parliament of Canada\"\n        }",
        "import:fastapi.\"count\": sponsor.bill_count} for sponsor in top_sponsors]\n    )\n\n\n@router.get(\"/{member_id}/votes\")\nasync def get_member_votes(\n    member_id: int",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find Members of Parliament and other representatives by postal code.\n    \n    Uses the Represent Canada API for accurate",
        "import:fastapi.'full_name': rep.get('name'",
        "import:fastapi.Bill\n    ).join(\n        Bill",
        "import:fastapi.\"full_name\": f\"{row.name_given} {row.name_family}\"",
        "import:fastapi.'Contact office for details')\n                            }\n                        })\n                \n                if municipal_reps:\n                    representatives['municipal'] = municipal_reps\n                else:\n                    representatives['municipal'] = {\n                        'level': 'municipal'",
        "import:fastapi.'suggestions': [\n                            'Visit https://www.elections.ca/Scripts/vis/FindED to find your electoral district'",
        "import:fastapi.\"bill_title\": vote.votequestion.bill.name_en if vote.votequestion.bill else \"Unknown\"",
        "import:fastapi.'613-992-4793') if rep.get('offices') else '613-992-4793'",
        "import:fastapi.\"amendments_passed\": 2",
        "import:fastapi.\"start_date\": member.start_date or \"2020-01-01\"",
        "import:fastapi.\"bill_id\": str(vote.votequestion.bill_id)",
        "import:fastapi.\"reports_contributed\": 3",
        "import:fastapi.\"name\": \"Standing Committee on Health\"",
        "import:fastapi.'Independent')",
        "import:fastapi.description=\"Search query for member name\")",
        "import:fastapi.first_name=member.first_name",
        "import:fastapi.'party': rep.get('party_name'",
        "import:fastapi.'data_sources': [\n            'Represent Canada API'",
        "import:fastapi.start_date=member.start_date",
        "import:fastapi.postal_code_clean):\n        raise HTTPException(status_code=400",
        "import:fastapi.f\"{rep.get('slug'",
        "import:fastapi.'last_updated': '2025-08-22'",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import List",
        "import:fastapi.'phone': rep.get('offices'",
        "import:fastapi.'Contact office for details') if rep.get('offices') else 'Contact office for details'",
        "import:fastapi.detail=\"Member not found\")\n    \n    # For now",
        "import:fastapi.Vote",
        "import:fastapi.# Simplified\n            \"source\": \"Parliament of Canada\"\n        })\n    \n    return {\n        \"results\": vote_results",
        "import:fastapi.Ottawa",
        "import:fastapi.cp.name_given",
        "import:fastapi.include_municipal: bool = Query(False",
        "import:fastapi.Member.politician.name_given",
        "import:fastapi.recent_votes_count=len(recent_votes)\n    )\n    \n    return MemberDetailResponse(member=member_detail)\n\n\n@router.get(\"/by-postal-code/{postal_code}\")\nasync def get_members_by_postal_code(\n    postal_code: str",
        "import:fastapi.'Contact your provincial elections office for assistance'\n                        ]\n                    }\n            \n            # Process municipal representatives\n            if include_municipal and 'representatives_centroid' in data:\n                municipal_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['Mayor'",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get activity timeline for a specific member.\n    \"\"\"\n    # Verify member exists\n    member = db.query(Member).filter(Member.id == member_id).first()\n    if not member:\n        raise HTTPException(status_code=404",
        "import:fastapi.response_model=MemberListResponse)\nasync def list_members(\n    q: Optional[str] = Query(None",
        "import:fastapi.include_provincial: bool = Query(False",
        "import:fastapi.top_sponsors=[{\"name\": sponsor.full_name",
        "import:fastapi.party_breakdown={party: count for party",
        "import:fastapi.last_name=member.last_name",
        "import:fastapi.\"location\": \"House of Commons\"",
        "import:fastapi.MemberSummaryResponse",
        "import:fastapi.\"\")\n    if not re.match(r'^[A-Z]\\d[A-Z]\\d[A-Z]\\d$'",
        "import:fastapi.:query) as sim\n        FROM core_member em\n        JOIN core_politician cp ON em.politician_id = cp.id\n        WHERE cp.name_given || ' ' || cp.name_family % :query\n        ORDER BY sim DESC",
        "import:fastapi.Pagination",
        "import:fastapi.return mock committee data since the current schema doesn't have committee memberships\n    # In a full implementation",
        "import:fastapi.\"limit\": limit})\n    \n    suggestions = []\n    for row in results:\n        suggestions.append({\n            \"id\": str(row.id)",
        "import:fastapi.'Municipality')",
        "import:fastapi.'message': f'No federal representatives found for postal code {formatted_postal_code}'",
        "import:fastapi.'Contact Elections Canada at 1-800-463-6868 for assistance'\n                        ]\n                    }\n            \n            # Process provincial representatives\n            if include_provincial and 'representatives_centroid' in data:\n                provincial_reps = []\n                for rep in data['representatives_centroid']:\n                    if rep.get('elected_office') in ['MPP'",
        "import:fastapi.'email': rep.get('email'",
        "import:fastapi.\"type\": \"parliamentary_event\"",
        "import:fastapi.APIRouter",
        "import:fastapi.MemberProfile",
        "import:fastapi.\"type\": \"amendment\"",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "POST:/app-auth/register": {
      "method": "POST",
      "path": "/app-auth/register",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 22,
      "dependencies": [
        "import:fastapi.Party",
        "import:fastapi.Any",
        "import:fastapi.Body",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Dict",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.VoteQuestion",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================",
        "import:fastapi.APIRouter",
        "import:fastapi.Politician",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "POST:/app-auth/login": {
      "method": "POST",
      "path": "/app-auth/login",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 54,
      "dependencies": [
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "function:register_user",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.Politician",
        "import:fastapi.\"password\"",
        "import:fastapi.Any",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }",
        "import:fastapi.Party",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.Body",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/app/v1/profile": {
      "method": "GET",
      "path": "/app/v1/profile",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 85,
      "dependencies": [
        "function:login_user",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"user\": mock_user\n    }",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.Politician",
        "import:fastapi.\"password\"",
        "import:fastapi.Any",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.Party",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.Body",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Dict",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.APIRouter",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "PUT:/app/v1/profile": {
      "method": "PUT",
      "path": "/app/v1/profile",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 109,
      "dependencies": [
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "function:fetch_profile",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"user\": mock_profile\n    }",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.Politician",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"password\"",
        "import:fastapi.Any",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.Party",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.Body",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.Dict",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.APIRouter",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "POST:/app/v1/change-password": {
      "method": "POST",
      "path": "/app/v1/change-password",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 138,
      "dependencies": [
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"User registration data\")",
        "function:update_profile",
        "import:fastapi.\"user\": updated_profile\n    }",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.Politician",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"password\"",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.Any",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Party",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Body",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.Dict",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.APIRouter",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "DELETE:/app/v1/delete-account": {
      "method": "DELETE",
      "path": "/app/v1/delete-account",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 158,
      "dependencies": [
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "function:change_password",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.Politician",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.Any",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Party",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Body",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.Dict",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.APIRouter",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/app/v1/bills": {
      "method": "GET",
      "path": "/app/v1/bills",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 182,
      "dependencies": [
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.Politician",
        "function:delete_account",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.Any",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Party",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Body",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.Dict",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.APIRouter",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/app/v1/bills/{bill_id}": {
      "method": "GET",
      "path": "/app/v1/bills/{bill_id}",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 227,
      "dependencies": [
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.Politician",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "function:get_bills_list",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.\"data\": mock_bills\n    }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "POST:/app/v1/bills/{bill_id}/support": {
      "method": "POST",
      "path": "/app/v1/bills/{bill_id}/support",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 259,
      "dependencies": [
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"bookmark\": False\n    }",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "function:get_bill_detail",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "POST:/app/v1/bills/{bill_id}/bookmark": {
      "method": "POST",
      "path": "/app/v1/bills/{bill_id}/bookmark",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 279,
      "dependencies": [
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "function:support_oppose_bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "POST:/app/v1/issues/create": {
      "method": "POST",
      "path": "/app/v1/issues/create",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 298,
      "dependencies": [
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/bookmark\")\nasync def bookmark_bill(\n    bill_id: int",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"bookmarked\": False",
        "function:bookmark_bill",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark a bill (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.this would toggle the bookmark\n    return {\n        \"success\": True\n    }\n\n\n# ============================================================================\n# 3. ISSUES APIs\n# ============================================================================",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "POST:/app/v1/issues/{issue_id}/support": {
      "method": "POST",
      "path": "/app/v1/issues/{issue_id}/support",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 328,
      "dependencies": [
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/bookmark\")\nasync def bookmark_bill(\n    bill_id: int",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"title\"",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.description=\"Issue creation data\")",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_id\"",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would toggle the bookmark\n    return {\n        \"success\": True\n    }\n\n\n# ============================================================================\n# 3. ISSUES APIs\n# ============================================================================\n\n@router.post(\"/app/v1/issues/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"related_bill\": issue_data[\"bill_id\"]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"title\": issue_data[\"title\"]",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.return mock issue response\n    # In a full implementation",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"status\": \"open\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.this would create the issue\n    mock_issue = {\n        \"id\": 301",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark a bill (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.\"issue\": mock_issue\n    }",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "function:create_issue",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "POST:/app/v1/issues/{issue_id}/bookmark": {
      "method": "POST",
      "path": "/app/v1/issues/{issue_id}/bookmark",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 346,
      "dependencies": [
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/bookmark\")\nasync def bookmark_bill(\n    bill_id: int",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"title\"",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    return {\n        \"success\": True\n    }",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.description=\"Issue support data\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.description=\"Issue creation data\")",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support an issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_id\"",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would toggle the bookmark\n    return {\n        \"success\": True\n    }\n\n\n# ============================================================================\n# 3. ISSUES APIs\n# ============================================================================\n\n@router.post(\"/app/v1/issues/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"related_bill\": issue_data[\"bill_id\"]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"title\": issue_data[\"title\"]",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "function:support_issue",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.return mock issue response\n    # In a full implementation",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"issue\": mock_issue\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/support\")\nasync def support_issue(\n    issue_id: int",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"status\": \"open\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.this would create the issue\n    mock_issue = {\n        \"id\": 301",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark a bill (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "POST:/app/v1/issues/{issue_id}/request-deletion": {
      "method": "POST",
      "path": "/app/v1/issues/{issue_id}/request-deletion",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 359,
      "dependencies": [
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/bookmark\")\nasync def bookmark_bill(\n    bill_id: int",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/bookmark\")\nasync def bookmark_issue(\n    issue_id: int",
        "import:fastapi.\"title\"",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "function:bookmark_issue",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.description=\"Issue support data\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark an issue (mobile app compatible).\n    \"\"\"\n    return {\n        \"success\": True\n    }",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.description=\"Issue creation data\")",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support an issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_id\"",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would toggle the bookmark\n    return {\n        \"success\": True\n    }\n\n\n# ============================================================================\n# 3. ISSUES APIs\n# ============================================================================\n\n@router.post(\"/app/v1/issues/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"related_bill\": issue_data[\"bill_id\"]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"title\": issue_data[\"title\"]",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.return mock issue response\n    # In a full implementation",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"issue\": mock_issue\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/support\")\nasync def support_issue(\n    issue_id: int",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"status\": \"open\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.this would create the issue\n    mock_issue = {\n        \"id\": 301",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark a bill (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "GET:/app/v1/representatives": {
      "method": "GET",
      "path": "/app/v1/representatives",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 384,
      "dependencies": [
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/bookmark\")\nasync def bookmark_bill(\n    bill_id: int",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/bookmark\")\nasync def bookmark_issue(\n    issue_id: int",
        "import:fastapi.\"title\"",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Request issue deletion (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"]\n    for field in required_fields:\n        if field not in deletion_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"message\": \"Issue deletion requested\"\n    }\n\n\n# ============================================================================\n# 4. REPRESENTATIVE APIs\n# ============================================================================",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.description=\"Issue support data\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Issue deletion request data\")",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.description=\"Issue creation data\")",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support an issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_id\"",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.deletion_data: Dict[str",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would toggle the bookmark\n    return {\n        \"success\": True\n    }\n\n\n# ============================================================================\n# 3. ISSUES APIs\n# ============================================================================\n\n@router.post(\"/app/v1/issues/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"related_bill\": issue_data[\"bill_id\"]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"title\": issue_data[\"title\"]",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.return mock issue response\n    # In a full implementation",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"issue\": mock_issue\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/support\")\nasync def support_issue(\n    issue_id: int",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "function:request_issue_deletion",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"status\": \"open\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.this would create the issue\n    mock_issue = {\n        \"id\": 301",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark a bill (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark an issue (mobile app compatible).\n    \"\"\"\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/request-deletion\")\nasync def request_issue_deletion(\n    issue_id: int",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "GET:/app/v1/representatives/all": {
      "method": "GET",
      "path": "/app/v1/representatives/all",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 410,
      "dependencies": [
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/bookmark\")\nasync def bookmark_bill(\n    bill_id: int",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/bookmark\")\nasync def bookmark_issue(\n    issue_id: int",
        "import:fastapi.\"title\"",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Request issue deletion (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"]\n    for field in required_fields:\n        if field not in deletion_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "function:find_user_representative",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.description=\"Issue support data\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.\"message\": \"Issue deletion requested\"\n    }\n\n\n# ============================================================================\n# 4. REPRESENTATIVE APIs\n# ============================================================================\n\n@router.get(\"/app/v1/representatives\")\nasync def find_user_representative(\n    postal_code: str = Query(...",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Issue deletion request data\")",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.description=\"Issue creation data\")",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support an issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"representative\": mock_representative\n    }",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_id\"",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.deletion_data: Dict[str",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would toggle the bookmark\n    return {\n        \"success\": True\n    }\n\n\n# ============================================================================\n# 3. ISSUES APIs\n# ============================================================================\n\n@router.post(\"/app/v1/issues/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.return mock representative data\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"phone\": \"+123456789\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"related_bill\": issue_data[\"bill_id\"]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"User's postal code\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"title\": issue_data[\"title\"]",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.return mock issue response\n    # In a full implementation",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"issue\": mock_issue\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/support\")\nasync def support_issue(\n    issue_id: int",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.this would query the database\n    mock_representative = {\n        \"id\": 401",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"status\": \"open\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.this would create the issue\n    mock_issue = {\n        \"id\": 301",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find user's representative by postal code (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark a bill (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"name\": \"Jane Doe\"",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.\"constituency\": \"Central\"",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark an issue (mobile app compatible).\n    \"\"\"\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/request-deletion\")\nasync def request_issue_deletion(\n    issue_id: int",
        "import:fastapi.\"contact_info\": {\n            \"email\": \"jane.doe@parliament.gov\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "GET:/app/v1/chat/get-bill": {
      "method": "GET",
      "path": "/app/v1/chat/get-bill",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 442,
      "dependencies": [
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/bookmark\")\nasync def bookmark_bill(\n    bill_id: int",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/bookmark\")\nasync def bookmark_issue(\n    issue_id: int",
        "import:fastapi.\"title\"",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Request issue deletion (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"]\n    for field in required_fields:\n        if field not in deletion_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "function:search_representatives",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"name\": \"John Smith\"",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"contact_info\": {\n                \"email\": \"john.smith@parliament.gov\"",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.description=\"Issue support data\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"representative\": mock_representative\n    }\n\n\n@router.get(\"/app/v1/representatives/all\")\nasync def search_representatives(\n    search: str = Query(...",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.\"message\": \"Issue deletion requested\"\n    }\n\n\n# ============================================================================\n# 4. REPRESENTATIVE APIs\n# ============================================================================\n\n@router.get(\"/app/v1/representatives\")\nasync def find_user_representative(\n    postal_code: str = Query(...",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"phone\": \"+987654321\"\n            }\n        }\n    ]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Issue deletion request data\")",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.description=\"Issue creation data\")",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support an issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_id\"",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.deletion_data: Dict[str",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would toggle the bookmark\n    return {\n        \"success\": True\n    }\n\n\n# ============================================================================\n# 3. ISSUES APIs\n# ============================================================================\n\n@router.post(\"/app/v1/issues/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.return mock representative data\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"phone\": \"+123456789\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"related_bill\": issue_data[\"bill_id\"]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"User's postal code\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"title\": issue_data[\"title\"]",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.return mock issue response\n    # In a full implementation",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.this would query the database\n    mock_representatives = [\n        {\n            \"id\": 402",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"issue\": mock_issue\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/support\")\nasync def support_issue(\n    issue_id: int",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.this would query the database\n    mock_representative = {\n        \"id\": 401",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Search all representatives (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"status\": \"open\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.this would create the issue\n    mock_issue = {\n        \"id\": 301",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find user's representative by postal code (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark a bill (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Search query for representatives\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.return mock representatives data\n    # In a full implementation",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.\"data\": mock_representatives\n    }\n\n\n# ============================================================================\n# 5. CHAT/GPT APIs\n# ============================================================================",
        "import:fastapi.\"name\": \"Jane Doe\"",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.\"constituency\": \"Central\"",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark an issue (mobile app compatible).\n    \"\"\"\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/request-deletion\")\nasync def request_issue_deletion(\n    issue_id: int",
        "import:fastapi.\"constituency\": \"North\"",
        "import:fastapi.\"contact_info\": {\n            \"email\": \"jane.doe@parliament.gov\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "POST:/app/v1/chat/bill-chat": {
      "method": "POST",
      "path": "/app/v1/chat/bill-chat",
      "file": "services/api-gateway/app/api/v1/mobile_app.py",
      "line": 460,
      "dependencies": [
        "import:fastapi.this would record the vote\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/bookmark\")\nasync def bookmark_bill(\n    bill_id: int",
        "import:fastapi.\"email\"]\n    for field in required_fields:\n        if field not in delete_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/bookmark\")\nasync def bookmark_issue(\n    issue_id: int",
        "import:fastapi.\"title\"",
        "import:fastapi.\"email\": user_data[\"email\"]",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Request issue deletion (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"]\n    for field in required_fields:\n        if field not in deletion_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"email\": login_data[\"email\"]",
        "import:fastapi.\"name\": \"Ashish Tandon\"",
        "import:fastapi.create mock user response\n    # In a full implementation",
        "import:fastapi.this would update the user's profile\n    updated_profile = {\n        \"id\": 101",
        "import:fastapi.{\n            \"id\": 202",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill detail (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.Politician",
        "import:fastapi.return mock bill detail\n    # In a full implementation",
        "import:fastapi.\"postal_code\": profile_data.get(\"postal_code\"",
        "import:fastapi.\"user\": mock_user\n    }\n\n\n@router.get(\"/app/v1/profile\")\nasync def fetch_profile(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Fetch user profile (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"summary\": mock_summary\n    }",
        "import:fastapi.\"avatar\": profile_data.get(\"avatar\"",
        "import:fastapi.\"description\": \"Addresses climate change concerns.\"",
        "import:fastapi.\"bookmarked\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update user profile (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"]\n    for field in required_fields:\n        if field not in profile_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"name\": \"John Smith\"",
        "import:fastapi.\"https://cdn.domain.com/avatars/101.png\")",
        "import:fastapi.\"contact_info\": {\n                \"email\": \"john.smith@parliament.gov\"",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"password\"]\n    for field in required_fields:\n        if field not in login_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.description=\"Login credentials\")",
        "import:fastapi.description=\"Issue support data\")",
        "import:fastapi.\"number\": \"B-234\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # For now",
        "import:fastapi.this would get the authenticated user's profile\n    mock_profile = {\n        \"id\": 101",
        "import:fastapi.this would create a user in the database\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"representative\": mock_representative\n    }\n\n\n@router.get(\"/app/v1/representatives/all\")\nasync def search_representatives(\n    search: str = Query(...",
        "import:fastapi.\"A1B2C3\")\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"role\": 0\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"email\": \"ashish@example.com\"",
        "import:fastapi.this would query the database\n    mock_bill = {\n        \"id\": bill_id",
        "import:fastapi.return mock updated profile\n    # In a full implementation",
        "import:fastapi.\"message\": \"Issue deletion requested\"\n    }\n\n\n# ============================================================================\n# 4. REPRESENTATIVE APIs\n# ============================================================================\n\n@router.get(\"/app/v1/representatives\")\nasync def find_user_representative(\n    postal_code: str = Query(...",
        "import:fastapi.return success response\n    # In a full implementation",
        "import:fastapi.\"phone\": \"+987654321\"\n            }\n        }\n    ]\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"name\": profile_data[\"name\"]",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# 1. USER APIs\n# ============================================================================\n\n@router.post(\"/app-auth/register\")\nasync def register_user(\n    user_data: Dict[str",
        "import:fastapi.\"email\"",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Issue deletion request data\")",
        "import:fastapi.create mock login response\n    # In a full implementation",
        "import:fastapi.description=\"Issue creation data\")",
        "import:fastapi.\"postal_code\"]\n    for field in required_fields:\n        if field not in user_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support an issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new issue (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_id\"",
        "import:fastapi.\"number\": \"B-235\"",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.deletion_data: Dict[str",
        "import:fastapi.\"postal_code\": user_data[\"postal_code\"]",
        "import:fastapi.\"title\": \"Climate Action Bill\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"",
        "import:fastapi.this would toggle the bookmark\n    return {\n        \"success\": True\n    }\n\n\n# ============================================================================\n# 3. ISSUES APIs\n# ============================================================================\n\n@router.post(\"/app/v1/issues/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.return mock representative data\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get list of bills (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": mock_user",
        "import:fastapi.\"phone\": \"+123456789\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"related_bill\": issue_data[\"bill_id\"]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"User's postal code\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support or oppose a bill (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    if \"support\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"title\": issue_data[\"title\"]",
        "import:fastapi.\"name\": user_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.description=\"Support/oppose data\")",
        "import:fastapi.description=\"Bill ID for chat context\")",
        "import:fastapi.\"vote_cast\": \"support\"",
        "import:fastapi.Party",
        "import:fastapi.\"data\": mock_representatives\n    }\n\n\n# ============================================================================\n# 5. CHAT/GPT APIs\n# ============================================================================\n\n@router.get(\"/app/v1/chat/get-bill\")\nasync def get_bill_for_chat(\n    bill_id: int = Query(...",
        "import:fastapi.this would validate credentials\n    mock_user = {\n        \"id\": 101",
        "import:fastapi.\"new_password\"]\n    for field in required_fields:\n        if field not in password_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.return mock issue response\n    # In a full implementation",
        "import:fastapi.\"support_percentage\": 65",
        "import:fastapi.this would query the database\n    mock_representatives = [\n        {\n            \"id\": 402",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Login user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"email\"",
        "import:fastapi.\"issue\": mock_issue\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/support\")\nasync def support_issue(\n    issue_id: int",
        "import:fastapi.ElectedMember",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Change user password (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"old_password\"",
        "import:fastapi.\"message\": \"Account deleted.\"\n    }\n\n\n# ============================================================================\n# 2. BILLS APIs\n# ============================================================================\n\n@router.get(\"/app/v1/bills\")\nasync def get_bills_list(\n    search: Optional[str] = Query(None",
        "import:fastapi.\"support_percentage\": 78",
        "import:fastapi.this would query the database\n    mock_representative = {\n        \"id\": 401",
        "function:get_bill_for_chat",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.this would query the database\n    mock_bills = [\n        {\n            \"id\": 201",
        "import:fastapi.Any",
        "import:fastapi.\"token\": \"jwt-token-abc123\"",
        "import:fastapi.this would query the database\n    mock_summary = \"The Education Reform Act improves standards and funding for public schools.\"\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Search all representatives (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"user\": updated_profile\n    }\n\n\n@router.post(\"/app/v1/change-password\")\nasync def change_password(\n    password_data: Dict[str",
        "import:fastapi.\"avatar\": \"https://cdn.domain.com/avatars/101.png\"",
        "import:fastapi.\"status\": \"open\"",
        "import:fastapi.\"bookmarked\": False",
        "import:fastapi.\"token\": \"jwt-token-abc123\"\n    }\n\n\n@router.post(\"/app-auth/login\")\nasync def login_user(\n    login_data: Dict[str",
        "import:fastapi.description=\"Search query for bills\")",
        "import:fastapi.this would create the issue\n    mock_issue = {\n        \"id\": 301",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"title\": \"Education Reform Act\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Find user's representative by postal code (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.return mock profile\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark a bill (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"app_summary\": \"Reforms educational standards and funding.\"\n        }",
        "import:fastapi.\"oppose_percentage\": 22",
        "import:fastapi.description=\"User registration data\")",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Search query for representatives\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete user account (mobile app compatible).\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"reason\"",
        "import:fastapi.\"postal_code\": \"A1B2C3\"\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"oppose_percentage\": 35",
        "import:fastapi.description=\"Profile update data\")",
        "import:fastapi.return mock representatives data\n    # In a full implementation",
        "import:fastapi.description=\"Account deletion data\")",
        "import:fastapi.\"data\": mock_bills\n    }\n\n\n@router.get(\"/app/v1/bills/{bill_id}\")\nasync def get_bill_detail(\n    bill_id: int",
        "import:fastapi.return mock bill summary\n    # In a full implementation",
        "import:fastapi.description=\"Password change data\")",
        "import:fastapi.\"password\"",
        "import:fastapi.\"data\": mock_bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill summary for chat (mobile app compatible).\n    \"\"\"\n    # For now",
        "import:fastapi.\"name\": \"Jane Doe\"",
        "import:fastapi.\"message\": \"Password updated successfully.\"\n    }\n\n\n@router.delete(\"/app/v1/delete-account\")\nasync def delete_account(\n    delete_data: Dict[str",
        "import:fastapi.\"bookmark\": False\n    }\n\n\n@router.post(\"/app/v1/bills/{bill_id}/support\")\nasync def support_oppose_bill(\n    bill_id: int",
        "import:fastapi.\"constituency\": \"Central\"",
        "import:fastapi.return mock bills data\n    # In a full implementation",
        "import:fastapi.VoteQuestion",
        "import:fastapi.detail=\"Missing required field: support\")\n    \n    # For now",
        "import:fastapi.\"user\": mock_profile\n    }\n\n\n@router.put(\"/app/v1/profile\")\nasync def update_profile(\n    profile_data: Dict[str",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Bookmark an issue (mobile app compatible).\n    \"\"\"\n    return {\n        \"success\": True\n    }\n\n\n@router.post(\"/app/v1/issues/{issue_id}/request-deletion\")\nasync def request_issue_deletion(\n    issue_id: int",
        "import:fastapi.\"constituency\": \"North\"",
        "import:fastapi.\"contact_info\": {\n            \"email\": \"jane.doe@parliament.gov\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"description\": \"Improves public education.\"",
        "import:fastapi.\"app_summary\": \"Implements climate change mitigation strategies.\"\n        }\n    ]\n    \n    # Apply search filter if provided\n    if search:\n        mock_bills = [bill for bill in mock_bills if search.lower() in bill[\"title\"].lower()]\n    \n    return {\n        \"success\": True"
      ]
    },
    "POST:/sessions": {
      "method": "POST",
      "path": "/sessions",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 44,
      "dependencies": [
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.HouseStatus",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.IndividualVote",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.WebSocket",
        "import:fastapi.HouseDebate",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.Path",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.HouseVote",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.HouseSitting",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.HTTPException",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_"
      ]
    },
    "GET:/sessions": {
      "method": "GET",
      "path": "/sessions",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 91,
      "dependencies": [
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.end_date=session.end_date",
        "function:create_house_session",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.status=session.status",
        "import:fastapi.HouseStatus",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.IndividualVote",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.WebSocket",
        "import:fastapi.HouseDebate",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.Path",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseVote",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.HouseSitting",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.Body",
        "import:fastapi.updated_at=session.updated_at\n    )",
        "import:fastapi.APIRouter",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.HTTPException",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_"
      ]
    },
    "GET:/sessions/{session_id}": {
      "method": "GET",
      "path": "/sessions/{session_id}",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 156,
      "dependencies": [
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.page_size=page_size",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.status=session.status",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseStatus",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.HouseDebate",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.Path",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.le=100",
        "import:fastapi.HouseVote",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.total=total",
        "function:list_house_sessions",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.page=page",
        "import:fastapi.HouseSitting",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.HTTPException",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_"
      ]
    },
    "PUT:/sessions/{session_id}": {
      "method": "PUT",
      "path": "/sessions/{session_id}",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 186,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "function:get_house_session",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.status=session.status",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.HouseDebate",
        "import:fastapi.le=100",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.updated_at=session.updated_at\n    )",
        "import:fastapi.HTTPException",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.HouseStatus",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.HouseVote",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.HouseSitting",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404"
      ]
    },
    "POST:/sessions/{session_id}/sittings": {
      "method": "POST",
      "path": "/sessions/{session_id}/sittings",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 234,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.status=session.status",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.HouseDebate",
        "import:fastapi.le=100",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HTTPException",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "function:update_house_session",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.HouseStatus",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.HouseVote",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.HouseSitting",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404"
      ]
    },
    "GET:/sessions/{session_id}/sittings": {
      "method": "GET",
      "path": "/sessions/{session_id}/sittings",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 277,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.status=session.status",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.HouseDebate",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HTTPException",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.HouseVote",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "function:create_house_sitting",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.HouseSitting",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.updated_at=sitting.updated_at\n    )",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.sitting_date=sitting.sitting_date"
      ]
    },
    "POST:/sessions/{session_id}/votes": {
      "method": "POST",
      "path": "/sessions/{session_id}/votes",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 350,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.description=\"Filter by sitting status\")",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.status=session.status",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.HouseDebate",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HTTPException",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.updated_at=sitting.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.updated_at=sitting.updated_at\n        ))\n    \n    return HouseSittingListResponse(\n        sittings=sitting_responses",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.HouseEventResponse",
        "function:list_house_sittings",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# HOUSE VOTES\n# ============================================================================",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.HouseVote",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.response_model=HouseSittingListResponse)\nasync def list_house_sittings(\n    session_id: str = Path(...",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseSitting).filter(HouseSitting.session_id == session_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(HouseSitting.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSitting.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sittings\n    sittings = query.order_by(desc(HouseSitting.sitting_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    sitting_responses = []\n    for sitting in sittings:\n        sitting_responses.append(HouseSittingResponse(\n            id=str(sitting.id)",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.HouseSitting",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sittings for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.sitting_date=sitting.sitting_date"
      ]
    },
    "GET:/sessions/{session_id}/votes": {
      "method": "GET",
      "path": "/sessions/{session_id}/votes",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 399,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house vote within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.description=\"Filter by sitting status\")",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.response_model=HouseVoteResponse)\nasync def create_house_vote(\n    session_id: str = Path(...",
        "import:fastapi.session_id=str(vote.session_id)",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# HOUSE VOTES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/votes\"",
        "import:fastapi.bill_id=vote.bill_id",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.status=session.status",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.HouseDebate",
        "import:fastapi.updated_at=vote.updated_at\n    )",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HTTPException",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.vote_metadata=vote.vote_metadata",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.updated_at=sitting.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/sittings\"",
        "function:create_house_vote",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.motion_text=vote.motion_text",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.updated_at=sitting.updated_at\n        ))\n    \n    return HouseSittingListResponse(\n        sittings=sitting_responses",
        "import:fastapi.vote_data: HouseVoteCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.royal_assent_date=vote.royal_assent_date",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new vote\n    vote = HouseVote(**vote_data.dict())\n    vote.session_id = session_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"House vote created: {current_user.username} - Vote {vote.vote_number}\")\n    \n    return HouseVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.HouseVote",
        "import:fastapi.abstentions=vote.abstentions",
        "import:fastapi.page=page",
        "import:fastapi.total_votes_cast=vote.total_votes_cast",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.response_model=HouseSittingListResponse)\nasync def list_house_sittings(\n    session_id: str = Path(...",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.vote_number=vote.vote_number",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.duration_minutes=vote.duration_minutes",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseSitting).filter(HouseSitting.session_id == session_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(HouseSitting.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSitting.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sittings\n    sittings = query.order_by(desc(HouseSitting.sitting_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    sitting_responses = []\n    for sitting in sittings:\n        sitting_responses.append(HouseSittingResponse(\n            id=str(sitting.id)",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.HouseSitting",
        "import:fastapi.vote_type=vote.vote_type",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sittings for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.start_time=vote.start_time",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.requires_royal_assent=vote.requires_royal_assent",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.nays=vote.nays",
        "import:fastapi.status=vote.status",
        "import:fastapi.end_time=vote.end_time",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.sitting_id=str(vote.sitting_id) if vote.sitting_id else None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.yeas=vote.yeas",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.result=vote.result",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.sitting_date=sitting.sitting_date",
        "import:fastapi.created_at=vote.created_at"
      ]
    },
    "POST:/votes/{vote_id}/individual-votes": {
      "method": "POST",
      "path": "/votes/{vote_id}/individual-votes",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 478,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.updated_at=vote.updated_at\n        ))\n    \n    return HouseVoteListResponse(\n        votes=vote_responses",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house vote within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.description=\"Filter by sitting status\")",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.metadata=vote.metadata",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# INDIVIDUAL VOTES\n# ============================================================================",
        "import:fastapi.response_model=HouseVoteResponse)\nasync def create_house_vote(\n    session_id: str = Path(...",
        "import:fastapi.session_id=str(vote.session_id)",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# HOUSE VOTES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/votes\"",
        "import:fastapi.bill_id=vote.bill_id",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.status=session.status",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.HouseDebate",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HTTPException",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "function:list_house_votes",
        "import:fastapi.vote_metadata=vote.vote_metadata",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseVote).filter(HouseVote.session_id == session_id)\n    \n    # Apply filters\n    if status:\n        query = query.filter(HouseVote.status == status)\n    \n    if vote_type:\n        query = query.filter(HouseVote.vote_type == vote_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get votes\n    votes = query.order_by(desc(HouseVote.vote_number)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_responses = []\n    for vote in votes:\n        vote_responses.append(HouseVoteResponse(\n            id=str(vote.id)",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.updated_at=sitting.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.motion_text=vote.motion_text",
        "import:fastapi.updated_at=vote.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/votes\"",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.updated_at=sitting.updated_at\n        ))\n    \n    return HouseSittingListResponse(\n        sittings=sitting_responses",
        "import:fastapi.vote_data: HouseVoteCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.royal_assent_date=vote.royal_assent_date",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new vote\n    vote = HouseVote(**vote_data.dict())\n    vote.session_id = session_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"House vote created: {current_user.username} - Vote {vote.vote_number}\")\n    \n    return HouseVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.response_model=HouseVoteListResponse)\nasync def list_house_votes(\n    session_id: str = Path(...",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.HouseVote",
        "import:fastapi.abstentions=vote.abstentions",
        "import:fastapi.page=page",
        "import:fastapi.total_votes_cast=vote.total_votes_cast",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.response_model=HouseSittingListResponse)\nasync def list_house_sittings(\n    session_id: str = Path(...",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.vote_number=vote.vote_number",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house votes for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.duration_minutes=vote.duration_minutes",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseSitting).filter(HouseSitting.session_id == session_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(HouseSitting.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSitting.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sittings\n    sittings = query.order_by(desc(HouseSitting.sitting_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    sitting_responses = []\n    for sitting in sittings:\n        sitting_responses.append(HouseSittingResponse(\n            id=str(sitting.id)",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.HouseSitting",
        "import:fastapi.vote_type=vote.vote_type",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sittings for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.vote_type: Optional[str] = Query(None",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.start_time=vote.start_time",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.requires_royal_assent=vote.requires_royal_assent",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.description=\"Filter by vote status\")",
        "import:fastapi.nays=vote.nays",
        "import:fastapi.status=vote.status",
        "import:fastapi.end_time=vote.end_time",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.sitting_id=str(vote.sitting_id) if vote.sitting_id else None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.yeas=vote.yeas",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.description=\"Filter by vote type\")",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.result=vote.result",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.sitting_date=sitting.sitting_date",
        "import:fastapi.created_at=vote.created_at"
      ]
    },
    "POST:/sessions/{session_id}/debates": {
      "method": "POST",
      "path": "/sessions/{session_id}/debates",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 536,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.updated_at=vote.updated_at\n        ))\n    \n    return HouseVoteListResponse(\n        votes=vote_responses",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.whip_status=vote.whip_status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house vote within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.description=\"Filter by sitting status\")",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.metadata=vote.metadata",
        "import:fastapi.response_model=HouseVoteResponse)\nasync def create_house_vote(\n    session_id: str = Path(...",
        "import:fastapi.session_id=str(vote.session_id)",
        "import:fastapi.vote_data: IndividualVoteCreateRequest = Body(...)",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# HOUSE VOTES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/votes\"",
        "import:fastapi.bill_id=vote.bill_id",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.is_paired=vote.is_paired",
        "import:fastapi.status=session.status",
        "import:fastapi.detail=\"House vote not found\")\n    \n    # Check if member already voted\n    existing_vote = db.query(IndividualVote).filter(\n        and_(\n            IndividualVote.house_vote_id == vote_id",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.HouseDebate",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create an individual vote for a house vote.\n    \"\"\"\n    # Verify house vote exists\n    house_vote = db.query(HouseVote).filter(HouseVote.id == vote_id).first()\n    if not house_vote:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.paired_with=vote.paired_with",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HTTPException",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.vote_metadata=vote.vote_metadata",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseVote).filter(HouseVote.session_id == session_id)\n    \n    # Apply filters\n    if status:\n        query = query.filter(HouseVote.status == status)\n    \n    if vote_type:\n        query = query.filter(HouseVote.vote_type == vote_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get votes\n    votes = query.order_by(desc(HouseVote.vote_number)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_responses = []\n    for vote in votes:\n        vote_responses.append(HouseVoteResponse(\n            id=str(vote.id)",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.updated_at=sitting.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.IndividualVote.member_id == vote_data.member_id\n        )\n    ).first()\n    \n    if existing_vote:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.motion_text=vote.motion_text",
        "import:fastapi.detail=f\"Member {vote_data.member_id} has already voted on this motion\"\n        )\n    \n    # Create new individual vote\n    vote = IndividualVote(**vote_data.dict())\n    vote.house_vote_id = vote_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"Individual vote created: {current_user.username} - Member {vote.member_id}\")\n    \n    return IndividualVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.updated_at=vote.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/votes\"",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.updated_at=sitting.updated_at\n        ))\n    \n    return HouseSittingListResponse(\n        sittings=sitting_responses",
        "import:fastapi.vote_data: HouseVoteCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.royal_assent_date=vote.royal_assent_date",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new vote\n    vote = HouseVote(**vote_data.dict())\n    vote.session_id = session_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"House vote created: {current_user.username} - Vote {vote.vote_number}\")\n    \n    return HouseVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.description=\"House vote ID\")",
        "import:fastapi.house_vote_id=str(vote.house_vote_id)",
        "import:fastapi.response_model=HouseVoteListResponse)\nasync def list_house_votes(\n    session_id: str = Path(...",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.HouseVote",
        "function:create_individual_vote",
        "import:fastapi.abstentions=vote.abstentions",
        "import:fastapi.page=page",
        "import:fastapi.total_votes_cast=vote.total_votes_cast",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# INDIVIDUAL VOTES\n# ============================================================================\n\n@router.post(\"/votes/{vote_id}/individual-votes\"",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.response_model=HouseSittingListResponse)\nasync def list_house_sittings(\n    session_id: str = Path(...",
        "import:fastapi.member_id=vote.member_id",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.vote_number=vote.vote_number",
        "import:fastapi.riding=vote.riding",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.response_model=IndividualVoteResponse)\nasync def create_individual_vote(\n    vote_id: str = Path(...",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house votes for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.duration_minutes=vote.duration_minutes",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseSitting).filter(HouseSitting.session_id == session_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(HouseSitting.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSitting.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sittings\n    sittings = query.order_by(desc(HouseSitting.sitting_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    sitting_responses = []\n    for sitting in sittings:\n        sitting_responses.append(HouseSittingResponse(\n            id=str(sitting.id)",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.created_at=vote.created_at\n    )\n\n\n# ============================================================================\n# HOUSE DEBATES\n# ============================================================================",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.HouseSitting",
        "import:fastapi.vote_type=vote.vote_type",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sittings for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.vote_type: Optional[str] = Query(None",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.start_time=vote.start_time",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.requires_royal_assent=vote.requires_royal_assent",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.description=\"Filter by vote status\")",
        "import:fastapi.nays=vote.nays",
        "import:fastapi.status=vote.status",
        "import:fastapi.end_time=vote.end_time",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.member_name=vote.member_name",
        "import:fastapi.sitting_id=str(vote.sitting_id) if vote.sitting_id else None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.yeas=vote.yeas",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.description=\"Filter by vote type\")",
        "import:fastapi.party=vote.party",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.result=vote.result",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.vote_cast=vote.vote_cast",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.sitting_date=sitting.sitting_date",
        "import:fastapi.created_at=vote.created_at",
        "import:fastapi.vote_time=vote.vote_time"
      ]
    },
    "GET:/status/current": {
      "method": "GET",
      "path": "/status/current",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 585,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.time_used_minutes=debate.time_used_minutes",
        "import:fastapi.updated_at=vote.updated_at\n        ))\n    \n    return HouseVoteListResponse(\n        votes=vote_responses",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.whip_status=vote.whip_status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house vote within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.description=\"Filter by sitting status\")",
        "import:fastapi.sitting_id=str(debate.sitting_id) if debate.sitting_id else None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house debate within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.metadata=vote.metadata",
        "import:fastapi.response_model=HouseVoteResponse)\nasync def create_house_vote(\n    session_id: str = Path(...",
        "import:fastapi.session_id=str(vote.session_id)",
        "import:fastapi.vote_data: IndividualVoteCreateRequest = Body(...)",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# HOUSE VOTES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/votes\"",
        "import:fastapi.bill_id=vote.bill_id",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.is_paired=vote.is_paired",
        "import:fastapi.status=session.status",
        "import:fastapi.detail=\"House vote not found\")\n    \n    # Check if member already voted\n    existing_vote = db.query(IndividualVote).filter(\n        and_(\n            IndividualVote.house_vote_id == vote_id",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.speakers_list=debate.speakers_list",
        "import:fastapi.HouseDebate",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create an individual vote for a house vote.\n    \"\"\"\n    # Verify house vote exists\n    house_vote = db.query(HouseVote).filter(HouseVote.id == vote_id).first()\n    if not house_vote:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.paired_with=vote.paired_with",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new debate\n    debate = HouseDebate(**debate_data.dict())\n    debate.session_id = session_id\n    db.add(debate)\n    db.commit()\n    db.refresh(debate)\n    \n    logger.info(f\"House debate created: {current_user.username} - {debate.subject}\")\n    \n    return HouseDebateResponse(\n        id=str(debate.id)",
        "import:fastapi.HTTPException",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.vote_metadata=vote.vote_metadata",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseVote).filter(HouseVote.session_id == session_id)\n    \n    # Apply filters\n    if status:\n        query = query.filter(HouseVote.status == status)\n    \n    if vote_type:\n        query = query.filter(HouseVote.vote_type == vote_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get votes\n    votes = query.order_by(desc(HouseVote.vote_number)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_responses = []\n    for vote in votes:\n        vote_responses.append(HouseVoteResponse(\n            id=str(vote.id)",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.updated_at=sitting.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.IndividualVote.member_id == vote_data.member_id\n        )\n    ).first()\n    \n    if existing_vote:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.motion_text=vote.motion_text",
        "import:fastapi.detail=f\"Member {vote_data.member_id} has already voted on this motion\"\n        )\n    \n    # Create new individual vote\n    vote = IndividualVote(**vote_data.dict())\n    vote.house_vote_id = vote_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"Individual vote created: {current_user.username} - Member {vote.member_id}\")\n    \n    return IndividualVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.updated_at=vote.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/votes\"",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.updated_at=sitting.updated_at\n        ))\n    \n    return HouseSittingListResponse(\n        sittings=sitting_responses",
        "import:fastapi.vote_data: HouseVoteCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.royal_assent_date=vote.royal_assent_date",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new vote\n    vote = HouseVote(**vote_data.dict())\n    vote.session_id = session_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"House vote created: {current_user.username} - Vote {vote.vote_number}\")\n    \n    return HouseVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.closure_motion=debate.closure_motion",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.start_time=debate.start_time",
        "import:fastapi.description=\"House vote ID\")",
        "import:fastapi.house_vote_id=str(vote.house_vote_id)",
        "import:fastapi.response_model=HouseVoteListResponse)\nasync def list_house_votes(\n    session_id: str = Path(...",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.HouseVote",
        "import:fastapi.abstentions=vote.abstentions",
        "import:fastapi.page=page",
        "import:fastapi.total_votes_cast=vote.total_votes_cast",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# INDIVIDUAL VOTES\n# ============================================================================\n\n@router.post(\"/votes/{vote_id}/individual-votes\"",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.response_model=HouseSittingListResponse)\nasync def list_house_sittings(\n    session_id: str = Path(...",
        "import:fastapi.member_id=vote.member_id",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.status=debate.status",
        "import:fastapi.current_speaker=debate.current_speaker",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.debate_data: HouseDebateCreateRequest = Body(...)",
        "import:fastapi.bill_id=debate.bill_id",
        "import:fastapi.vote_number=vote.vote_number",
        "import:fastapi.riding=vote.riding",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.response_model=IndividualVoteResponse)\nasync def create_individual_vote(\n    vote_id: str = Path(...",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house votes for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.duration_minutes=vote.duration_minutes",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseSitting).filter(HouseSitting.session_id == session_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(HouseSitting.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSitting.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sittings\n    sittings = query.order_by(desc(HouseSitting.sitting_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    sitting_responses = []\n    for sitting in sittings:\n        sitting_responses.append(HouseSittingResponse(\n            id=str(sitting.id)",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.response_model=HouseDebateResponse)\nasync def create_house_debate(\n    session_id: str = Path(...",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.created_at=vote.created_at\n    )\n\n\n# ============================================================================\n# HOUSE DEBATES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/debates\"",
        "import:fastapi.HouseSitting",
        "import:fastapi.time_allocation_minutes=debate.time_allocation_minutes",
        "import:fastapi.current_amendment=debate.current_amendment",
        "import:fastapi.vote_type=vote.vote_type",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sittings for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.vote_type: Optional[str] = Query(None",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.start_time=vote.start_time",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.requires_royal_assent=vote.requires_royal_assent",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.description=\"Filter by vote status\")",
        "import:fastapi.nays=vote.nays",
        "import:fastapi.status=vote.status",
        "import:fastapi.end_time=vote.end_time",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=debate.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE STATUS\n# ============================================================================",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.member_name=vote.member_name",
        "import:fastapi.sitting_id=str(vote.sitting_id) if vote.sitting_id else None",
        "import:fastapi.debate_type=debate.debate_type",
        "function:create_house_debate",
        "import:fastapi.subject=debate.subject",
        "import:fastapi.end_time=debate.end_time",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.yeas=vote.yeas",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.session_id=str(debate.session_id)",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.description=\"Filter by vote type\")",
        "import:fastapi.party=vote.party",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.result=vote.result",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.vote_cast=vote.vote_cast",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.created_at=debate.created_at",
        "import:fastapi.sitting_date=sitting.sitting_date",
        "import:fastapi.created_at=vote.created_at",
        "import:fastapi.vote_time=vote.vote_time"
      ]
    },
    "PUT:/status/current": {
      "method": "PUT",
      "path": "/status/current",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 635,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.time_used_minutes=debate.time_used_minutes",
        "import:fastapi.debate_status=status.debate_status",
        "import:fastapi.current_time=status.current_time",
        "import:fastapi.updated_at=vote.updated_at\n        ))\n    \n    return HouseVoteListResponse(\n        votes=vote_responses",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.whip_status=vote.whip_status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house vote within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.description=\"Filter by sitting status\")",
        "import:fastapi.sitting_id=str(debate.sitting_id) if debate.sitting_id else None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house debate within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.metadata=vote.metadata",
        "import:fastapi.response_model=HouseVoteResponse)\nasync def create_house_vote(\n    session_id: str = Path(...",
        "import:fastapi.session_id=str(vote.session_id)",
        "import:fastapi.vote_data: IndividualVoteCreateRequest = Body(...)",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# HOUSE VOTES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/votes\"",
        "import:fastapi.bill_id=vote.bill_id",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.is_paired=vote.is_paired",
        "import:fastapi.status=session.status",
        "import:fastapi.current_time=datetime.utcnow()",
        "import:fastapi.detail=\"House vote not found\")\n    \n    # Check if member already voted\n    existing_vote = db.query(IndividualVote).filter(\n        and_(\n            IndividualVote.house_vote_id == vote_id",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.update_source=\"system\"\n        )\n        db.add(status)\n        db.commit()\n        db.refresh(status)\n    \n    return HouseStatusResponse(\n        id=str(status.id)",
        "import:fastapi.question_period_status=status.question_period_status",
        "import:fastapi.speakers_list=debate.speakers_list",
        "import:fastapi.HouseDebate",
        "import:fastapi.next_event_time=status.next_event_time",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create an individual vote for a house vote.\n    \"\"\"\n    # Verify house vote exists\n    house_vote = db.query(HouseVote).filter(HouseVote.id == vote_id).first()\n    if not house_vote:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.paired_with=vote.paired_with",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new debate\n    debate = HouseDebate(**debate_data.dict())\n    debate.session_id = session_id\n    db.add(debate)\n    db.commit()\n    db.refresh(debate)\n    \n    logger.info(f\"House debate created: {current_user.username} - {debate.subject}\")\n    \n    return HouseDebateResponse(\n        id=str(debate.id)",
        "import:fastapi.notes=status.notes",
        "import:fastapi.HTTPException",
        "import:fastapi.house_status=status.house_status",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.vote_metadata=vote.vote_metadata",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseVote).filter(HouseVote.session_id == session_id)\n    \n    # Apply filters\n    if status:\n        query = query.filter(HouseVote.status == status)\n    \n    if vote_type:\n        query = query.filter(HouseVote.vote_type == vote_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get votes\n    votes = query.order_by(desc(HouseVote.vote_number)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_responses = []\n    for vote in votes:\n        vote_responses.append(HouseVoteResponse(\n            id=str(vote.id)",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.updated_at=sitting.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.IndividualVote.member_id == vote_data.member_id\n        )\n    ).first()\n    \n    if existing_vote:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.motion_text=vote.motion_text",
        "import:fastapi.detail=f\"Member {vote_data.member_id} has already voted on this motion\"\n        )\n    \n    # Create new individual vote\n    vote = IndividualVote(**vote_data.dict())\n    vote.house_vote_id = vote_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"Individual vote created: {current_user.username} - Member {vote.member_id}\")\n    \n    return IndividualVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.updated_at=vote.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/votes\"",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.updated_at=sitting.updated_at\n        ))\n    \n    return HouseSittingListResponse(\n        sittings=sitting_responses",
        "import:fastapi.vote_data: HouseVoteCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.royal_assent_date=vote.royal_assent_date",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new vote\n    vote = HouseVote(**vote_data.dict())\n    vote.session_id = session_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"House vote created: {current_user.username} - Vote {vote.vote_number}\")\n    \n    return HouseVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.HouseEventResponse",
        "function:get_current_house_status",
        "import:fastapi.closure_motion=debate.closure_motion",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.start_time=debate.start_time",
        "import:fastapi.description=\"House vote ID\")",
        "import:fastapi.house_vote_id=str(vote.house_vote_id)",
        "import:fastapi.response_model=HouseVoteListResponse)\nasync def list_house_votes(\n    session_id: str = Path(...",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.debate_status=\"none\"",
        "import:fastapi.current_vote_id=str(status.current_vote_id) if status.current_vote_id else None",
        "import:fastapi.HouseVote",
        "import:fastapi.abstentions=vote.abstentions",
        "import:fastapi.quorum_met=True",
        "import:fastapi.page=page",
        "import:fastapi.total_votes_cast=vote.total_votes_cast",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# INDIVIDUAL VOTES\n# ============================================================================\n\n@router.post(\"/votes/{vote_id}/individual-votes\"",
        "import:fastapi.members_present=status.members_present",
        "import:fastapi.current_debate_id=str(status.current_debate_id) if status.current_debate_id else None",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.updated_at=debate.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE STATUS\n# ============================================================================\n\n@router.get(\"/status/current\"",
        "import:fastapi.update_source=status.update_source",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.response_model=HouseSittingListResponse)\nasync def list_house_sittings(\n    session_id: str = Path(...",
        "import:fastapi.member_id=vote.member_id",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.status=debate.status",
        "import:fastapi.current_speaker=debate.current_speaker",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.debate_data: HouseDebateCreateRequest = Body(...)",
        "import:fastapi.bill_id=debate.bill_id",
        "import:fastapi.vote_number=vote.vote_number",
        "import:fastapi.riding=vote.riding",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.response_model=IndividualVoteResponse)\nasync def create_individual_vote(\n    vote_id: str = Path(...",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.emergency_debate_requested=status.emergency_debate_requested",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house votes for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.duration_minutes=vote.duration_minutes",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.quorum_met=status.quorum_met",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseSitting).filter(HouseSitting.session_id == session_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(HouseSitting.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSitting.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sittings\n    sittings = query.order_by(desc(HouseSitting.sitting_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    sitting_responses = []\n    for sitting in sittings:\n        sitting_responses.append(HouseSittingResponse(\n            id=str(sitting.id)",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.sitting_status=status.sitting_status",
        "import:fastapi.response_model=HouseDebateResponse)\nasync def create_house_debate(\n    session_id: str = Path(...",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.created_at=vote.created_at\n    )\n\n\n# ============================================================================\n# HOUSE DEBATES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/debates\"",
        "import:fastapi.HouseSitting",
        "import:fastapi.time_allocation_minutes=debate.time_allocation_minutes",
        "import:fastapi.current_amendment=debate.current_amendment",
        "import:fastapi.vote_type=vote.vote_type",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.response_model=HouseStatusResponse)\nasync def get_current_house_status(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get the current real-time house status.\n    \"\"\"\n    # Get the most recent house status\n    status = db.query(HouseStatus).order_by(desc(HouseStatus.last_updated)).first()\n    \n    if not status:\n        # Create default status if none exists\n        status = HouseStatus(\n            house_status=\"sitting\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sittings for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.vote_type: Optional[str] = Query(None",
        "import:fastapi.current_sitting_id=str(status.current_sitting_id) if status.current_sitting_id else None",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.start_time=vote.start_time",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.closure_motion_active=status.closure_motion_active",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.requires_royal_assent=vote.requires_royal_assent",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.description=\"Filter by vote status\")",
        "import:fastapi.nays=vote.nays",
        "import:fastapi.status=vote.status",
        "import:fastapi.members_present=0",
        "import:fastapi.end_time=vote.end_time",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.sitting_status=\"in_progress\"",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.next_scheduled_event=status.next_scheduled_event",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.member_name=vote.member_name",
        "import:fastapi.sitting_id=str(vote.sitting_id) if vote.sitting_id else None",
        "import:fastapi.debate_type=debate.debate_type",
        "import:fastapi.subject=debate.subject",
        "import:fastapi.end_time=debate.end_time",
        "import:fastapi.current_session_id=str(status.current_session_id) if status.current_session_id else None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.yeas=vote.yeas",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.session_id=str(debate.session_id)",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.voting_status=\"none\"",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.voting_status=status.voting_status",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.last_updated=status.last_updated\n    )",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.description=\"Filter by vote type\")",
        "import:fastapi.party=vote.party",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.result=vote.result",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.vote_cast=vote.vote_cast",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.created_at=debate.created_at",
        "import:fastapi.sitting_date=sitting.sitting_date",
        "import:fastapi.created_at=vote.created_at",
        "import:fastapi.vote_time=vote.vote_time"
      ]
    },
    "POST:/events": {
      "method": "POST",
      "path": "/events",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 704,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.time_used_minutes=debate.time_used_minutes",
        "import:fastapi.debate_status=status.debate_status",
        "import:fastapi.current_time=status.current_time",
        "import:fastapi.updated_at=vote.updated_at\n        ))\n    \n    return HouseVoteListResponse(\n        votes=vote_responses",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.whip_status=vote.whip_status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house vote within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.last_updated=status.last_updated\n    )\n\n\n# ============================================================================\n# HOUSE EVENTS\n# ============================================================================",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.description=\"Filter by sitting status\")",
        "import:fastapi.sitting_id=str(debate.sitting_id) if debate.sitting_id else None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house debate within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.metadata=vote.metadata",
        "import:fastapi.response_model=HouseVoteResponse)\nasync def create_house_vote(\n    session_id: str = Path(...",
        "import:fastapi.session_id=str(vote.session_id)",
        "import:fastapi.vote_data: IndividualVoteCreateRequest = Body(...)",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# HOUSE VOTES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/votes\"",
        "import:fastapi.bill_id=vote.bill_id",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.is_paired=vote.is_paired",
        "import:fastapi.status=session.status",
        "import:fastapi.current_time=datetime.utcnow()",
        "import:fastapi.detail=\"House vote not found\")\n    \n    # Check if member already voted\n    existing_vote = db.query(IndividualVote).filter(\n        and_(\n            IndividualVote.house_vote_id == vote_id",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.update_source=\"system\"\n        )\n        db.add(status)\n        db.commit()\n        db.refresh(status)\n    \n    return HouseStatusResponse(\n        id=str(status.id)",
        "import:fastapi.question_period_status=status.question_period_status",
        "import:fastapi.speakers_list=debate.speakers_list",
        "import:fastapi.HouseDebate",
        "import:fastapi.next_event_time=status.next_event_time",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create an individual vote for a house vote.\n    \"\"\"\n    # Verify house vote exists\n    house_vote = db.query(HouseVote).filter(HouseVote.id == vote_id).first()\n    if not house_vote:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.paired_with=vote.paired_with",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.value)\n    \n    db.commit()\n    db.refresh(status)\n    \n    logger.info(f\"House status updated: {current_user.username}\")\n    \n    return HouseStatusResponse(\n        id=str(status.id)",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new debate\n    debate = HouseDebate(**debate_data.dict())\n    debate.session_id = session_id\n    db.add(debate)\n    db.commit()\n    db.refresh(debate)\n    \n    logger.info(f\"House debate created: {current_user.username} - {debate.subject}\")\n    \n    return HouseDebateResponse(\n        id=str(debate.id)",
        "import:fastapi.notes=status.notes",
        "import:fastapi.HTTPException",
        "import:fastapi.house_status=status.house_status",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.vote_metadata=vote.vote_metadata",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseVote).filter(HouseVote.session_id == session_id)\n    \n    # Apply filters\n    if status:\n        query = query.filter(HouseVote.status == status)\n    \n    if vote_type:\n        query = query.filter(HouseVote.vote_type == vote_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get votes\n    votes = query.order_by(desc(HouseVote.vote_number)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_responses = []\n    for vote in votes:\n        vote_responses.append(HouseVoteResponse(\n            id=str(vote.id)",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.updated_at=sitting.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.IndividualVote.member_id == vote_data.member_id\n        )\n    ).first()\n    \n    if existing_vote:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.value in update_data.items():\n        if hasattr(status",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.motion_text=vote.motion_text",
        "import:fastapi.detail=f\"Member {vote_data.member_id} has already voted on this motion\"\n        )\n    \n    # Create new individual vote\n    vote = IndividualVote(**vote_data.dict())\n    vote.house_vote_id = vote_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"Individual vote created: {current_user.username} - Member {vote.member_id}\")\n    \n    return IndividualVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.updated_at=vote.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/votes\"",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.updated_at=sitting.updated_at\n        ))\n    \n    return HouseSittingListResponse(\n        sittings=sitting_responses",
        "import:fastapi.vote_data: HouseVoteCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.royal_assent_date=vote.royal_assent_date",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new vote\n    vote = HouseVote(**vote_data.dict())\n    vote.session_id = session_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"House vote created: {current_user.username} - Vote {vote.vote_number}\")\n    \n    return HouseVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.closure_motion=debate.closure_motion",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.start_time=debate.start_time",
        "import:fastapi.description=\"House vote ID\")",
        "import:fastapi.house_vote_id=str(vote.house_vote_id)",
        "import:fastapi.response_model=HouseVoteListResponse)\nasync def list_house_votes(\n    session_id: str = Path(...",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.debate_status=\"none\"",
        "import:fastapi.current_vote_id=str(status.current_vote_id) if status.current_vote_id else None",
        "import:fastapi.HouseVote",
        "import:fastapi.abstentions=vote.abstentions",
        "import:fastapi.quorum_met=True",
        "import:fastapi.page=page",
        "import:fastapi.total_votes_cast=vote.total_votes_cast",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# INDIVIDUAL VOTES\n# ============================================================================\n\n@router.post(\"/votes/{vote_id}/individual-votes\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update the current house status.\n    \"\"\"\n    # Get the most recent house status\n    status = db.query(HouseStatus).order_by(desc(HouseStatus.last_updated)).first()\n    \n    if not status:\n        # Create new status if none exists\n        status = HouseStatus(\n            house_status=\"sitting\"",
        "import:fastapi.members_present=status.members_present",
        "import:fastapi.current_debate_id=str(status.current_debate_id) if status.current_debate_id else None",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.updated_at=debate.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE STATUS\n# ============================================================================\n\n@router.get(\"/status/current\"",
        "import:fastapi.update_source=status.update_source",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.response_model=HouseSittingListResponse)\nasync def list_house_sittings(\n    session_id: str = Path(...",
        "import:fastapi.member_id=vote.member_id",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.status=debate.status",
        "import:fastapi.current_speaker=debate.current_speaker",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.debate_data: HouseDebateCreateRequest = Body(...)",
        "import:fastapi.bill_id=debate.bill_id",
        "import:fastapi.vote_number=vote.vote_number",
        "import:fastapi.riding=vote.riding",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.response_model=IndividualVoteResponse)\nasync def create_individual_vote(\n    vote_id: str = Path(...",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.emergency_debate_requested=status.emergency_debate_requested",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house votes for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.duration_minutes=vote.duration_minutes",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.quorum_met=status.quorum_met",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseSitting).filter(HouseSitting.session_id == session_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(HouseSitting.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSitting.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sittings\n    sittings = query.order_by(desc(HouseSitting.sitting_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    sitting_responses = []\n    for sitting in sittings:\n        sitting_responses.append(HouseSittingResponse(\n            id=str(sitting.id)",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.sitting_status=status.sitting_status",
        "import:fastapi.response_model=HouseDebateResponse)\nasync def create_house_debate(\n    session_id: str = Path(...",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.created_at=vote.created_at\n    )\n\n\n# ============================================================================\n# HOUSE DEBATES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/debates\"",
        "import:fastapi.HouseSitting",
        "import:fastapi.time_allocation_minutes=debate.time_allocation_minutes",
        "import:fastapi.current_amendment=debate.current_amendment",
        "import:fastapi.vote_type=vote.vote_type",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.response_model=HouseStatusResponse)\nasync def get_current_house_status(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get the current real-time house status.\n    \"\"\"\n    # Get the most recent house status\n    status = db.query(HouseStatus).order_by(desc(HouseStatus.last_updated)).first()\n    \n    if not status:\n        # Create default status if none exists\n        status = HouseStatus(\n            house_status=\"sitting\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sittings for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.vote_type: Optional[str] = Query(None",
        "import:fastapi.current_sitting_id=str(status.current_sitting_id) if status.current_sitting_id else None",
        "import:fastapi.update_source=\"user\"\n        )\n        db.add(status)\n    else:\n        # Update existing status\n        status.current_time = datetime.utcnow()\n        status.update_source = \"user\"\n    \n    # Update status fields\n    update_data = status_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.start_time=vote.start_time",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.closure_motion_active=status.closure_motion_active",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.requires_royal_assent=vote.requires_royal_assent",
        "import:fastapi.response_model=HouseStatusResponse)\nasync def update_current_house_status(\n    status_data: HouseStatusUpdateRequest = Body(...)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.description=\"Filter by vote status\")",
        "import:fastapi.nays=vote.nays",
        "import:fastapi.status=vote.status",
        "import:fastapi.members_present=0",
        "import:fastapi.end_time=vote.end_time",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.sitting_status=\"in_progress\"",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.next_scheduled_event=status.next_scheduled_event",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.field):\n            setattr(status",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.member_name=vote.member_name",
        "import:fastapi.sitting_id=str(vote.sitting_id) if vote.sitting_id else None",
        "import:fastapi.debate_type=debate.debate_type",
        "import:fastapi.subject=debate.subject",
        "import:fastapi.end_time=debate.end_time",
        "import:fastapi.current_session_id=str(status.current_session_id) if status.current_session_id else None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.yeas=vote.yeas",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.last_updated=status.last_updated\n    )\n\n\n@router.put(\"/status/current\"",
        "import:fastapi.session_id=str(debate.session_id)",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.voting_status=\"none\"",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.voting_status=status.voting_status",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.description=\"Filter by vote type\")",
        "import:fastapi.party=vote.party",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.result=vote.result",
        "import:fastapi.Body",
        "function:update_current_house_status",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.vote_cast=vote.vote_cast",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.created_at=debate.created_at",
        "import:fastapi.sitting_date=sitting.sitting_date",
        "import:fastapi.created_at=vote.created_at",
        "import:fastapi.vote_time=vote.vote_time"
      ]
    },
    "GET:/events": {
      "method": "GET",
      "path": "/events",
      "file": "services/api-gateway/app/api/v1/house_status.py",
      "line": 741,
      "dependencies": [
        "import:fastapi.page_size=page_size",
        "import:fastapi.time_used_minutes=debate.time_used_minutes",
        "import:fastapi.debate_status=status.debate_status",
        "import:fastapi.current_time=status.current_time",
        "import:fastapi.updated_at=vote.updated_at\n        ))\n    \n    return HouseVoteListResponse(\n        votes=vote_responses",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def get_house_session(\n    session_id: str = Path(...",
        "import:fastapi.whip_status=vote.whip_status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house vote within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.end_date=session.end_date",
        "import:fastapi.agenda_items=sitting.agenda_items",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Update session fields\n    update_data = session_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.response_model=HouseEventResponse)\nasync def create_house_event(\n    event_data: HouseEventCreateRequest = Body(...)",
        "import:fastapi.last_updated=status.last_updated\n    )\n\n\n# ============================================================================\n# HOUSE EVENTS\n# ============================================================================\n\n@router.post(\"/events\"",
        "import:fastapi.HouseEvent\n)\nfrom app.schemas.house_status import (\n    HouseSessionResponse",
        "import:fastapi.description=\"Filter by sitting status\")",
        "import:fastapi.sitting_id=str(debate.sitting_id) if debate.sitting_id else None",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house debate within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.get(\"/sessions\"",
        "import:fastapi.metadata=vote.metadata",
        "import:fastapi.response_model=HouseVoteResponse)\nasync def create_house_vote(\n    session_id: str = Path(...",
        "import:fastapi.session_id=str(vote.session_id)",
        "import:fastapi.vote_data: IndividualVoteCreateRequest = Body(...)",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.members_present=sitting.members_present",
        "import:fastapi.parliament_number: Optional[int] = Query(None",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# HOUSE VOTES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/votes\"",
        "import:fastapi.bill_id=vote.bill_id",
        "import:fastapi.HouseSessionUpdateRequest",
        "import:fastapi.is_paired=vote.is_paired",
        "import:fastapi.status=session.status",
        "import:fastapi.current_time=datetime.utcnow()",
        "import:fastapi.detail=\"House vote not found\")\n    \n    # Check if member already voted\n    existing_vote = db.query(IndividualVote).filter(\n        and_(\n            IndividualVote.house_vote_id == vote_id",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n@router.put(\"/sessions/{session_id}\"",
        "import:fastapi.description=\"Filter by session status\")",
        "import:fastapi.IndividualVote",
        "import:fastapi.ge=1",
        "import:fastapi.HouseEventCreateRequest",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house sitting within a session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.total_members=sitting.total_members",
        "import:fastapi.update_source=\"system\"\n        )\n        db.add(status)\n        db.commit()\n        db.refresh(status)\n    \n    return HouseStatusResponse(\n        id=str(status.id)",
        "import:fastapi.question_period_status=status.question_period_status",
        "import:fastapi.speakers_list=debate.speakers_list",
        "import:fastapi.HouseDebate",
        "import:fastapi.next_event_time=status.next_event_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house event.\n    \"\"\"\n    # Create new event\n    event = HouseEvent(**event_data.dict())\n    db.add(event)\n    db.commit()\n    db.refresh(event)\n    \n    logger.info(f\"House event created: {current_user.username} - {event.event_title}\")\n    \n    return HouseEventResponse(\n        id=str(event.id)",
        "import:fastapi.le=100",
        "import:fastapi.status=sitting.status",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create an individual vote for a house vote.\n    \"\"\"\n    # Verify house vote exists\n    house_vote = db.query(HouseVote).filter(HouseVote.id == vote_id).first()\n    if not house_vote:\n        raise HTTPException(status_code=404",
        "import:fastapi.related_bill_id=event.related_bill_id",
        "import:fastapi.detail=f\"Session number {session_data.session_number} already exists\"\n        )\n    \n    # Create new session\n    session = HouseSession(**session_data.dict())\n    db.add(session)\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session created: {current_user.username} - {session_data.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.paired_with=vote.paired_with",
        "import:fastapi.priority=event.priority",
        "import:fastapi.field",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new house session.\n    \n    This is typically used by administrators to set up new parliamentary sessions.\n    \"\"\"\n    # Check if session number already exists\n    existing_session = db.query(HouseSession).filter(\n        HouseSession.session_number == session_data.session_number\n    ).first()\n    \n    if existing_session:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.value)\n    \n    db.commit()\n    db.refresh(status)\n    \n    logger.info(f\"House status updated: {current_user.username}\")\n    \n    return HouseStatusResponse(\n        id=str(status.id)",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new debate\n    debate = HouseDebate(**debate_data.dict())\n    debate.session_id = session_id\n    db.add(debate)\n    db.commit()\n    db.refresh(debate)\n    \n    logger.info(f\"House debate created: {current_user.username} - {debate.subject}\")\n    \n    return HouseDebateResponse(\n        id=str(debate.id)",
        "import:fastapi.notes=status.notes",
        "import:fastapi.event_description=event.event_description",
        "import:fastapi.HTTPException",
        "import:fastapi.house_status=status.house_status",
        "import:fastapi.start_time=sitting.start_time",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update a house session.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.HouseSessionListResponse",
        "import:fastapi.session_name=session.session_name",
        "import:fastapi.updated_at=event.updated_at\n    )",
        "import:fastapi.vote_metadata=vote.vote_metadata",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseVote).filter(HouseVote.session_id == session_id)\n    \n    # Apply filters\n    if status:\n        query = query.filter(HouseVote.status == status)\n    \n    if vote_type:\n        query = query.filter(HouseVote.vote_type == vote_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get votes\n    votes = query.order_by(desc(HouseVote.vote_number)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_responses = []\n    for vote in votes:\n        vote_responses.append(HouseVoteResponse(\n            id=str(vote.id)",
        "import:fastapi.HouseDebateCreateRequest",
        "import:fastapi.updated_at=sitting.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.IndividualVote.member_id == vote_data.member_id\n        )\n    ).first()\n    \n    if existing_vote:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.value in update_data.items():\n        if hasattr(status",
        "import:fastapi.HouseDebateListResponse",
        "import:fastapi.motion_text=vote.motion_text",
        "import:fastapi.detail=f\"Member {vote_data.member_id} has already voted on this motion\"\n        )\n    \n    # Create new individual vote\n    vote = IndividualVote(**vote_data.dict())\n    vote.house_vote_id = vote_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"Individual vote created: {current_user.username} - Member {vote.member_id}\")\n    \n    return IndividualVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.updated_at=vote.updated_at\n    )\n\n\n@router.get(\"/sessions/{session_id}/votes\"",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def update_house_session(\n    session_id: str = Path(...",
        "import:fastapi.updated_at=sitting.updated_at\n        ))\n    \n    return HouseSittingListResponse(\n        sittings=sitting_responses",
        "import:fastapi.vote_data: HouseVoteCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.royal_assent_date=vote.royal_assent_date",
        "import:fastapi.HouseStatus",
        "import:fastapi.response_model=HouseSittingResponse)\nasync def create_house_sitting(\n    session_id: str = Path(...",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new vote\n    vote = HouseVote(**vote_data.dict())\n    vote.session_id = session_id\n    db.add(vote)\n    db.commit()\n    db.refresh(vote)\n    \n    logger.info(f\"House vote created: {current_user.username} - Vote {vote.vote_number}\")\n    \n    return HouseVoteResponse(\n        id=str(vote.id)",
        "import:fastapi.HouseEventResponse",
        "import:fastapi.closure_motion=debate.closure_motion",
        "import:fastapi.created_at=session.created_at",
        "import:fastapi.start_time=debate.start_time",
        "import:fastapi.notification_sent=event.notification_sent",
        "import:fastapi.description=\"House vote ID\")",
        "import:fastapi.house_vote_id=str(vote.house_vote_id)",
        "import:fastapi.response_model=HouseVoteListResponse)\nasync def list_house_votes(\n    session_id: str = Path(...",
        "import:fastapi.Depends",
        "import:fastapi.opposition_leader=session.opposition_leader",
        "import:fastapi.HouseStatusResponse",
        "import:fastapi.parliament_number=session.parliament_number",
        "import:fastapi.Path",
        "import:fastapi.debate_status=\"none\"",
        "import:fastapi.current_vote_id=str(status.current_vote_id) if status.current_vote_id else None",
        "import:fastapi.HouseVote",
        "import:fastapi.abstentions=vote.abstentions",
        "import:fastapi.quorum_met=True",
        "import:fastapi.page=page",
        "import:fastapi.total_votes_cast=vote.total_votes_cast",
        "import:fastapi.detail=\"House session not found\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n# ============================================================================\n# INDIVIDUAL VOTES\n# ============================================================================\n\n@router.post(\"/votes/{vote_id}/individual-votes\"",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Update the current house status.\n    \"\"\"\n    # Get the most recent house status\n    status = db.query(HouseStatus).order_by(desc(HouseStatus.last_updated)).first()\n    \n    if not status:\n        # Create new status if none exists\n        status = HouseStatus(\n            house_status=\"sitting\"",
        "import:fastapi.members_present=status.members_present",
        "import:fastapi.current_debate_id=str(status.current_debate_id) if status.current_debate_id else None",
        "import:fastapi.end_time=sitting.end_time",
        "import:fastapi.updated_at=debate.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE STATUS\n# ============================================================================\n\n@router.get(\"/status/current\"",
        "import:fastapi.update_source=status.update_source",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/sessions/{session_id}\"",
        "import:fastapi.IndividualVoteCreateRequest",
        "import:fastapi.response_model=HouseSittingListResponse)\nasync def list_house_sittings(\n    session_id: str = Path(...",
        "import:fastapi.member_id=vote.member_id",
        "import:fastapi.WebSocketDisconnect\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.status=debate.status",
        "import:fastapi.current_speaker=debate.current_speaker",
        "import:fastapi.HouseDebateResponse",
        "import:fastapi.start_date=session.start_date",
        "import:fastapi.value)\n    \n    session.updated_at = datetime.utcnow()\n    db.commit()\n    db.refresh(session)\n    \n    logger.info(f\"House session updated: {current_user.username} - {session.session_name}\")\n    \n    return HouseSessionResponse(\n        id=str(session.id)",
        "import:fastapi.related_vote_id=str(event.related_vote_id) if event.related_vote_id else None",
        "import:fastapi.HouseStatusStatistics\n)\nfrom app.api.v1.auth import get_current_user\nfrom app.models.users import User\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# HOUSE SESSIONS\n# ============================================================================\n\n@router.post(\"/sessions\"",
        "import:fastapi.debate_data: HouseDebateCreateRequest = Body(...)",
        "import:fastapi.bill_id=debate.bill_id",
        "import:fastapi.vote_number=vote.vote_number",
        "import:fastapi.riding=vote.riding",
        "import:fastapi.event_time=event.event_time",
        "import:fastapi.description=\"Filter by parliament number\")",
        "import:fastapi.response_model=IndividualVoteResponse)\nasync def create_individual_vote(\n    vote_id: str = Path(...",
        "import:fastapi.event_title=event.event_title",
        "import:fastapi.session_data: HouseSessionUpdateRequest = Body(...)",
        "import:fastapi.description=\"Session ID\")",
        "import:fastapi.page: int = Query(1",
        "function:create_house_event",
        "import:fastapi.emergency_debate_requested=status.emergency_debate_requested",
        "import:fastapi.event_type=event.event_type",
        "import:fastapi.HouseVoteListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house votes for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.duration_minutes=vote.duration_minutes",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sessions with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(HouseSession)\n    \n    # Apply filters\n    if parliament_number:\n        query = query.filter(HouseSession.parliament_number == parliament_number)\n    \n    if is_active is not None:\n        query = query.filter(HouseSession.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSession.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sessions\n    sessions = query.order_by(desc(HouseSession.start_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    session_responses = []\n    for session in sessions:\n        session_responses.append(HouseSessionResponse(\n            id=str(session.id)",
        "import:fastapi.HouseVoteCreateRequest",
        "import:fastapi.notes=sitting.notes",
        "import:fastapi.quorum_met=status.quorum_met",
        "import:fastapi.updated_at=session.updated_at\n    )\n\n\n# ============================================================================\n# HOUSE SITTINGS\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/sittings\"",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Build base query\n    query = db.query(HouseSitting).filter(HouseSitting.session_id == session_id)\n    \n    # Apply filters\n    if is_active is not None:\n        query = query.filter(HouseSitting.is_active == is_active)\n    \n    if status:\n        query = query.filter(HouseSitting.status == status)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get sittings\n    sittings = query.order_by(desc(HouseSitting.sitting_date)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    sitting_responses = []\n    for sitting in sittings:\n        sitting_responses.append(HouseSittingResponse(\n            id=str(sitting.id)",
        "import:fastapi.WebSocket",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.sitting_data: HouseSittingCreateRequest = Body(...)",
        "import:fastapi.response_model=HouseSessionResponse)\nasync def create_house_session(\n    session_data: HouseSessionCreateRequest = Body(...)",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.HouseSittingCreateRequest",
        "import:fastapi.sitting_status=status.sitting_status",
        "import:fastapi.response_model=HouseDebateResponse)\nasync def create_house_debate(\n    session_id: str = Path(...",
        "import:fastapi.is_active=sitting.is_active",
        "import:fastapi.created_at=vote.created_at\n    )\n\n\n# ============================================================================\n# HOUSE DEBATES\n# ============================================================================\n\n@router.post(\"/sessions/{session_id}/debates\"",
        "import:fastapi.HouseSitting",
        "import:fastapi.time_allocation_minutes=debate.time_allocation_minutes",
        "import:fastapi.current_amendment=debate.current_amendment",
        "import:fastapi.vote_type=vote.vote_type",
        "import:fastapi.detail=\"House session not found\")\n    \n    # Create new sitting\n    sitting = HouseSitting(**sitting_data.dict())\n    sitting.session_id = session_id\n    db.add(sitting)\n    db.commit()\n    db.refresh(sitting)\n    \n    logger.info(f\"House sitting created: {current_user.username} - Session {session.session_number}\")\n    \n    return HouseSittingResponse(\n        id=str(sitting.id)",
        "import:fastapi.response_model=HouseStatusResponse)\nasync def get_current_house_status(\n    db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get the current real-time house status.\n    \"\"\"\n    # Get the most recent house status\n    status = db.query(HouseStatus).order_by(desc(HouseStatus.last_updated)).first()\n    \n    if not status:\n        # Create default status if none exists\n        status = HouseStatus(\n            house_status=\"sitting\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List house sittings for a specific session.\n    \"\"\"\n    # Verify session exists\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.vote_type: Optional[str] = Query(None",
        "import:fastapi.current_sitting_id=str(status.current_sitting_id) if status.current_sitting_id else None",
        "import:fastapi.update_source=\"user\"\n        )\n        db.add(status)\n    else:\n        # Update existing status\n        status.current_time = datetime.utcnow()\n        status.update_source = \"user\"\n    \n    # Update status fields\n    update_data = status_data.dict(exclude_unset=True)\n    for field",
        "import:fastapi.HouseSittingListResponse",
        "import:fastapi.start_time=vote.start_time",
        "import:fastapi.quorum_present=sitting.quorum_present",
        "import:fastapi.closure_motion_active=status.closure_motion_active",
        "import:fastapi.HouseEventUpdateRequest",
        "import:fastapi.requires_royal_assent=vote.requires_royal_assent",
        "import:fastapi.response_model=HouseStatusResponse)\nasync def update_current_house_status(\n    status_data: HouseStatusUpdateRequest = Body(...)",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.desc\nfrom typing import Optional\nfrom datetime import datetime\nimport math\nimport json\nimport asyncio\n\nfrom app.database import get_db\nfrom app.models.house_status import (\n    HouseSession",
        "import:fastapi.description=\"Filter by vote status\")",
        "import:fastapi.nays=vote.nays",
        "import:fastapi.status=vote.status",
        "import:fastapi.members_present=0",
        "import:fastapi.end_time=vote.end_time",
        "import:fastapi.HouseVoteResponse",
        "import:fastapi.sitting_status=\"in_progress\"",
        "import:fastapi.HouseEventListResponse",
        "import:fastapi.next_scheduled_event=status.next_scheduled_event",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.field):\n            setattr(status",
        "import:fastapi.event_metadata=event.event_metadata",
        "import:fastapi.updated_at=session.updated_at\n        ))\n    \n    return HouseSessionListResponse(\n        sessions=session_responses",
        "import:fastapi.government_party=session.government_party",
        "import:fastapi.member_name=vote.member_name",
        "import:fastapi.sitting_id=str(vote.sitting_id) if vote.sitting_id else None",
        "import:fastapi.debate_type=debate.debate_type",
        "import:fastapi.subject=debate.subject",
        "import:fastapi.created_at=event.created_at",
        "import:fastapi.end_time=debate.end_time",
        "import:fastapi.current_session_id=str(status.current_session_id) if status.current_session_id else None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.sitting_number=sitting.sitting_number",
        "import:fastapi.yeas=vote.yeas",
        "import:fastapi.response_model=HouseSessionListResponse)\nasync def list_house_sessions(\n    page: int = Query(1",
        "import:fastapi.HouseSessionCreateRequest",
        "import:fastapi.last_updated=status.last_updated\n    )\n\n\n@router.put(\"/status/current\"",
        "import:fastapi.session_id=str(event.session_id) if event.session_id else None",
        "import:fastapi.session_id=str(debate.session_id)",
        "import:fastapi.session_id=str(sitting.session_id)",
        "import:fastapi.voting_status=\"none\"",
        "import:fastapi.HouseStatusUpdateRequest",
        "import:fastapi.voting_status=status.voting_status",
        "import:fastapi.sitting_id=str(event.sitting_id) if event.sitting_id else None",
        "import:fastapi.value in update_data.items():\n        if hasattr(session",
        "import:fastapi.IndividualVoteResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.created_at=sitting.created_at",
        "import:fastapi.HouseSittingResponse",
        "import:fastapi.session_number=session.session_number",
        "import:fastapi.is_active=session.is_active",
        "import:fastapi.description=\"Filter by vote type\")",
        "import:fastapi.party=vote.party",
        "import:fastapi.requires_notification=event.requires_notification",
        "import:fastapi.speaker=session.speaker",
        "import:fastapi.result=vote.result",
        "import:fastapi.related_debate_id=str(event.related_debate_id) if event.related_debate_id else None",
        "import:fastapi.Body",
        "import:fastapi.APIRouter",
        "import:fastapi.field):\n            setattr(session",
        "import:fastapi.vote_cast=vote.vote_cast",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific house session by ID.\n    \"\"\"\n    session = db.query(HouseSession).filter(HouseSession.id == session_id).first()\n    \n    if not session:\n        raise HTTPException(status_code=404",
        "import:fastapi.created_at=debate.created_at",
        "import:fastapi.sitting_date=sitting.sitting_date",
        "import:fastapi.created_at=vote.created_at",
        "import:fastapi.vote_time=vote.vote_time"
      ]
    },
    "POST:/": {
      "method": "POST",
      "path": "/",
      "file": "services/api-gateway/app/api/v1/endpoints/entities.py",
      "line": 143,
      "dependencies": [
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.detail=\"Entity not found\")",
        "import:fastapi.data={\"title\": \"C-123\"",
        "import:fastapi.created_at=entity.created_at.isoformat() if entity.created_at else None",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"List parliamentary entities with pagination and filtering.\"\"\"\n    try:\n        # Build query\n        query = db.query(ParliamentaryEntity)\n        \n        if type:\n            query = query.filter(ParliamentaryEntity.type == type)\n        \n        # Get total count\n        total = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * size\n        entities = query.offset(offset).limit(size).all()\n        \n        # Convert to response format\n        entity_responses = [\n            EntityResponse(\n                id=str(entity.id)",
        "import:fastapi.updated_at=entity.updated_at.isoformat() if entity.updated_at else None\n            )\n        else:\n            raise HTTPException(status_code=404",
        "import:fastapi.data=entity.data",
        "import:fastapi.size: int = Query(10",
        "import:fastapi.description=\"Filter by entity type\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.db: Session = Depends(get_db)):\n    \"\"\"Get a specific parliamentary entity by ID.\"\"\"\n    try:\n        import uuid\n        entity_uuid = uuid.UUID(entity_id)\n        entity = db.query(ParliamentaryEntity).filter(ParliamentaryEntity.id == entity_uuid).first()\n        \n        if entity:\n            return EntityResponse(\n                id=str(entity.id)",
        "import:fastapi.EntityResponse(\n                id=\"2\"",
        "import:fastapi.created_at=\"2024-01-01T00:00:00Z\"",
        "import:fastapi.type=\"mp\"",
        "import:fastapi.detail=\"Entity not found\")\n            \n    except ValueError:\n        raise HTTPException(status_code=400",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )\n        \n        raise HTTPException(status_code=404",
        "import:fastapi.\"sponsor\": \"Jane Smith\"}",
        "import:fastapi.Depends\nfrom typing import List",
        "import:fastapi.type=entity.type",
        "import:fastapi.size=size\n        )\n        \n    except Exception as e:\n        # Fallback to mock data if database fails\n        mock_entities = [\n            EntityResponse(\n                id=\"1\"",
        "import:fastapi.response_model=EntityListResponse)\nasync def list_entities(\n    type: Optional[str] = Query(None",
        "import:fastapi.description=\"Page size\")",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\nfrom app.database import get_db\nfrom app.models.parliamentary_entities import ParliamentaryEntity\n\nclass EntityResponse(BaseModel):\n    id: str\n    type: str\n    data: dict\n    created_at: str\n    updated_at: str\n\nclass EntityCreate(BaseModel):\n    type: str\n    data: dict\n\nclass EntityListResponse(BaseModel):\n    entities: List[EntityResponse]\n    total: int\n    page: int\n    size: int\n\nrouter = APIRouter()\n\n@router.get(\"/\"",
        "import:fastapi.ge=1",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )",
        "import:fastapi.response_model=EntityResponse)\nasync def get_entity(entity_id: str",
        "import:fastapi.type=\"bill\"",
        "import:fastapi.\"status\": \"introduced\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )\n        ]\n        \n        if type:\n            mock_entities = [e for e in mock_entities if e.type == type]\n        \n        return EntityListResponse(\n            entities=mock_entities",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )\n        elif entity_id == \"2\":\n            return EntityResponse(\n                id=\"2\"",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.total=total",
        "import:fastapi.detail=\"Invalid entity ID format\")\n    except Exception as e:\n        # Fallback to mock data if database fails\n        if entity_id == \"1\":\n            return EntityResponse(\n                id=\"1\"",
        "import:fastapi.size=size\n        )\n\n@router.get(\"/{entity_id}\"",
        "import:fastapi.updated_at=entity.updated_at.isoformat() if entity.updated_at else None\n            )\n            for entity in entities\n        ]\n        \n        return EntityListResponse(\n            entities=entity_responses",
        "import:fastapi.page=page",
        "import:fastapi.\"party\": \"Liberal\"",
        "import:fastapi.total=len(mock_entities)",
        "import:fastapi.\"riding\": \"Toronto Centre\"}",
        "import:fastapi.APIRouter",
        "import:fastapi.data={\"name\": \"John Doe\"",
        "import:fastapi.HTTPException",
        "function:get_entity"
      ]
    },
    "GET:/user/{user_id}": {
      "method": "GET",
      "path": "/user/{user_id}",
      "file": "services/api-gateway/app/api/v1/saved-items.py",
      "line": 52,
      "dependencies": [
        "import:fastapi.SavedItemResponse",
        "import:fastapi.saved_at=datetime.utcnow()",
        "import:fastapi.item_id=item_data.item_id",
        "import:fastapi.item_title=item_data.item_title",
        "import:fastapi.detail=\"Item already saved\")\n        \n        # Create new saved item\n        saved_item = SavedItem(\n            user_id=item_data.user_id",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "function:add_saved_item",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.saved_items import SavedItem\nfrom app.schemas.saved_items import SavedItemCreate",
        "import:fastapi.notes=item_data.notes or \"\"",
        "import:fastapi.item_url=item_data.item_url",
        "import:fastapi.response_model=SavedItemResponse)\nasync def add_saved_item(\n    item_data: SavedItemCreate",
        "import:fastapi.tags=[\"Saved Items\"])\n\n@router.post(\"/\"",
        "import:fastapi.Depends",
        "import:fastapi.item_type=item_data.item_type",
        "import:fastapi.SavedItemUpdate",
        "import:fastapi.tags=item_data.tags or []\n        )\n        \n        db.add(saved_item)\n        db.commit()\n        db.refresh(saved_item)\n        \n        return SavedItemResponse.from_orm(saved_item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.SavedItemListResponse\n\nrouter = APIRouter(prefix=\"/saved-items\"",
        "import:fastapi.detail=f\"Failed to save item: {str(e)}\")",
        "import:fastapi.SavedItem.item_id == item_data.item_id",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Add a new item to user's saved list\"\"\"\n    try:\n        # Check if item already exists\n        existing_item = db.query(SavedItem).filter(\n            SavedItem.user_id == item_data.user_id",
        "import:fastapi.SavedItem.item_type == item_data.item_type\n        ).first()\n        \n        if existing_item:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/{item_id}": {
      "method": "GET",
      "path": "/{item_id}",
      "file": "services/api-gateway/app/api/v1/saved-items.py",
      "line": 104,
      "dependencies": [
        "function:get_user_saved_items",
        "import:fastapi.SavedItemResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=f\"Failed to retrieve saved items: {str(e)}\")",
        "import:fastapi.description=\"Filter by tags (comma-separated)\")",
        "import:fastapi.saved_at=datetime.utcnow()",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.item_id=item_data.item_id",
        "import:fastapi.item_title=item_data.item_title",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.total_pages=(total_count + page_size - 1) // page_size\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.detail=\"Item already saved\")\n        \n        # Create new saved item\n        saved_item = SavedItem(\n            user_id=item_data.user_id",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.description=\"Filter by item type\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get user's saved items with optional filtering\"\"\"\n    try:\n        query = db.query(SavedItem).filter(SavedItem.user_id == user_id)\n        \n        # Apply filters\n        if item_type:\n            query = query.filter(SavedItem.item_type == item_type)\n        \n        if search:\n            search_term = f\"%{search}%\"\n            query = query.filter(\n                (SavedItem.item_title.ilike(search_term)) |\n                (SavedItem.notes.ilike(search_term)) |\n                (SavedItem.tags.any(lambda tag: search_term in tag))\n            )\n        \n        if tags:\n            tag_list = [tag.strip() for tag in tags.split(\"",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.saved_items import SavedItem\nfrom app.schemas.saved_items import SavedItemCreate",
        "import:fastapi.notes=item_data.notes or \"\"",
        "import:fastapi.total_count=total_count",
        "import:fastapi.ge=1",
        "import:fastapi.item_url=item_data.item_url",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_model=SavedItemResponse)\nasync def add_saved_item(\n    item_data: SavedItemCreate",
        "import:fastapi.tags=[\"Saved Items\"])\n\n@router.post(\"/\"",
        "import:fastapi.Depends",
        "import:fastapi.le=100",
        "import:fastapi.item_type=item_data.item_type",
        "import:fastapi.and tags\")",
        "import:fastapi.SavedItemUpdate",
        "import:fastapi.tags=item_data.tags or []\n        )\n        \n        db.add(saved_item)\n        db.commit()\n        db.refresh(saved_item)\n        \n        return SavedItemResponse.from_orm(saved_item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.item_type: Optional[str] = Query(None",
        "import:fastapi.notes",
        "import:fastapi.page=page",
        "import:fastapi.SavedItemListResponse\n\nrouter = APIRouter(prefix=\"/saved-items\"",
        "import:fastapi.description=\"Search in titles",
        "import:fastapi.response_model=SavedItemListResponse)\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\")]\n            for tag in tag_list:\n                query = query.filter(SavedItem.tags.contains([tag]))\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        items = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [SavedItemResponse.from_orm(item) for item in items]\n        \n        return SavedItemListResponse(\n            results=results",
        "import:fastapi.SavedItem.item_id == item_data.item_id",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Add a new item to user's saved list\"\"\"\n    try:\n        # Check if item already exists\n        existing_item = db.query(SavedItem).filter(\n            SavedItem.user_id == item_data.user_id",
        "import:fastapi.detail=f\"Failed to save item: {str(e)}\")\n\n@router.get(\"/user/{user_id}\"",
        "import:fastapi.SavedItem.item_type == item_data.item_type\n        ).first()\n        \n        if existing_item:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "PUT:/{item_id}": {
      "method": "PUT",
      "path": "/{item_id}",
      "file": "services/api-gateway/app/api/v1/saved-items.py",
      "line": 125,
      "dependencies": [
        "import:fastapi.SavedItemResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by tags (comma-separated)\")",
        "import:fastapi.saved_at=datetime.utcnow()",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.item_id=item_data.item_id",
        "import:fastapi.item_title=item_data.item_title",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.total_pages=(total_count + page_size - 1) // page_size\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.detail=\"Item already saved\")\n        \n        # Create new saved item\n        saved_item = SavedItem(\n            user_id=item_data.user_id",
        "import:fastapi.detail=f\"Failed to retrieve saved item: {str(e)}\")",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.detail=f\"Failed to retrieve saved items: {str(e)}\")\n\n@router.get(\"/{item_id}\"",
        "import:fastapi.description=\"Filter by item type\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.response_model=SavedItemResponse)\nasync def get_saved_item(\n    item_id: str",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get user's saved items with optional filtering\"\"\"\n    try:\n        query = db.query(SavedItem).filter(SavedItem.user_id == user_id)\n        \n        # Apply filters\n        if item_type:\n            query = query.filter(SavedItem.item_type == item_type)\n        \n        if search:\n            search_term = f\"%{search}%\"\n            query = query.filter(\n                (SavedItem.item_title.ilike(search_term)) |\n                (SavedItem.notes.ilike(search_term)) |\n                (SavedItem.tags.any(lambda tag: search_term in tag))\n            )\n        \n        if tags:\n            tag_list = [tag.strip() for tag in tags.split(\"",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.saved_items import SavedItem\nfrom app.schemas.saved_items import SavedItemCreate",
        "import:fastapi.notes=item_data.notes or \"\"",
        "import:fastapi.user_id: str = Query(...",
        "import:fastapi.total_count=total_count",
        "import:fastapi.ge=1",
        "import:fastapi.item_url=item_data.item_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_model=SavedItemResponse)\nasync def add_saved_item(\n    item_data: SavedItemCreate",
        "import:fastapi.tags=[\"Saved Items\"])\n\n@router.post(\"/\"",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get a specific saved item\"\"\"\n    try:\n        item = db.query(SavedItem).filter(\n            SavedItem.id == item_id",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        return SavedItemResponse.from_orm(item)\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.Depends",
        "import:fastapi.le=100",
        "import:fastapi.item_type=item_data.item_type",
        "import:fastapi.SavedItem.user_id == user_id\n        ).first()\n        \n        if not item:\n            raise HTTPException(status_code=404",
        "import:fastapi.and tags\")",
        "import:fastapi.SavedItemUpdate",
        "import:fastapi.tags=item_data.tags or []\n        )\n        \n        db.add(saved_item)\n        db.commit()\n        db.refresh(saved_item)\n        \n        return SavedItemResponse.from_orm(saved_item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.item_type: Optional[str] = Query(None",
        "import:fastapi.notes",
        "import:fastapi.page=page",
        "import:fastapi.SavedItemListResponse\n\nrouter = APIRouter(prefix=\"/saved-items\"",
        "import:fastapi.description=\"Search in titles",
        "import:fastapi.response_model=SavedItemListResponse)\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\")]\n            for tag in tag_list:\n                query = query.filter(SavedItem.tags.contains([tag]))\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        items = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [SavedItemResponse.from_orm(item) for item in items]\n        \n        return SavedItemListResponse(\n            results=results",
        "import:fastapi.SavedItem.item_id == item_data.item_id",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Add a new item to user's saved list\"\"\"\n    try:\n        # Check if item already exists\n        existing_item = db.query(SavedItem).filter(\n            SavedItem.user_id == item_data.user_id",
        "import:fastapi.detail=f\"Failed to save item: {str(e)}\")\n\n@router.get(\"/user/{user_id}\"",
        "import:fastapi.SavedItem.item_type == item_data.item_type\n        ).first()\n        \n        if existing_item:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "function:get_saved_item"
      ]
    },
    "DELETE:/{item_id}": {
      "method": "DELETE",
      "path": "/{item_id}",
      "file": "services/api-gateway/app/api/v1/saved-items.py",
      "line": 157,
      "dependencies": [
        "import:fastapi.update_data: SavedItemUpdate",
        "import:fastapi.SavedItemResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by tags (comma-separated)\")",
        "import:fastapi.saved_at=datetime.utcnow()",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Update a saved item (notes",
        "import:fastapi.item_id=item_data.item_id",
        "import:fastapi.item_title=item_data.item_title",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.total_pages=(total_count + page_size - 1) // page_size\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.detail=\"Item already saved\")\n        \n        # Create new saved item\n        saved_item = SavedItem(\n            user_id=item_data.user_id",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.detail=f\"Failed to retrieve saved items: {str(e)}\")\n\n@router.get(\"/{item_id}\"",
        "import:fastapi.description=\"Filter by item type\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.response_model=SavedItemResponse)\nasync def get_saved_item(\n    item_id: str",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get user's saved items with optional filtering\"\"\"\n    try:\n        query = db.query(SavedItem).filter(SavedItem.user_id == user_id)\n        \n        # Apply filters\n        if item_type:\n            query = query.filter(SavedItem.item_type == item_type)\n        \n        if search:\n            search_term = f\"%{search}%\"\n            query = query.filter(\n                (SavedItem.item_title.ilike(search_term)) |\n                (SavedItem.notes.ilike(search_term)) |\n                (SavedItem.tags.any(lambda tag: search_term in tag))\n            )\n        \n        if tags:\n            tag_list = [tag.strip() for tag in tags.split(\"",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.saved_items import SavedItem\nfrom app.schemas.saved_items import SavedItemCreate",
        "import:fastapi.notes=item_data.notes or \"\"",
        "import:fastapi.user_id: str = Query(...",
        "import:fastapi.total_count=total_count",
        "import:fastapi.ge=1",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        # Update fields\n        if update_data.notes is not None:\n            item.notes = update_data.notes\n        if update_data.tags is not None:\n            item.tags = update_data.tags\n        \n        db.commit()\n        db.refresh(item)\n        \n        return SavedItemResponse.from_orm(item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.detail=f\"Failed to update saved item: {str(e)}\")",
        "import:fastapi.item_url=item_data.item_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.response_model=SavedItemResponse)\nasync def update_saved_item(\n    item_id: str",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_model=SavedItemResponse)\nasync def add_saved_item(\n    item_data: SavedItemCreate",
        "import:fastapi.tags=[\"Saved Items\"])\n\n@router.post(\"/\"",
        "function:update_saved_item",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get a specific saved item\"\"\"\n    try:\n        item = db.query(SavedItem).filter(\n            SavedItem.id == item_id",
        "import:fastapi.detail=f\"Failed to retrieve saved item: {str(e)}\")\n\n@router.put(\"/{item_id}\"",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        return SavedItemResponse.from_orm(item)\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.Depends",
        "import:fastapi.le=100",
        "import:fastapi.item_type=item_data.item_type",
        "import:fastapi.SavedItem.user_id == user_id\n        ).first()\n        \n        if not item:\n            raise HTTPException(status_code=404",
        "import:fastapi.and tags\")",
        "import:fastapi.SavedItemUpdate",
        "import:fastapi.tags=item_data.tags or []\n        )\n        \n        db.add(saved_item)\n        db.commit()\n        db.refresh(saved_item)\n        \n        return SavedItemResponse.from_orm(saved_item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.item_type: Optional[str] = Query(None",
        "import:fastapi.notes",
        "import:fastapi.page=page",
        "import:fastapi.SavedItemListResponse\n\nrouter = APIRouter(prefix=\"/saved-items\"",
        "import:fastapi.description=\"Search in titles",
        "import:fastapi.response_model=SavedItemListResponse)\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\")]\n            for tag in tag_list:\n                query = query.filter(SavedItem.tags.contains([tag]))\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        items = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [SavedItemResponse.from_orm(item) for item in items]\n        \n        return SavedItemListResponse(\n            results=results",
        "import:fastapi.SavedItem.item_id == item_data.item_id",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Add a new item to user's saved list\"\"\"\n    try:\n        # Check if item already exists\n        existing_item = db.query(SavedItem).filter(\n            SavedItem.user_id == item_data.user_id",
        "import:fastapi.detail=f\"Failed to save item: {str(e)}\")\n\n@router.get(\"/user/{user_id}\"",
        "import:fastapi.SavedItem.item_type == item_data.item_type\n        ).first()\n        \n        if existing_item:\n            raise HTTPException(status_code=400",
        "import:fastapi.tags)\"\"\"\n    try:\n        item = db.query(SavedItem).filter(\n            SavedItem.id == item_id",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/user/{user_id}/stats": {
      "method": "GET",
      "path": "/user/{user_id}/stats",
      "file": "services/api-gateway/app/api/v1/saved-items.py",
      "line": 185,
      "dependencies": [
        "import:fastapi.update_data: SavedItemUpdate",
        "import:fastapi.SavedItemResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by tags (comma-separated)\")",
        "import:fastapi.saved_at=datetime.utcnow()",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Update a saved item (notes",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Remove an item from user's saved list\"\"\"\n    try:\n        # Find item by user_id",
        "import:fastapi.item_id=item_data.item_id",
        "import:fastapi.item_title=item_data.item_title",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.total_pages=(total_count + page_size - 1) // page_size\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.detail=\"Item already saved\")\n        \n        # Create new saved item\n        saved_item = SavedItem(\n            user_id=item_data.user_id",
        "import:fastapi.and item_type\n        item = db.query(SavedItem).filter(\n            SavedItem.user_id == user_id",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        db.delete(item)\n        db.commit()\n        \n        return {\"message\": \"Item removed from saved list successfully\"}\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.detail=f\"Failed to remove saved item: {str(e)}\")",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.description=\"Item type for identification\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.detail=f\"Failed to retrieve saved items: {str(e)}\")\n\n@router.get(\"/{item_id}\"",
        "import:fastapi.description=\"Filter by item type\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.response_model=SavedItemResponse)\nasync def get_saved_item(\n    item_id: str",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get user's saved items with optional filtering\"\"\"\n    try:\n        query = db.query(SavedItem).filter(SavedItem.user_id == user_id)\n        \n        # Apply filters\n        if item_type:\n            query = query.filter(SavedItem.item_type == item_type)\n        \n        if search:\n            search_term = f\"%{search}%\"\n            query = query.filter(\n                (SavedItem.item_title.ilike(search_term)) |\n                (SavedItem.notes.ilike(search_term)) |\n                (SavedItem.tags.any(lambda tag: search_term in tag))\n            )\n        \n        if tags:\n            tag_list = [tag.strip() for tag in tags.split(\"",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.saved_items import SavedItem\nfrom app.schemas.saved_items import SavedItemCreate",
        "import:fastapi.notes=item_data.notes or \"\"",
        "import:fastapi.user_id: str = Query(...",
        "import:fastapi.item_id",
        "import:fastapi.SavedItem.item_id == item_id",
        "import:fastapi.total_count=total_count",
        "import:fastapi.ge=1",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        # Update fields\n        if update_data.notes is not None:\n            item.notes = update_data.notes\n        if update_data.tags is not None:\n            item.tags = update_data.tags\n        \n        db.commit()\n        db.refresh(item)\n        \n        return SavedItemResponse.from_orm(item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.item_url=item_data.item_url",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.response_model=SavedItemResponse)\nasync def update_saved_item(\n    item_id: str",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.response_model=SavedItemResponse)\nasync def add_saved_item(\n    item_data: SavedItemCreate",
        "import:fastapi.tags=[\"Saved Items\"])\n\n@router.post(\"/\"",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get a specific saved item\"\"\"\n    try:\n        item = db.query(SavedItem).filter(\n            SavedItem.id == item_id",
        "import:fastapi.detail=f\"Failed to retrieve saved item: {str(e)}\")\n\n@router.put(\"/{item_id}\"",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        return SavedItemResponse.from_orm(item)\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.detail=f\"Failed to update saved item: {str(e)}\")\n\n@router.delete(\"/{item_id}\")\nasync def remove_saved_item(\n    item_id: str",
        "import:fastapi.Depends",
        "import:fastapi.le=100",
        "import:fastapi.item_type=item_data.item_type",
        "function:remove_saved_item",
        "import:fastapi.item_type: str = Query(...",
        "import:fastapi.SavedItem.user_id == user_id\n        ).first()\n        \n        if not item:\n            raise HTTPException(status_code=404",
        "import:fastapi.and tags\")",
        "import:fastapi.SavedItemUpdate",
        "import:fastapi.tags=item_data.tags or []\n        )\n        \n        db.add(saved_item)\n        db.commit()\n        db.refresh(saved_item)\n        \n        return SavedItemResponse.from_orm(saved_item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.item_type: Optional[str] = Query(None",
        "import:fastapi.notes",
        "import:fastapi.page=page",
        "import:fastapi.SavedItemListResponse\n\nrouter = APIRouter(prefix=\"/saved-items\"",
        "import:fastapi.description=\"Search in titles",
        "import:fastapi.response_model=SavedItemListResponse)\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.\")]\n            for tag in tag_list:\n                query = query.filter(SavedItem.tags.contains([tag]))\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        items = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [SavedItemResponse.from_orm(item) for item in items]\n        \n        return SavedItemListResponse(\n            results=results",
        "import:fastapi.SavedItem.item_id == item_data.item_id",
        "import:fastapi.SavedItem.item_type == item_type\n        ).first()\n        \n        if not item:\n            raise HTTPException(status_code=404",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Add a new item to user's saved list\"\"\"\n    try:\n        # Check if item already exists\n        existing_item = db.query(SavedItem).filter(\n            SavedItem.user_id == item_data.user_id",
        "import:fastapi.detail=f\"Failed to save item: {str(e)}\")\n\n@router.get(\"/user/{user_id}\"",
        "import:fastapi.SavedItem.item_type == item_data.item_type\n        ).first()\n        \n        if existing_item:\n            raise HTTPException(status_code=400",
        "import:fastapi.tags)\"\"\"\n    try:\n        item = db.query(SavedItem).filter(\n            SavedItem.id == item_id",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "POST:/user/{user_id}/bulk-actions": {
      "method": "POST",
      "path": "/user/{user_id}/bulk-actions",
      "file": "services/api-gateway/app/api/v1/saved-items.py",
      "line": 239,
      "dependencies": [
        "import:fastapi.update_data: SavedItemUpdate",
        "import:fastapi.SavedItemResponse",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by tags (comma-separated)\")",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Remove an item from user's saved list\"\"\"\n    try:\n        # Find item by user_id",
        "import:fastapi.item_title=item_data.item_title",
        "import:fastapi.detail=\"Item already saved\")\n        \n        # Create new saved item\n        saved_item = SavedItem(\n            user_id=item_data.user_id",
        "import:fastapi.description=\"Item type for identification\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.response_model=SavedItemResponse)\nasync def get_saved_item(\n    item_id: str",
        "import:fastapi.SavedItem.item_type == item_type\n            ).count()\n            type_counts[item_type] = count\n        \n        # Get recent activity\n        recent_items = db.query(SavedItem).filter(\n            SavedItem.user_id == user_id\n        ).order_by(SavedItem.saved_at.desc()).limit(5).all()\n        \n        # Get tag statistics\n        all_tags = []\n        for item in db.query(SavedItem).filter(SavedItem.user_id == user_id).all():\n            all_tags.extend(item.tags or [])\n        \n        tag_counts = {}\n        for tag in all_tags:\n            tag_counts[tag] = tag_counts.get(tag",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.saved_items import SavedItem\nfrom app.schemas.saved_items import SavedItemCreate",
        "import:fastapi.'mp'",
        "import:fastapi.notes=item_data.notes or \"\"",
        "import:fastapi.user_id: str = Query(...",
        "import:fastapi.total_count=total_count",
        "import:fastapi.ge=1",
        "import:fastapi.'vote']:\n            count = db.query(SavedItem).filter(\n                SavedItem.user_id == user_id",
        "import:fastapi.description=\"User ID\")",
        "import:fastapi.detail=f\"Failed to retrieve saved item: {str(e)}\")\n\n@router.put(\"/{item_id}\"",
        "import:fastapi.detail=f\"Failed to update saved item: {str(e)}\")\n\n@router.delete(\"/{item_id}\")\nasync def remove_saved_item(\n    item_id: str",
        "import:fastapi.le=100",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get statistics about user's saved items\"\"\"\n    try:\n        # Get total count\n        total_count = db.query(SavedItem).filter(SavedItem.user_id == user_id).count()\n        \n        # Get count by type\n        type_counts = {}\n        for item_type in ['bill'",
        "import:fastapi.tags=item_data.tags or []\n        )\n        \n        db.add(saved_item)\n        db.commit()\n        db.refresh(saved_item)\n        \n        return SavedItemResponse.from_orm(saved_item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.detail=f\"Failed to save item: {str(e)}\")\n\n@router.get(\"/user/{user_id}\"",
        "import:fastapi.tags)\"\"\"\n    try:\n        item = db.query(SavedItem).filter(\n            SavedItem.id == item_id",
        "import:fastapi.HTTPException",
        "import:fastapi.'committee'",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Update a saved item (notes",
        "import:fastapi.total_pages=(total_count + page_size - 1) // page_size\n        )\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.and item_type\n        item = db.query(SavedItem).filter(\n            SavedItem.user_id == user_id",
        "import:fastapi.\"saved_at\": item.saved_at.isoformat()\n                }\n                for item in recent_items\n            ]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List",
        "import:fastapi.description=\"Filter by item type\")",
        "import:fastapi.0) + 1\n        \n        # Sort tags by frequency\n        top_tags = sorted(tag_counts.items()",
        "import:fastapi.tags=[\"Saved Items\"])\n\n@router.post(\"/\"",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get a specific saved item\"\"\"\n    try:\n        item = db.query(SavedItem).filter(\n            SavedItem.id == item_id",
        "import:fastapi.reverse=True)[:10]\n        \n        return {\n            \"total_saved_items\": total_count",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        return SavedItemResponse.from_orm(item)\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.Depends",
        "import:fastapi.item_type=item_data.item_type",
        "import:fastapi.\"item_title\": item.item_title",
        "import:fastapi.SavedItem.user_id == user_id\n        ).first()\n        \n        if not item:\n            raise HTTPException(status_code=404",
        "import:fastapi.item_type: Optional[str] = Query(None",
        "import:fastapi.notes",
        "import:fastapi.page=page",
        "import:fastapi.description=\"Search in titles",
        "import:fastapi.\"items_by_type\": type_counts",
        "import:fastapi.\")]\n            for tag in tag_list:\n                query = query.filter(SavedItem.tags.contains([tag]))\n        \n        # Get total count\n        total_count = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * page_size\n        items = query.offset(offset).limit(page_size).all()\n        \n        # Convert to response models\n        results = [SavedItemResponse.from_orm(item) for item in items]\n        \n        return SavedItemListResponse(\n            results=results",
        "import:fastapi.SavedItem.item_id == item_data.item_id",
        "import:fastapi.SavedItem.item_type == item_type\n        ).first()\n        \n        if not item:\n            raise HTTPException(status_code=404",
        "import:fastapi.'debate'",
        "import:fastapi.detail=f\"Failed to retrieve saved stats: {str(e)}\")",
        "import:fastapi.tags: Optional[str] = Query(None",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        db.delete(item)\n        db.commit()\n        \n        return {\"message\": \"Item removed from saved list successfully\"}\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.detail=f\"Failed to retrieve saved items: {str(e)}\")\n\n@router.get(\"/{item_id}\"",
        "import:fastapi.detail=f\"Failed to remove saved item: {str(e)}\")\n\n@router.get(\"/user/{user_id}/stats\")\nasync def get_user_saved_stats(\n    user_id: str",
        "import:fastapi.key=lambda x: x[1]",
        "import:fastapi.item_id",
        "import:fastapi.SavedItem.item_id == item_id",
        "import:fastapi.item_url=item_data.item_url",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.item_type: str = Query(...",
        "import:fastapi.count in top_tags]\n        }\n        \n    except Exception as e:\n        raise HTTPException(status_code=500",
        "import:fastapi.SavedItemUpdate",
        "import:fastapi.SavedItemListResponse\n\nrouter = APIRouter(prefix=\"/saved-items\"",
        "import:fastapi.response_model=SavedItemListResponse)\nasync def get_user_saved_items(\n    user_id: str",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Add a new item to user's saved list\"\"\"\n    try:\n        # Check if item already exists\n        existing_item = db.query(SavedItem).filter(\n            SavedItem.user_id == item_data.user_id",
        "import:fastapi.SavedItem.item_type == item_data.item_type\n        ).first()\n        \n        if existing_item:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"item_type\": item.item_type",
        "function:get_user_saved_stats",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.saved_at=datetime.utcnow()",
        "import:fastapi.item_id=item_data.item_id",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"Get user's saved items with optional filtering\"\"\"\n    try:\n        query = db.query(SavedItem).filter(SavedItem.user_id == user_id)\n        \n        # Apply filters\n        if item_type:\n            query = query.filter(SavedItem.item_type == item_type)\n        \n        if search:\n            search_term = f\"%{search}%\"\n            query = query.filter(\n                (SavedItem.item_title.ilike(search_term)) |\n                (SavedItem.notes.ilike(search_term)) |\n                (SavedItem.tags.any(lambda tag: search_term in tag))\n            )\n        \n        if tags:\n            tag_list = [tag.strip() for tag in tags.split(\"",
        "import:fastapi.detail=\"Saved item not found\")\n        \n        # Update fields\n        if update_data.notes is not None:\n            item.notes = update_data.notes\n        if update_data.tags is not None:\n            item.tags = update_data.tags\n        \n        db.commit()\n        db.refresh(item)\n        \n        return SavedItemResponse.from_orm(item)\n        \n    except Exception as e:\n        db.rollback()\n        raise HTTPException(status_code=500",
        "import:fastapi.response_model=SavedItemResponse)\nasync def update_saved_item(\n    item_id: str",
        "import:fastapi.response_model=SavedItemResponse)\nasync def add_saved_item(\n    item_data: SavedItemCreate",
        "import:fastapi.\"recent_items\": [\n                {\n                    \"id\": item.id",
        "import:fastapi.\"top_tags\": [{\"tag\": tag",
        "import:fastapi.and tags\")",
        "import:fastapi.\"count\": count} for tag",
        "import:fastapi.APIRouter"
      ]
    },
    "ROUTER:/saved-items": {
      "method": "ROUTER",
      "path": "/saved-items",
      "file": "services/api-gateway/app/api/v1/saved-items.py",
      "line": 11,
      "dependencies": [
        "import:fastapi.SavedItemResponse",
        "import:fastapi.Depends",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom datetime import datetime\n\nfrom app.database import get_db\nfrom app.models.saved_items import SavedItem\nfrom app.schemas.saved_items import SavedItemCreate",
        "import:fastapi.SavedItemListResponse\n\nrouter =",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "import:fastapi.SavedItemUpdate",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session\nfrom typing import List"
      ]
    },
    "POST:/types": {
      "method": "POST",
      "path": "/types",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 45,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DataVisualization",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Path",
        "import:fastapi.or_",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.Dashboard",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.VisualizationCache",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/types": {
      "method": "GET",
      "path": "/types",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 90,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.updated_at=viz_type.updated_at\n    )",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DataVisualization",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.Path",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.or_",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.Dashboard",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.VisualizationCache",
        "function:create_visualization_type",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/types/{type_id}": {
      "method": "GET",
      "path": "/types/{type_id}",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 160,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DataVisualization",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "function:list_visualization_types",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.Path",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.total=total",
        "import:fastapi.or_",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.Dashboard",
        "import:fastapi.page=page",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.VisualizationCache",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.HTTPException"
      ]
    },
    "POST:/visualizations": {
      "method": "POST",
      "path": "/visualizations",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 192,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.le=100",
        "import:fastapi.or_",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.HTTPException",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.Depends",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.VisualizationCache",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "function:get_visualization_type",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.Dashboard",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter"
      ]
    },
    "GET:/visualizations": {
      "method": "GET",
      "path": "/visualizations",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 240,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.created_at=visualization.created_at",
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.last_generated=visualization.last_generated",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new data visualization.\n    \"\"\"\n    # Verify visualization type exists\n    viz_type = db.query(VisualizationType).filter(\n        VisualizationType.id == viz_data.visualization_type_id\n    ).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.created_by=visualization.created_by",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.le=100",
        "import:fastapi.is_featured=visualization.is_featured",
        "import:fastapi.or_",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.data_source=visualization.data_source",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    # Create new visualization\n    visualization = DataVisualization(**viz_data.dict())\n    visualization.created_by = current_user.username\n    db.add(visualization)\n    db.commit()\n    db.refresh(visualization)\n    \n    logger.info(f\"Data visualization created: {current_user.username} - {viz_data.title}\")\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.view_count=visualization.view_count",
        "import:fastapi.HTTPException",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.tags=visualization.tags",
        "import:fastapi.cache_key=visualization.cache_key",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.Depends",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.VisualizationCache",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def create_data_visualization(\n    viz_data: DataVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=visualization.is_public",
        "function:create_data_visualization",
        "import:fastapi.title=visualization.title",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.generation_time_ms=visualization.generation_time_ms",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/visualizations\"",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.data_query=visualization.data_query",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.configuration=visualization.configuration",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.visualization_type_id=str(visualization.visualization_type_id)",
        "import:fastapi.updated_at=visualization.updated_at\n    )",
        "import:fastapi.description=visualization.description",
        "import:fastapi.Dashboard",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.cache_expires=visualization.cache_expires",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter"
      ]
    },
    "GET:/visualizations/{visualization_id}": {
      "method": "GET",
      "path": "/visualizations/{visualization_id}",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 328,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.created_at=visualization.created_at",
        "import:fastapi.page_size=page_size",
        "function:list_data_visualizations",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.last_generated=visualization.last_generated",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List data visualizations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(DataVisualization)\n    \n    # Apply filters\n    if visualization_type_id:\n        query = query.filter(DataVisualization.visualization_type_id == visualization_type_id)\n    \n    if data_source:\n        query = query.filter(DataVisualization.data_source == data_source)\n    \n    if is_public is not None:\n        query = query.filter(DataVisualization.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(DataVisualization.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(DataVisualization.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                DataVisualization.title.ilike(search_term)",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new data visualization.\n    \"\"\"\n    # Verify visualization type exists\n    viz_type = db.query(VisualizationType).filter(\n        VisualizationType.id == viz_data.visualization_type_id\n    ).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.created_by=visualization.created_by",
        "import:fastapi.updated_at=visualization.updated_at\n        ))\n    \n    return DataVisualizationListResponse(\n        visualizations=viz_responses",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.le=100",
        "import:fastapi.is_featured=visualization.is_featured",
        "import:fastapi.or_",
        "import:fastapi.description=\"Filter by featured status\")",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.description=\"Filter by data source\")",
        "import:fastapi.data_source=visualization.data_source",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    # Create new visualization\n    visualization = DataVisualization(**viz_data.dict())\n    visualization.created_by = current_user.username\n    db.add(visualization)\n    db.commit()\n    db.refresh(visualization)\n    \n    logger.info(f\"Data visualization created: {current_user.username} - {viz_data.title}\")\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.view_count=visualization.view_count",
        "import:fastapi.HTTPException",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n@router.get(\"/visualizations\"",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.tags=visualization.tags",
        "import:fastapi.visualization_type_id: Optional[str] = Query(None",
        "import:fastapi.cache_key=visualization.cache_key",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by creator\")",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.Depends",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.VisualizationCache",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def create_data_visualization(\n    viz_data: DataVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=visualization.is_public",
        "import:fastapi.title=visualization.title",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.response_model=DataVisualizationListResponse)\nasync def list_data_visualizations(\n    page: int = Query(1",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.generation_time_ms=visualization.generation_time_ms",
        "import:fastapi.created_by: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.data_source: Optional[DataSourceEnum] = Query(None",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/visualizations\"",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.data_query=visualization.data_query",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.is_featured: Optional[bool] = Query(None",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Search in titles and descriptions\")",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.configuration=visualization.configuration",
        "import:fastapi.description=\"Filter by visualization type ID\")",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.visualization_type_id=str(visualization.visualization_type_id)",
        "import:fastapi.description=visualization.description",
        "import:fastapi.Dashboard",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.cache_expires=visualization.cache_expires",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.DataVisualization.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get visualizations\n    visualizations = query.order_by(desc(DataVisualization.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    viz_responses = []\n    for visualization in visualizations:\n        viz_responses.append(DataVisualizationResponse(\n            id=str(visualization.id)"
      ]
    },
    "POST:/dashboards": {
      "method": "POST",
      "path": "/dashboards",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 373,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.created_at=visualization.created_at",
        "import:fastapi.page_size=page_size",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.last_generated=visualization.last_generated",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List data visualizations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(DataVisualization)\n    \n    # Apply filters\n    if visualization_type_id:\n        query = query.filter(DataVisualization.visualization_type_id == visualization_type_id)\n    \n    if data_source:\n        query = query.filter(DataVisualization.data_source == data_source)\n    \n    if is_public is not None:\n        query = query.filter(DataVisualization.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(DataVisualization.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(DataVisualization.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                DataVisualization.title.ilike(search_term)",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new data visualization.\n    \"\"\"\n    # Verify visualization type exists\n    viz_type = db.query(VisualizationType).filter(\n        VisualizationType.id == viz_data.visualization_type_id\n    ).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.created_by=visualization.created_by",
        "import:fastapi.updated_at=visualization.updated_at\n        ))\n    \n    return DataVisualizationListResponse(\n        visualizations=viz_responses",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def get_data_visualization(\n    visualization_id: str = Path(...",
        "import:fastapi.le=100",
        "import:fastapi.is_featured=visualization.is_featured",
        "import:fastapi.or_",
        "import:fastapi.description=\"Filter by featured status\")",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific data visualization by ID.\n    \"\"\"\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by data source\")",
        "import:fastapi.data_source=visualization.data_source",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    # Create new visualization\n    visualization = DataVisualization(**viz_data.dict())\n    visualization.created_by = current_user.username\n    db.add(visualization)\n    db.commit()\n    db.refresh(visualization)\n    \n    logger.info(f\"Data visualization created: {current_user.username} - {viz_data.title}\")\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.view_count=visualization.view_count",
        "import:fastapi.HTTPException",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n# ============================================================================\n# DASHBOARD MANAGEMENT\n# ============================================================================",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n@router.get(\"/visualizations\"",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.tags=visualization.tags",
        "import:fastapi.visualization_type_id: Optional[str] = Query(None",
        "import:fastapi.cache_key=visualization.cache_key",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by creator\")",
        "import:fastapi.description=\"Visualization ID\")",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.Depends",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.VisualizationCache",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def create_data_visualization(\n    viz_data: DataVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=visualization.is_public",
        "import:fastapi.title=visualization.title",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "function:get_data_visualization",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.response_model=DataVisualizationListResponse)\nasync def list_data_visualizations(\n    page: int = Query(1",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.generation_time_ms=visualization.generation_time_ms",
        "import:fastapi.created_by: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.data_source: Optional[DataSourceEnum] = Query(None",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/visualizations\"",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/visualizations/{visualization_id}\"",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.data_query=visualization.data_query",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.is_featured: Optional[bool] = Query(None",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=\"Data visualization not found\")\n    \n    # Increment view count\n    visualization.view_count += 1\n    db.commit()\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Search in titles and descriptions\")",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.configuration=visualization.configuration",
        "import:fastapi.description=\"Filter by visualization type ID\")",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.visualization_type_id=str(visualization.visualization_type_id)",
        "import:fastapi.description=visualization.description",
        "import:fastapi.Dashboard",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.cache_expires=visualization.cache_expires",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.DataVisualization.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get visualizations\n    visualizations = query.order_by(desc(DataVisualization.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    viz_responses = []\n    for visualization in visualizations:\n        viz_responses.append(DataVisualizationResponse(\n            id=str(visualization.id)"
      ]
    },
    "GET:/dashboards": {
      "method": "GET",
      "path": "/dashboards",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 409,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.created_at=visualization.created_at",
        "import:fastapi.page_size=page_size",
        "import:fastapi.layout_config=dashboard.layout_config",
        "import:fastapi.is_public=dashboard.is_public",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.last_generated=visualization.last_generated",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List data visualizations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(DataVisualization)\n    \n    # Apply filters\n    if visualization_type_id:\n        query = query.filter(DataVisualization.visualization_type_id == visualization_type_id)\n    \n    if data_source:\n        query = query.filter(DataVisualization.data_source == data_source)\n    \n    if is_public is not None:\n        query = query.filter(DataVisualization.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(DataVisualization.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(DataVisualization.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                DataVisualization.title.ilike(search_term)",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new data visualization.\n    \"\"\"\n    # Verify visualization type exists\n    viz_type = db.query(VisualizationType).filter(\n        VisualizationType.id == viz_data.visualization_type_id\n    ).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.created_by=visualization.created_by",
        "import:fastapi.updated_at=visualization.updated_at\n        ))\n    \n    return DataVisualizationListResponse(\n        visualizations=viz_responses",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.view_count=dashboard.view_count",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def get_data_visualization(\n    visualization_id: str = Path(...",
        "import:fastapi.le=100",
        "import:fastapi.is_featured=visualization.is_featured",
        "import:fastapi.or_",
        "import:fastapi.description=\"Filter by featured status\")",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n# ============================================================================\n# DASHBOARD MANAGEMENT\n# ============================================================================\n\n@router.post(\"/dashboards\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific data visualization by ID.\n    \"\"\"\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by data source\")",
        "import:fastapi.data_source=visualization.data_source",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    # Create new visualization\n    visualization = DataVisualization(**viz_data.dict())\n    visualization.created_by = current_user.username\n    db.add(visualization)\n    db.commit()\n    db.refresh(visualization)\n    \n    logger.info(f\"Data visualization created: {current_user.username} - {viz_data.title}\")\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.view_count=visualization.view_count",
        "import:fastapi.HTTPException",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.tags=dashboard.tags",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n@router.get(\"/visualizations\"",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.tags=visualization.tags",
        "import:fastapi.created_by=dashboard.created_by",
        "import:fastapi.description=dashboard.description",
        "import:fastapi.visualization_type_id: Optional[str] = Query(None",
        "import:fastapi.cache_key=visualization.cache_key",
        "import:fastapi.response_model=DashboardResponse)\nasync def create_dashboard(\n    dashboard_data: DashboardCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by creator\")",
        "import:fastapi.description=\"Visualization ID\")",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.Depends",
        "import:fastapi.is_featured=dashboard.is_featured",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.title=dashboard.title",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.VisualizationCache",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def create_data_visualization(\n    viz_data: DataVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=visualization.is_public",
        "import:fastapi.title=visualization.title",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.response_model=DataVisualizationListResponse)\nasync def list_data_visualizations(\n    page: int = Query(1",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.refresh_interval=dashboard.refresh_interval",
        "import:fastapi.generation_time_ms=visualization.generation_time_ms",
        "import:fastapi.created_by: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.created_at=dashboard.created_at",
        "import:fastapi.data_source: Optional[DataSourceEnum] = Query(None",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.last_accessed=dashboard.last_accessed",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/visualizations\"",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/visualizations/{visualization_id}\"",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.theme=dashboard.theme",
        "function:create_dashboard",
        "import:fastapi.data_query=visualization.data_query",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.updated_at=dashboard.updated_at\n    )",
        "import:fastapi.is_featured: Optional[bool] = Query(None",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=\"Data visualization not found\")\n    \n    # Increment view count\n    visualization.view_count += 1\n    db.commit()\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Search in titles and descriptions\")",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.configuration=visualization.configuration",
        "import:fastapi.description=\"Filter by visualization type ID\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new dashboard.\n    \"\"\"\n    # Create new dashboard\n    dashboard = Dashboard(**dashboard_data.dict())\n    dashboard.created_by = current_user.username\n    db.add(dashboard)\n    db.commit()\n    db.refresh(dashboard)\n    \n    logger.info(f\"Dashboard created: {current_user.username} - {dashboard_data.title}\")\n    \n    return DashboardResponse(\n        id=str(dashboard.id)",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.visualization_type_id=str(visualization.visualization_type_id)",
        "import:fastapi.description=visualization.description",
        "import:fastapi.Dashboard",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.cache_expires=visualization.cache_expires",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.DataVisualization.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get visualizations\n    visualizations = query.order_by(desc(DataVisualization.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    viz_responses = []\n    for visualization in visualizations:\n        viz_responses.append(DataVisualizationResponse(\n            id=str(visualization.id)"
      ]
    },
    "GET:/dashboards/{dashboard_id}": {
      "method": "GET",
      "path": "/dashboards/{dashboard_id}",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 489,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.created_at=visualization.created_at",
        "import:fastapi.page_size=page_size",
        "import:fastapi.layout_config=dashboard.layout_config",
        "import:fastapi.is_public=dashboard.is_public",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.last_generated=visualization.last_generated",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List data visualizations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(DataVisualization)\n    \n    # Apply filters\n    if visualization_type_id:\n        query = query.filter(DataVisualization.visualization_type_id == visualization_type_id)\n    \n    if data_source:\n        query = query.filter(DataVisualization.data_source == data_source)\n    \n    if is_public is not None:\n        query = query.filter(DataVisualization.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(DataVisualization.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(DataVisualization.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                DataVisualization.title.ilike(search_term)",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new data visualization.\n    \"\"\"\n    # Verify visualization type exists\n    viz_type = db.query(VisualizationType).filter(\n        VisualizationType.id == viz_data.visualization_type_id\n    ).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.created_by=visualization.created_by",
        "import:fastapi.updated_at=visualization.updated_at\n        ))\n    \n    return DataVisualizationListResponse(\n        visualizations=viz_responses",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.view_count=dashboard.view_count",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def get_data_visualization(\n    visualization_id: str = Path(...",
        "import:fastapi.le=100",
        "import:fastapi.is_featured=visualization.is_featured",
        "import:fastapi.or_",
        "import:fastapi.description=\"Filter by featured status\")",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n# ============================================================================\n# DASHBOARD MANAGEMENT\n# ============================================================================\n\n@router.post(\"/dashboards\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific data visualization by ID.\n    \"\"\"\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by data source\")",
        "import:fastapi.data_source=visualization.data_source",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List dashboards with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Dashboard)\n    \n    # Apply filters\n    if theme:\n        query = query.filter(Dashboard.theme == theme)\n    \n    if is_public is not None:\n        query = query.filter(Dashboard.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(Dashboard.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(Dashboard.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Dashboard.title.ilike(search_term)",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    # Create new visualization\n    visualization = DataVisualization(**viz_data.dict())\n    visualization.created_by = current_user.username\n    db.add(visualization)\n    db.commit()\n    db.refresh(visualization)\n    \n    logger.info(f\"Data visualization created: {current_user.username} - {viz_data.title}\")\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.has_prev=page > 1\n    )",
        "import:fastapi.view_count=visualization.view_count",
        "import:fastapi.HTTPException",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.tags=dashboard.tags",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n@router.get(\"/visualizations\"",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.tags=visualization.tags",
        "import:fastapi.Dashboard.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get dashboards\n    dashboards = query.order_by(desc(Dashboard.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    dashboard_responses = []\n    for dashboard in dashboards:\n        dashboard_responses.append(DashboardResponse(\n            id=str(dashboard.id)",
        "import:fastapi.created_by=dashboard.created_by",
        "import:fastapi.description=dashboard.description",
        "import:fastapi.visualization_type_id: Optional[str] = Query(None",
        "import:fastapi.cache_key=visualization.cache_key",
        "import:fastapi.response_model=DashboardResponse)\nasync def create_dashboard(\n    dashboard_data: DashboardCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by creator\")",
        "import:fastapi.description=\"Visualization ID\")",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.Depends",
        "import:fastapi.is_featured=dashboard.is_featured",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.title=dashboard.title",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.VisualizationCache",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def create_data_visualization(\n    viz_data: DataVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=visualization.is_public",
        "import:fastapi.title=visualization.title",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.response_model=DataVisualizationListResponse)\nasync def list_data_visualizations(\n    page: int = Query(1",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.updated_at=dashboard.updated_at\n        ))\n    \n    return DashboardListResponse(\n        dashboards=dashboard_responses",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.refresh_interval=dashboard.refresh_interval",
        "import:fastapi.generation_time_ms=visualization.generation_time_ms",
        "import:fastapi.created_by: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.created_at=dashboard.created_at",
        "import:fastapi.data_source: Optional[DataSourceEnum] = Query(None",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.last_accessed=dashboard.last_accessed",
        "import:fastapi.updated_at=dashboard.updated_at\n    )\n\n\n@router.get(\"/dashboards\"",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/visualizations\"",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/visualizations/{visualization_id}\"",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.theme=dashboard.theme",
        "import:fastapi.theme: Optional[ThemeEnum] = Query(None",
        "import:fastapi.data_query=visualization.data_query",
        "function:list_dashboards",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.is_featured: Optional[bool] = Query(None",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=\"Data visualization not found\")\n    \n    # Increment view count\n    visualization.view_count += 1\n    db.commit()\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Search in titles and descriptions\")",
        "import:fastapi.description=\"Filter by theme\")",
        "import:fastapi.response_model=DashboardListResponse)\nasync def list_dashboards(\n    page: int = Query(1",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.configuration=visualization.configuration",
        "import:fastapi.description=\"Filter by visualization type ID\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new dashboard.\n    \"\"\"\n    # Create new dashboard\n    dashboard = Dashboard(**dashboard_data.dict())\n    dashboard.created_by = current_user.username\n    db.add(dashboard)\n    db.commit()\n    db.refresh(dashboard)\n    \n    logger.info(f\"Dashboard created: {current_user.username} - {dashboard_data.title}\")\n    \n    return DashboardResponse(\n        id=str(dashboard.id)",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.visualization_type_id=str(visualization.visualization_type_id)",
        "import:fastapi.description=visualization.description",
        "import:fastapi.Dashboard",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.cache_expires=visualization.cache_expires",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.DataVisualization.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get visualizations\n    visualizations = query.order_by(desc(DataVisualization.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    viz_responses = []\n    for visualization in visualizations:\n        viz_responses.append(DataVisualizationResponse(\n            id=str(visualization.id)"
      ]
    },
    "POST:/visualizations/{visualization_id}/generate": {
      "method": "POST",
      "path": "/visualizations/{visualization_id}/generate",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 529,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.created_at=visualization.created_at",
        "import:fastapi.page_size=page_size",
        "import:fastapi.layout_config=dashboard.layout_config",
        "import:fastapi.is_public=dashboard.is_public",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.last_generated=visualization.last_generated",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.description=\"Dashboard ID\")",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/dashboards/{dashboard_id}\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List data visualizations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(DataVisualization)\n    \n    # Apply filters\n    if visualization_type_id:\n        query = query.filter(DataVisualization.visualization_type_id == visualization_type_id)\n    \n    if data_source:\n        query = query.filter(DataVisualization.data_source == data_source)\n    \n    if is_public is not None:\n        query = query.filter(DataVisualization.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(DataVisualization.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(DataVisualization.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                DataVisualization.title.ilike(search_term)",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new data visualization.\n    \"\"\"\n    # Verify visualization type exists\n    viz_type = db.query(VisualizationType).filter(\n        VisualizationType.id == viz_data.visualization_type_id\n    ).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.created_by=visualization.created_by",
        "import:fastapi.updated_at=visualization.updated_at\n        ))\n    \n    return DataVisualizationListResponse(\n        visualizations=viz_responses",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.view_count=dashboard.view_count",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def get_data_visualization(\n    visualization_id: str = Path(...",
        "import:fastapi.le=100",
        "import:fastapi.is_featured=visualization.is_featured",
        "import:fastapi.or_",
        "import:fastapi.description=\"Filter by featured status\")",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n# ============================================================================\n# DASHBOARD MANAGEMENT\n# ============================================================================\n\n@router.post(\"/dashboards\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific data visualization by ID.\n    \"\"\"\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by data source\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific dashboard by ID.\n    \"\"\"\n    dashboard = db.query(Dashboard).filter(Dashboard.id == dashboard_id).first()\n    \n    if not dashboard:\n        raise HTTPException(status_code=404",
        "import:fastapi.data_source=visualization.data_source",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List dashboards with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Dashboard)\n    \n    # Apply filters\n    if theme:\n        query = query.filter(Dashboard.theme == theme)\n    \n    if is_public is not None:\n        query = query.filter(Dashboard.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(Dashboard.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(Dashboard.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Dashboard.title.ilike(search_term)",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    # Create new visualization\n    visualization = DataVisualization(**viz_data.dict())\n    visualization.created_by = current_user.username\n    db.add(visualization)\n    db.commit()\n    db.refresh(visualization)\n    \n    logger.info(f\"Data visualization created: {current_user.username} - {viz_data.title}\")\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.view_count=visualization.view_count",
        "import:fastapi.HTTPException",
        "import:fastapi.updated_at=dashboard.updated_at\n    )\n\n\n# ============================================================================\n# VISUALIZATION DATA GENERATION\n# ============================================================================",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.tags=dashboard.tags",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n@router.get(\"/visualizations\"",
        "import:fastapi.response_model=DashboardResponse)\nasync def get_dashboard(\n    dashboard_id: str = Path(...",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.tags=visualization.tags",
        "import:fastapi.Dashboard.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get dashboards\n    dashboards = query.order_by(desc(Dashboard.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    dashboard_responses = []\n    for dashboard in dashboards:\n        dashboard_responses.append(DashboardResponse(\n            id=str(dashboard.id)",
        "import:fastapi.created_by=dashboard.created_by",
        "import:fastapi.description=dashboard.description",
        "import:fastapi.visualization_type_id: Optional[str] = Query(None",
        "import:fastapi.cache_key=visualization.cache_key",
        "import:fastapi.response_model=DashboardResponse)\nasync def create_dashboard(\n    dashboard_data: DashboardCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.description=\"Filter by creator\")",
        "import:fastapi.description=\"Visualization ID\")",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.Depends",
        "import:fastapi.is_featured=dashboard.is_featured",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.title=dashboard.title",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.VisualizationCache",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def create_data_visualization(\n    viz_data: DataVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=visualization.is_public",
        "import:fastapi.title=visualization.title",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.response_model=DataVisualizationListResponse)\nasync def list_data_visualizations(\n    page: int = Query(1",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.updated_at=dashboard.updated_at\n        ))\n    \n    return DashboardListResponse(\n        dashboards=dashboard_responses",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.refresh_interval=dashboard.refresh_interval",
        "import:fastapi.generation_time_ms=visualization.generation_time_ms",
        "import:fastapi.created_by: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.created_at=dashboard.created_at",
        "import:fastapi.data_source: Optional[DataSourceEnum] = Query(None",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.last_accessed=dashboard.last_accessed",
        "import:fastapi.updated_at=dashboard.updated_at\n    )\n\n\n@router.get(\"/dashboards\"",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "function:get_dashboard",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/visualizations\"",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/visualizations/{visualization_id}\"",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.theme=dashboard.theme",
        "import:fastapi.theme: Optional[ThemeEnum] = Query(None",
        "import:fastapi.data_query=visualization.data_query",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.detail=\"Dashboard not found\")\n    \n    # Update last accessed and view count\n    dashboard.last_accessed = datetime.utcnow()\n    dashboard.view_count += 1\n    db.commit()\n    \n    return DashboardResponse(\n        id=str(dashboard.id)",
        "import:fastapi.is_featured: Optional[bool] = Query(None",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=\"Data visualization not found\")\n    \n    # Increment view count\n    visualization.view_count += 1\n    db.commit()\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Search in titles and descriptions\")",
        "import:fastapi.description=\"Filter by theme\")",
        "import:fastapi.response_model=DashboardListResponse)\nasync def list_dashboards(\n    page: int = Query(1",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.configuration=visualization.configuration",
        "import:fastapi.description=\"Filter by visualization type ID\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new dashboard.\n    \"\"\"\n    # Create new dashboard\n    dashboard = Dashboard(**dashboard_data.dict())\n    dashboard.created_by = current_user.username\n    db.add(dashboard)\n    db.commit()\n    db.refresh(dashboard)\n    \n    logger.info(f\"Dashboard created: {current_user.username} - {dashboard_data.title}\")\n    \n    return DashboardResponse(\n        id=str(dashboard.id)",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.visualization_type_id=str(visualization.visualization_type_id)",
        "import:fastapi.description=visualization.description",
        "import:fastapi.Dashboard",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.cache_expires=visualization.cache_expires",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.DataVisualization.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get visualizations\n    visualizations = query.order_by(desc(DataVisualization.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    viz_responses = []\n    for visualization in visualizations:\n        viz_responses.append(DataVisualizationResponse(\n            id=str(visualization.id)"
      ]
    },
    "POST:/dashboards/{dashboard_id}/visualizations": {
      "method": "POST",
      "path": "/dashboards/{dashboard_id}/visualizations",
      "file": "services/api-gateway/app/api/v1/data_visualizations.py",
      "line": 647,
      "dependencies": [
        "import:fastapi.desc",
        "import:fastapi.created_at=visualization.created_at",
        "import:fastapi.\"expires_at\": cached_data.expires_at",
        "import:fastapi.page_size=page_size",
        "import:fastapi.layout_config=dashboard.layout_config",
        "import:fastapi.is_public=dashboard.is_public",
        "import:fastapi.search: Optional[str] = Query(None",
        "import:fastapi.usedforsecurity=False).hexdigest()\n        config_hash = hashlib.md5(json.dumps(visualization.configuration",
        "import:fastapi.last_generated=visualization.last_generated",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List visualization types with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(VisualizationType)\n    \n    # Apply filters\n    if category:\n        query = query.filter(VisualizationType.category == category)\n    \n    if is_active is not None:\n        query = query.filter(VisualizationType.is_active == is_active)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                VisualizationType.type_name.ilike(search_term)",
        "import:fastapi.DashboardResponse",
        "import:fastapi.description=\"Dashboard ID\")",
        "import:fastapi.DashboardUpdateRequest",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/dashboards/{dashboard_id}\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List data visualizations with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(DataVisualization)\n    \n    # Apply filters\n    if visualization_type_id:\n        query = query.filter(DataVisualization.visualization_type_id == visualization_type_id)\n    \n    if data_source:\n        query = query.filter(DataVisualization.data_source == data_source)\n    \n    if is_public is not None:\n        query = query.filter(DataVisualization.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(DataVisualization.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(DataVisualization.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                DataVisualization.title.ilike(search_term)",
        "import:fastapi.display_name=viz_type.display_name",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new visualization type.\n    \n    This creates a new visualization type configuration for the system.\n    \"\"\"\n    # Check if type name already exists\n    existing_type = db.query(VisualizationType).filter(\n        VisualizationType.type_name == type_data.type_name\n    ).first()\n    \n    if existing_type:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.created_at=viz_type.created_at",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new data visualization.\n    \"\"\"\n    # Verify visualization type exists\n    viz_type = db.query(VisualizationType).filter(\n        VisualizationType.id == viz_data.visualization_type_id\n    ).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Filter by category\")",
        "import:fastapi.created_by=visualization.created_by",
        "import:fastapi.updated_at=visualization.updated_at\n        ))\n    \n    return DataVisualizationListResponse(\n        visualizations=viz_responses",
        "import:fastapi.config_hash=config_hash",
        "function:generate_visualization_data",
        "import:fastapi.DashboardListResponse",
        "import:fastapi.ge=1",
        "import:fastapi.view_count=dashboard.view_count",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def create_visualization_type(\n    type_data: VisualizationTypeCreateRequest = Body(...)",
        "import:fastapi.description=viz_type.description",
        "import:fastapi.request_data: VisualizationDataRequest = Body(...)",
        "import:fastapi.visualization_id)\n        \n        logger.info(f\"Visualization data generated: {visualization.title} - {generation_time:.2f}ms\")\n        \n        return {\n            \"visualization_id\": visualization_id",
        "import:fastapi.\"expires_at\": expires_at",
        "import:fastapi.VisualizationAnalytics\n)\nfrom app.models.users import User\nfrom app.schemas.data_visualizations import (\n    VisualizationTypeResponse",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def get_data_visualization(\n    visualization_id: str = Path(...",
        "import:fastapi.le=100",
        "import:fastapi.is_featured=visualization.is_featured",
        "import:fastapi.or_",
        "import:fastapi.description=\"Filter by featured status\")",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n# ============================================================================\n# DASHBOARD MANAGEMENT\n# ============================================================================\n\n@router.post(\"/dashboards\"",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.ThemeEnum\n)\nfrom app.api.v1.auth import get_current_user\nimport structlog\n\nlogger = structlog.get_logger(__name__)\nrouter = APIRouter()\n\n\n# ============================================================================\n# VISUALIZATION TYPE MANAGEMENT\n# ============================================================================\n\n@router.post(\"/types\"",
        "import:fastapi.\"cache_key\": cached_data.cache_key",
        "import:fastapi.\"generation_time_ms\": int(generation_time)\n        }\n        \n    except Exception as e:\n        # Log error\n        error_message = str(e)\n        logger.error(f\"Visualization generation failed: {visualization.title} - {error_message}\")\n        \n        raise HTTPException(\n            status_code=500",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific data visualization by ID.\n    \"\"\"\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by data source\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific dashboard by ID.\n    \"\"\"\n    dashboard = db.query(Dashboard).filter(Dashboard.id == dashboard_id).first()\n    \n    if not dashboard:\n        raise HTTPException(status_code=404",
        "import:fastapi.data_source=visualization.data_source",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List dashboards with filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Dashboard)\n    \n    # Apply filters\n    if theme:\n        query = query.filter(Dashboard.theme == theme)\n    \n    if is_public is not None:\n        query = query.filter(Dashboard.is_public == is_public)\n    \n    if is_featured is not None:\n        query = query.filter(Dashboard.is_featured == is_featured)\n    \n    if created_by:\n        query = query.filter(Dashboard.created_by == created_by)\n    \n    if search:\n        search_term = f\"%{search}%\"\n        query = query.filter(\n            or_(\n                Dashboard.title.ilike(search_term)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Generate data for a specific visualization.\n    \"\"\"\n    # Get visualization\n    visualization = db.query(DataVisualization).filter(\n        DataVisualization.id == visualization_id\n    ).first()\n    \n    if not visualization:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"data\": generated_data",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    # Create new visualization\n    visualization = DataVisualization(**viz_data.dict())\n    visualization.created_by = current_user.username\n    db.add(visualization)\n    db.commit()\n    db.refresh(visualization)\n    \n    logger.info(f\"Data visualization created: {current_user.username} - {viz_data.title}\")\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.view_count=visualization.view_count",
        "import:fastapi.HTTPException",
        "import:fastapi.DataVisualizationCreateRequest",
        "import:fastapi.is_public: Optional[bool] = Query(None",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.tags=dashboard.tags",
        "import:fastapi.updated_at=visualization.updated_at\n    )\n\n\n@router.get(\"/visualizations\"",
        "import:fastapi.response_model=DashboardResponse)\nasync def get_dashboard(\n    dashboard_id: str = Path(...",
        "import:fastapi.DataVisualization",
        "import:fastapi.VisualizationType.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get types\n    types = query.order_by(VisualizationType.type_name).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    type_responses = []\n    for viz_type in types:\n        type_responses.append(VisualizationTypeResponse(\n            id=str(viz_type.id)",
        "import:fastapi.tags=visualization.tags",
        "import:fastapi.Dashboard.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get dashboards\n    dashboards = query.order_by(desc(Dashboard.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    dashboard_responses = []\n    for dashboard in dashboards:\n        dashboard_responses.append(DashboardResponse(\n            id=str(dashboard.id)",
        "import:fastapi.created_by=dashboard.created_by",
        "import:fastapi.description=dashboard.description",
        "import:fastapi.visualization_type_id: Optional[str] = Query(None",
        "import:fastapi.cache_key=visualization.cache_key",
        "import:fastapi.response_model=DashboardResponse)\nasync def create_dashboard(\n    dashboard_data: DashboardCreateRequest = Body(...)",
        "import:fastapi.db: DBSession = Depends(get_db)",
        "import:fastapi.request_data.custom_filters\n        )\n        \n        generation_time = (datetime.utcnow() - start_time).total_seconds() * 1000\n        \n        # Cache the generated data\n        data_hash = hashlib.md5(json.dumps(generated_data",
        "import:fastapi.data_size=len(json.dumps(generated_data))",
        "import:fastapi.description=\"Filter by creator\")",
        "import:fastapi.description=\"Visualization ID\")",
        "import:fastapi.VisualizationDataRequest",
        "import:fastapi.visualization_id)\n            \n            return {\n                \"visualization_id\": visualization_id",
        "import:fastapi.visualization",
        "import:fastapi.expires_at=expires_at",
        "import:fastapi.Depends",
        "import:fastapi.is_featured=dashboard.is_featured",
        "import:fastapi.response_model=VisualizationTypeResponse)\nasync def get_visualization_type(\n    type_id: str = Path(...",
        "import:fastapi.Path",
        "import:fastapi.DashboardCreateRequest",
        "import:fastapi.title=dashboard.title",
        "import:fastapi.response_model=VisualizationTypeListResponse)\nasync def list_visualization_types(\n    page: int = Query(1",
        "import:fastapi.generated_data=generated_data",
        "import:fastapi.page=page",
        "import:fastapi.detail=\"Visualization type not found\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.\"generation_time_ms\": cached_data.generation_time_ms\n            }\n    \n    # Generate new data\n    start_time = datetime.utcnow()\n    \n    try:\n        # Generate visualization data based on type and source\n        generated_data = await _generate_visualization_data(\n            db",
        "import:fastapi.VisualizationCache",
        "import:fastapi.response_model=DataVisualizationResponse)\nasync def create_data_visualization(\n    viz_data: DataVisualizationCreateRequest = Body(...)",
        "import:fastapi.is_public=visualization.is_public",
        "import:fastapi.title=visualization.title",
        "import:fastapi.updated_at=viz_type.updated_at\n        ))\n    \n    return VisualizationTypeListResponse(\n        types=type_responses",
        "import:fastapi.VisualizationTypeListResponse",
        "import:fastapi.description=\"Search in type names and descriptions\")",
        "import:fastapi.response_model=DataVisualizationListResponse)\nasync def list_data_visualizations(\n    page: int = Query(1",
        "import:fastapi.func\nfrom typing import Optional",
        "import:fastapi.DataVisualizationUpdateRequest",
        "import:fastapi.updated_at=dashboard.updated_at\n        ))\n    \n    return DashboardListResponse(\n        dashboards=dashboard_responses",
        "import:fastapi.\"cache_key\": cache_key",
        "import:fastapi.\"is_cached\": False",
        "import:fastapi.DashboardVisualization",
        "import:fastapi.type_name=viz_type.type_name",
        "import:fastapi.refresh_interval=dashboard.refresh_interval",
        "import:fastapi.generation_time_ms=visualization.generation_time_ms",
        "import:fastapi.created_by: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific visualization type by ID.\n    \"\"\"\n    viz_type = db.query(VisualizationType).filter(VisualizationType.id == type_id).first()\n    \n    if not viz_type:\n        raise HTTPException(status_code=404",
        "import:fastapi.DashboardVisualizationUpdateRequest",
        "import:fastapi.created_at=dashboard.created_at",
        "import:fastapi.data_source: Optional[DataSourceEnum] = Query(None",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.last_accessed=dashboard.last_accessed",
        "import:fastapi.detail=f\"Failed to generate visualization data: {error_message}\"\n        )\n\n\n# ============================================================================\n# DASHBOARD VISUALIZATION MANAGEMENT\n# ============================================================================",
        "import:fastapi.updated_at=dashboard.updated_at\n    )\n\n\n@router.get(\"/dashboards\"",
        "import:fastapi.timedelta\nimport math\nimport hashlib\nimport json\n\nfrom app.database import get_db\nfrom app.models.data_visualizations import (\n    VisualizationType",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n# ============================================================================\n# DATA VISUALIZATION MANAGEMENT\n# ============================================================================\n\n@router.post(\"/visualizations\"",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.default_options=viz_type.default_options",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/visualizations/{visualization_id}\"",
        "import:fastapi.description=\"Filter by public status\")",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_",
        "import:fastapi.\"is_cached\": True",
        "import:fastapi.\"data\": cached_data.generated_data",
        "import:fastapi.description=\"Visualization type ID\")",
        "import:fastapi.detail=\"Visualization not found\")\n    \n    # Check cache first\n    if not request_data.force_regenerate:\n        cached_data = db.query(VisualizationCache).filter(\n            and_(\n                VisualizationCache.visualization_id == visualization_id",
        "import:fastapi.detail=f\"Visualization type with name '{type_data.type_name}' already exists\"\n        )\n    \n    # Create new visualization type\n    viz_type = VisualizationType(**type_data.dict())\n    db.add(viz_type)\n    db.commit()\n    db.refresh(viz_type)\n    \n    logger.info(f\"Visualization type created: {current_user.username} - {type_data.type_name}\")\n    \n    return VisualizationTypeResponse(\n        id=str(viz_type.id)",
        "import:fastapi.DashboardVisualizationResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.usedforsecurity=False).hexdigest()\n        cache_key = f\"viz_{visualization_id}_{data_hash}_{config_hash}\"\n        expires_at = datetime.utcnow() + timedelta(hours=1)  # Cache for 1 hour\n        \n        # Remove old cache entries\n        db.query(VisualizationCache).filter(\n            VisualizationCache.visualization_id == visualization_id\n        ).delete()\n        \n        # Create new cache entry\n        cache_entry = VisualizationCache(\n            visualization_id=visualization_id",
        "import:fastapi.configuration_schema=viz_type.configuration_schema",
        "import:fastapi.VisualizationTypeCreateRequest",
        "import:fastapi.theme=dashboard.theme",
        "import:fastapi.theme: Optional[ThemeEnum] = Query(None",
        "import:fastapi.data_query=visualization.data_query",
        "import:fastapi.hits=1",
        "import:fastapi.has_prev=page > 1\n    )\n\n\n@router.get(\"/types/{type_id}\"",
        "import:fastapi.detail=\"Dashboard not found\")\n    \n    # Update last accessed and view count\n    dashboard.last_accessed = datetime.utcnow()\n    dashboard.view_count += 1\n    db.commit()\n    \n    return DashboardResponse(\n        id=str(dashboard.id)",
        "import:fastapi.updated_at=dashboard.updated_at\n    )\n\n\n# ============================================================================\n# VISUALIZATION DATA GENERATION\n# ============================================================================\n\n@router.post(\"/visualizations/{visualization_id}/generate\")\nasync def generate_visualization_data(\n    visualization_id: str = Path(...",
        "import:fastapi.is_featured: Optional[bool] = Query(None",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.detail=\"Data visualization not found\")\n    \n    # Increment view count\n    visualization.view_count += 1\n    db.commit()\n    \n    return DataVisualizationResponse(\n        id=str(visualization.id)",
        "import:fastapi.sort_keys=True).encode()",
        "import:fastapi.DataSourceEnum",
        "import:fastapi.is_active=viz_type.is_active",
        "import:fastapi.updated_at=viz_type.updated_at\n    )\n\n\n@router.get(\"/types\"",
        "import:fastapi.cache_key=cache_key",
        "import:fastapi.DataVisualizationListResponse",
        "import:fastapi.VisualizationTypeUpdateRequest",
        "import:fastapi.DashboardVisualizationCreateRequest",
        "import:fastapi.VisualizationType.display_name.ilike(search_term)",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Search in titles and descriptions\")",
        "import:fastapi.data_hash=data_hash",
        "import:fastapi.description=\"Filter by theme\")",
        "import:fastapi.response_model=DashboardListResponse)\nasync def list_dashboards(\n    page: int = Query(1",
        "import:fastapi.category=viz_type.category",
        "import:fastapi.configuration=visualization.configuration",
        "import:fastapi.description=\"Filter by visualization type ID\")",
        "import:fastapi.current_user: User = Depends(get_current_user)\n):\n    \"\"\"\n    Create a new dashboard.\n    \"\"\"\n    # Create new dashboard\n    dashboard = Dashboard(**dashboard_data.dict())\n    dashboard.created_by = current_user.username\n    db.add(dashboard)\n    db.commit()\n    db.refresh(dashboard)\n    \n    logger.info(f\"Dashboard created: {current_user.username} - {dashboard_data.title}\")\n    \n    return DashboardResponse(\n        id=str(dashboard.id)",
        "import:fastapi.DataVisualizationResponse",
        "import:fastapi.description=\"Filter by active status\")",
        "import:fastapi.last_hit=datetime.utcnow()\n        )\n        db.add(cache_entry)\n        \n        # Update visualization metadata\n        visualization.last_generated = datetime.utcnow()\n        visualization.generation_time_ms = int(generation_time)\n        visualization.cache_key = cache_key\n        visualization.cache_expires = expires_at\n        \n        db.commit()\n        \n        # Track analytics\n        _track_visualization_access(db",
        "import:fastapi.visualization_type_id=str(visualization.visualization_type_id)",
        "import:fastapi.description=visualization.description",
        "import:fastapi.Dashboard",
        "import:fastapi.VisualizationCache.expires_at > datetime.utcnow()\n            )\n        ).first()\n        \n        if cached_data:\n            # Update cache hits\n            cached_data.hits += 1\n            cached_data.last_hit = datetime.utcnow()\n            db.commit()\n            \n            # Track analytics\n            _track_visualization_access(db",
        "import:fastapi.generation_time_ms=int(generation_time)",
        "import:fastapi.supported_data_types=viz_type.supported_data_types",
        "import:fastapi.cache_expires=visualization.cache_expires",
        "import:fastapi.VisualizationStatistics",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.DataVisualization.description.ilike(search_term)\n            )\n        )\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get visualizations\n    visualizations = query.order_by(desc(DataVisualization.created_at)).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    viz_responses = []\n    for visualization in visualizations:\n        viz_responses.append(DataVisualizationResponse(\n            id=str(visualization.id)"
      ]
    },
    "POST:/create": {
      "method": "POST",
      "path": "/create",
      "file": "services/api-gateway/app/api/v1/issues.py",
      "line": 18,
      "dependencies": [
        "import:fastapi.Riding\n\nrouter = APIRouter()",
        "import:fastapi.Party",
        "import:fastapi.Any",
        "import:fastapi.Body",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Dict",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.VoteQuestion",
        "import:fastapi.APIRouter",
        "import:fastapi.Politician",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/user-issues": {
      "method": "GET",
      "path": "/user-issues",
      "file": "services/api-gateway/app/api/v1/issues.py",
      "line": 82,
      "dependencies": [
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new user issue.\n    Users can report issues that need government attention.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.description=\"Issue data\")",
        "import:fastapi.\"summary\": issue_data[\"summary\"]",
        "import:fastapi.detail=\"Issue description must be at least 20 characters\")\n    \n    # For now",
        "import:fastapi.\"issue\": issue_record",
        "import:fastapi.\"medium\")",
        "import:fastapi.create mock issue response\n    # In a full implementation",
        "import:fastapi.this would save to the database\n    issue_record = {\n        \"id\": f\"issue-{datetime.utcnow().timestamp()}\"",
        "import:fastapi.\"contact_email\": issue_data.get(\"contact_email\")",
        "import:fastapi.\"created_at\": datetime.utcnow().isoformat()",
        "import:fastapi.\"unknown\")",
        "import:fastapi.\"constituency\": issue_data.get(\"constituency\")",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.detail=\"Issue name must be at least 3 characters\")\n    \n    if len(issue_data[\"summary\"]) < 10:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"user_id\": issue_data.get(\"user_id\"",
        "import:fastapi.\"user_agent\": issue_data.get(\"user_agent\"",
        "import:fastapi.\"An admin will review and approve your issue\"",
        "import:fastapi.\"status\": \"pending_approval\"",
        "import:fastapi.\"You will receive updates on the approval status\"",
        "import:fastapi.\"summary\"",
        "import:fastapi.detail=\"Issue summary must be at least 10 characters\")\n    \n    if len(issue_data[\"description\"]) < 20:\n        raise HTTPException(status_code=400",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.\"message\": \"Issue created successfully and is pending admin approval\"",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"Approved issues will be visible to the community\"\n        ]\n    }",
        "import:fastapi.Politician",
        "import:fastapi.\"updated_at\": datetime.utcnow().isoformat()",
        "import:fastapi.\"ip_address\": issue_data.get(\"ip_address\")",
        "import:fastapi.Any",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate field lengths\n    if len(issue_data[\"name\"]) < 3:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": issue_data[\"name\"]",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"postal_code\": issue_data.get(\"postal_code\")",
        "import:fastapi.\"category\": issue_data.get(\"category\"",
        "import:fastapi.\"priority\": issue_data.get(\"priority\"",
        "import:fastapi.\"location\": issue_data.get(\"location\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Party",
        "import:fastapi.\"metadata\": {\n            \"source\": \"web\"",
        "function:create_issue",
        "import:fastapi.[])",
        "import:fastapi.\"demo-user\")",
        "import:fastapi.\"tags\": issue_data.get(\"tags\"",
        "import:fastapi.Body",
        "import:fastapi.\"general\")",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"next_steps\": [\n            \"Your issue has been submitted for review\"",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"attachments\": issue_data.get(\"attachments\""
      ]
    },
    "GET:/{issue_id}": {
      "method": "GET",
      "path": "/{issue_id}",
      "file": "services/api-gateway/app/api/v1/issues.py",
      "line": 118,
      "dependencies": [
        "import:fastapi.description=\"Issue data\")",
        "import:fastapi.\"rejected\": 1",
        "import:fastapi.category",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issues created by a specific user.\n    Provides paginated list of user's issues with filtering options.\n    \"\"\"\n    # For now",
        "import:fastapi.\"You will receive updates on the approval status\"",
        "import:fastapi.detail=\"Issue summary must be at least 10 characters\")\n    \n    if len(issue_data[\"description\"]) < 20:\n        raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.Politician",
        "import:fastapi.ge=1",
        "import:fastapi.create mock user issues\n    # In a full implementation",
        "import:fastapi.le=100",
        "import:fastapi.\"location\": issue_data.get(\"location\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"metadata\": {\n            \"source\": \"web\"",
        "import:fastapi.[])",
        "import:fastapi.this would query the database\n    mock_issues = generate_mock_user_issues(user_id",
        "import:fastapi.HTTPException",
        "import:fastapi.\"attachments\": issue_data.get(\"attachments\"",
        "import:fastapi.\"approved\": 5",
        "import:fastapi.\"issue\": issue_record",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"An admin will review and approve your issue\"",
        "import:fastapi.\"status\": \"pending_approval\"",
        "import:fastapi.\"pagination\": mock_issues[\"pagination\"]",
        "import:fastapi.page",
        "import:fastapi.\"updated_at\": datetime.utcnow().isoformat()",
        "import:fastapi.description=\"Filter by issue status\")",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"postal_code\": issue_data.get(\"postal_code\")",
        "import:fastapi.\"filters\": {\n            \"status\": status",
        "import:fastapi.Party",
        "import:fastapi.status",
        "import:fastapi.\"next_steps\": [\n            \"Your issue has been submitted for review\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new user issue.\n    Users can report issues that need government attention.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"summary\": issue_data[\"summary\"]",
        "import:fastapi.\"user_issues\": mock_issues[\"issues\"]",
        "import:fastapi.create mock issue response\n    # In a full implementation",
        "import:fastapi.\"contact_email\": issue_data.get(\"contact_email\")",
        "import:fastapi.\"created_at\": datetime.utcnow().isoformat()",
        "import:fastapi.\"unknown\")",
        "import:fastapi.\"constituency\": issue_data.get(\"constituency\")",
        "import:fastapi.detail=\"Issue name must be at least 3 characters\")\n    \n    if len(issue_data[\"summary\"]) < 10:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"user_id\": issue_data.get(\"user_id\"",
        "import:fastapi.\"user_agent\": issue_data.get(\"user_agent\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"summary\": {\n            \"total_issues\": mock_issues[\"pagination\"][\"total\"]",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.\"ip_address\": issue_data.get(\"ip_address\")",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Any",
        "import:fastapi.\"demo-user\")",
        "import:fastapi.\"general\")",
        "import:fastapi.\"Approved issues will be visible to the community\"\n        ]\n    }\n\n\n@router.get(\"/user-issues\")\nasync def get_user_issues(\n    user_id: str",
        "function:get_user_issues",
        "import:fastapi.page_size)\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.detail=\"Issue description must be at least 20 characters\")\n    \n    # For now",
        "import:fastapi.\"medium\")",
        "import:fastapi.this would save to the database\n    issue_record = {\n        \"id\": f\"issue-{datetime.utcnow().timestamp()}\"",
        "import:fastapi.\"pending_approval\": 3",
        "import:fastapi.\"summary\"",
        "import:fastapi.\"message\": \"Issue created successfully and is pending admin approval\"",
        "import:fastapi.\"resolved\": 2\n        }\n    }",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate field lengths\n    if len(issue_data[\"name\"]) < 3:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": issue_data[\"name\"]",
        "import:fastapi.description=\"Filter by issue category\")",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"category\": issue_data.get(\"category\"",
        "import:fastapi.\"priority\": issue_data.get(\"priority\"",
        "import:fastapi.\"tags\": issue_data.get(\"tags\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.\"category\": category\n        }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.ElectedMember"
      ]
    },
    "PUT:/{issue_id}/update": {
      "method": "PUT",
      "path": "/{issue_id}/update",
      "file": "services/api-gateway/app/api/v1/issues.py",
      "line": 140,
      "dependencies": [
        "import:fastapi.description=\"Issue data\")",
        "import:fastapi.\"rejected\": 1",
        "import:fastapi.category",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issues created by a specific user.\n    Provides paginated list of user's issues with filtering options.\n    \"\"\"\n    # For now",
        "import:fastapi.\"You will receive updates on the approval status\"",
        "import:fastapi.detail=\"Issue summary must be at least 10 characters\")\n    \n    if len(issue_data[\"description\"]) < 20:\n        raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.Politician",
        "import:fastapi.ge=1",
        "import:fastapi.create mock user issues\n    # In a full implementation",
        "import:fastapi.le=100",
        "import:fastapi.\"location\": issue_data.get(\"location\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"metadata\": {\n            \"source\": \"web\"",
        "import:fastapi.[])",
        "import:fastapi.this would query the database\n    mock_issues = generate_mock_user_issues(user_id",
        "import:fastapi.HTTPException",
        "import:fastapi.\"attachments\": issue_data.get(\"attachments\"",
        "import:fastapi.\"approved\": 5",
        "import:fastapi.\"issue\": issue_record",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"An admin will review and approve your issue\"",
        "import:fastapi.\"status\": \"pending_approval\"",
        "import:fastapi.\"pagination\": mock_issues[\"pagination\"]",
        "import:fastapi.page",
        "import:fastapi.\"updated_at\": datetime.utcnow().isoformat()",
        "import:fastapi.description=\"Filter by issue status\")",
        "import:fastapi.\"resolved\": 2\n        }\n    }\n\n\n@router.get(\"/{issue_id}\")\nasync def get_issue_detail(\n    issue_id: str",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"postal_code\": issue_data.get(\"postal_code\")",
        "import:fastapi.\"filters\": {\n            \"status\": status",
        "import:fastapi.this would query the database\n    issue_detail = generate_mock_issue_detail(issue_id)\n    \n    if not issue_detail:\n        raise HTTPException(status_code=404",
        "import:fastapi.Party",
        "import:fastapi.status",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific issue.\n    Provides complete issue details and status information.\n    \"\"\"\n    # For now",
        "import:fastapi.\"next_steps\": [\n            \"Your issue has been submitted for review\"",
        "import:fastapi.create mock issue detail\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new user issue.\n    Users can report issues that need government attention.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"summary\": issue_data[\"summary\"]",
        "import:fastapi.\"user_issues\": mock_issues[\"issues\"]",
        "import:fastapi.create mock issue response\n    # In a full implementation",
        "import:fastapi.detail=\"Issue not found\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"contact_email\": issue_data.get(\"contact_email\")",
        "import:fastapi.\"created_at\": datetime.utcnow().isoformat()",
        "import:fastapi.\"unknown\")",
        "import:fastapi.\"constituency\": issue_data.get(\"constituency\")",
        "import:fastapi.detail=\"Issue name must be at least 3 characters\")\n    \n    if len(issue_data[\"summary\"]) < 10:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"user_id\": issue_data.get(\"user_id\"",
        "import:fastapi.\"user_agent\": issue_data.get(\"user_agent\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"summary\": {\n            \"total_issues\": mock_issues[\"pagination\"][\"total\"]",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.\"ip_address\": issue_data.get(\"ip_address\")",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Any",
        "import:fastapi.\"demo-user\")",
        "import:fastapi.\"general\")",
        "import:fastapi.\"Approved issues will be visible to the community\"\n        ]\n    }\n\n\n@router.get(\"/user-issues\")\nasync def get_user_issues(\n    user_id: str",
        "import:fastapi.page_size)\n    \n    return {\n        \"success\": True",
        "function:get_issue_detail",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.detail=\"Issue description must be at least 20 characters\")\n    \n    # For now",
        "import:fastapi.\"medium\")",
        "import:fastapi.this would save to the database\n    issue_record = {\n        \"id\": f\"issue-{datetime.utcnow().timestamp()}\"",
        "import:fastapi.\"pending_approval\": 3",
        "import:fastapi.\"summary\"",
        "import:fastapi.\"message\": \"Issue created successfully and is pending admin approval\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate field lengths\n    if len(issue_data[\"name\"]) < 3:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": issue_data[\"name\"]",
        "import:fastapi.description=\"Filter by issue category\")",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"category\": issue_data.get(\"category\"",
        "import:fastapi.\"priority\": issue_data.get(\"priority\"",
        "import:fastapi.\"issue\": issue_detail\n    }",
        "import:fastapi.\"tags\": issue_data.get(\"tags\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.\"category\": category\n        }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.ElectedMember"
      ]
    },
    "DELETE:/{issue_id}": {
      "method": "DELETE",
      "path": "/{issue_id}",
      "file": "services/api-gateway/app/api/v1/issues.py",
      "line": 187,
      "dependencies": [
        "import:fastapi.description=\"Issue data\")",
        "import:fastapi.\"rejected\": 1",
        "import:fastapi.\"priority\": update_data.get(\"priority\"",
        "import:fastapi.category",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issues created by a specific user.\n    Provides paginated list of user's issues with filtering options.\n    \"\"\"\n    # For now",
        "import:fastapi.\"category\"",
        "import:fastapi.\"category\": update_data.get(\"category\"",
        "import:fastapi.\"You will receive updates on the approval status\"",
        "import:fastapi.detail=\"Issue summary must be at least 10 characters\")\n    \n    if len(issue_data[\"description\"]) < 20:\n        raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.Politician",
        "import:fastapi.\"name\": update_data.get(\"name\"",
        "import:fastapi.ge=1",
        "import:fastapi.create mock user issues\n    # In a full implementation",
        "import:fastapi.le=100",
        "import:fastapi.\"location\": issue_data.get(\"location\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"metadata\": {\n            \"source\": \"web\"",
        "import:fastapi.[])",
        "import:fastapi.this would query the database\n    mock_issues = generate_mock_user_issues(user_id",
        "import:fastapi.\"Updated issue description\")",
        "import:fastapi.HTTPException",
        "import:fastapi.\"attachments\": issue_data.get(\"attachments\"",
        "import:fastapi.\"approved\": 5",
        "import:fastapi.\"issue\": issue_record",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"An admin will review and approve your issue\"",
        "import:fastapi.\"status\": \"pending_approval\"",
        "import:fastapi.\"pagination\": mock_issues[\"pagination\"]",
        "import:fastapi.page",
        "import:fastapi.\"updated_at\": datetime.utcnow().isoformat()",
        "import:fastapi.description=\"Filter by issue status\")",
        "import:fastapi.create mock update response\n    # In a full implementation",
        "import:fastapi.\"resolved\": 2\n        }\n    }\n\n\n@router.get(\"/{issue_id}\")\nasync def get_issue_detail(\n    issue_id: str",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"postal_code\": issue_data.get(\"postal_code\")",
        "import:fastapi.\"filters\": {\n            \"status\": status",
        "import:fastapi.\"changes\": list(update_data.keys())\n            }\n        ]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.this would query the database\n    issue_detail = generate_mock_issue_detail(issue_id)\n    \n    if not issue_detail:\n        raise HTTPException(status_code=404",
        "import:fastapi.Party",
        "import:fastapi.status",
        "import:fastapi.detail=f\"Invalid fields for update: {'",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific issue.\n    Provides complete issue details and status information.\n    \"\"\"\n    # For now",
        "import:fastapi.this would update the database\n    updated_issue = {\n        \"id\": issue_id",
        "import:fastapi.\"description\": update_data.get(\"description\"",
        "import:fastapi.\"Updated Issue Name\")",
        "import:fastapi.\"next_steps\": [\n            \"Your issue has been submitted for review\"",
        "import:fastapi.create mock issue detail\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new user issue.\n    Users can report issues that need government attention.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"summary\": issue_data[\"summary\"]",
        "import:fastapi.\"issue\": issue_detail\n    }\n\n\n@router.put(\"/{issue_id}/update\")\nasync def update_issue(\n    issue_id: str",
        "import:fastapi.\"user_issues\": mock_issues[\"issues\"]",
        "import:fastapi.create mock issue response\n    # In a full implementation",
        "import:fastapi.detail=\"Issue not found\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"issue\": updated_issue\n    }",
        "import:fastapi.\"contact_email\": issue_data.get(\"contact_email\")",
        "import:fastapi.\"created_at\": datetime.utcnow().isoformat()",
        "import:fastapi.\"unknown\")",
        "import:fastapi.\"constituency\": issue_data.get(\"constituency\")",
        "import:fastapi.detail=\"Issue name must be at least 3 characters\")\n    \n    if len(issue_data[\"summary\"]) < 10:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"user_id\": issue_data.get(\"user_id\"",
        "import:fastapi.\"user_agent\": issue_data.get(\"user_agent\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'.join(invalid_fields)}\"\n        )\n    \n    # For now",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"summary\": {\n            \"total_issues\": mock_issues[\"pagination\"][\"total\"]",
        "import:fastapi.\"Updated issue summary\")",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update an existing issue.\n    Users can modify their issues before approval.\n    \"\"\"\n    # Validate updateable fields\n    allowed_fields = [\"name\"",
        "import:fastapi.\"tags\"]\n    invalid_fields = [field for field in update_data.keys() if field not in allowed_fields]\n    \n    if invalid_fields:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.\"ip_address\": issue_data.get(\"ip_address\")",
        "import:fastapi.update_data: Dict[str",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Any",
        "import:fastapi.\"summary\": update_data.get(\"summary\"",
        "import:fastapi.\"demo-user\")",
        "import:fastapi.\"general\")",
        "import:fastapi.\"Approved issues will be visible to the community\"\n        ]\n    }\n\n\n@router.get(\"/user-issues\")\nasync def get_user_issues(\n    user_id: str",
        "import:fastapi.description=\"Update data\")",
        "import:fastapi.page_size)\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.detail=\"Issue description must be at least 20 characters\")\n    \n    # For now",
        "import:fastapi.\"medium\")",
        "import:fastapi.this would save to the database\n    issue_record = {\n        \"id\": f\"issue-{datetime.utcnow().timestamp()}\"",
        "import:fastapi.\"message\": \"Issue updated successfully\"",
        "import:fastapi.\"pending_approval\": 3",
        "import:fastapi.\"update_history\": [\n            {\n                \"timestamp\": datetime.utcnow().isoformat()",
        "import:fastapi.\"summary\"",
        "import:fastapi.\"message\": \"Issue created successfully and is pending admin approval\"",
        "import:fastapi.\"action\": \"user_update\"",
        "import:fastapi.\"priority\"",
        "function:update_issue",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate field lengths\n    if len(issue_data[\"name\"]) < 3:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": issue_data[\"name\"]",
        "import:fastapi.\"description\"",
        "import:fastapi.description=\"Filter by issue category\")",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"category\": issue_data.get(\"category\"",
        "import:fastapi.\"priority\": issue_data.get(\"priority\"",
        "import:fastapi.\"tags\": issue_data.get(\"tags\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.\"category\": category\n        }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/community/issues": {
      "method": "GET",
      "path": "/community/issues",
      "file": "services/api-gateway/app/api/v1/issues.py",
      "line": 207,
      "dependencies": [
        "import:fastapi.description=\"Issue data\")",
        "import:fastapi.\"rejected\": 1",
        "import:fastapi.\"priority\": update_data.get(\"priority\"",
        "import:fastapi.category",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issues created by a specific user.\n    Provides paginated list of user's issues with filtering options.\n    \"\"\"\n    # For now",
        "import:fastapi.\"category\"",
        "import:fastapi.\"category\": update_data.get(\"category\"",
        "import:fastapi.\"You will receive updates on the approval status\"",
        "import:fastapi.detail=\"Issue summary must be at least 10 characters\")\n    \n    if len(issue_data[\"description\"]) < 20:\n        raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.user_id: str = Query(...",
        "import:fastapi.Politician",
        "import:fastapi.\"name\": update_data.get(\"name\"",
        "import:fastapi.ge=1",
        "import:fastapi.create mock user issues\n    # In a full implementation",
        "import:fastapi.le=100",
        "import:fastapi.\"location\": issue_data.get(\"location\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"metadata\": {\n            \"source\": \"web\"",
        "import:fastapi.[])",
        "import:fastapi.this would query the database\n    mock_issues = generate_mock_user_issues(user_id",
        "import:fastapi.\"Updated issue description\")",
        "import:fastapi.\"deleted_issue_id\": issue_id",
        "import:fastapi.HTTPException",
        "import:fastapi.\"attachments\": issue_data.get(\"attachments\"",
        "import:fastapi.\"approved\": 5",
        "import:fastapi.\"issue\": issue_record",
        "function:delete_issue",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"An admin will review and approve your issue\"",
        "import:fastapi.\"status\": \"pending_approval\"",
        "import:fastapi.\"pagination\": mock_issues[\"pagination\"]",
        "import:fastapi.page",
        "import:fastapi.\"updated_at\": datetime.utcnow().isoformat()",
        "import:fastapi.description=\"Filter by issue status\")",
        "import:fastapi.create mock update response\n    # In a full implementation",
        "import:fastapi.\"resolved\": 2\n        }\n    }\n\n\n@router.get(\"/{issue_id}\")\nasync def get_issue_detail(\n    issue_id: str",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"postal_code\": issue_data.get(\"postal_code\")",
        "import:fastapi.\"filters\": {\n            \"status\": status",
        "import:fastapi.\"changes\": list(update_data.keys())\n            }\n        ]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.this would query the database\n    issue_detail = generate_mock_issue_detail(issue_id)\n    \n    if not issue_detail:\n        raise HTTPException(status_code=404",
        "import:fastapi.Party",
        "import:fastapi.status",
        "import:fastapi.\"deleted_at\": datetime.utcnow().isoformat()\n    }",
        "import:fastapi.detail=f\"Invalid fields for update: {'",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific issue.\n    Provides complete issue details and status information.\n    \"\"\"\n    # For now",
        "import:fastapi.this would update the database\n    updated_issue = {\n        \"id\": issue_id",
        "import:fastapi.\"description\": update_data.get(\"description\"",
        "import:fastapi.\"Updated Issue Name\")",
        "import:fastapi.\"next_steps\": [\n            \"Your issue has been submitted for review\"",
        "import:fastapi.create mock issue detail\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new user issue.\n    Users can report issues that need government attention.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"summary\": issue_data[\"summary\"]",
        "import:fastapi.\"issue\": issue_detail\n    }\n\n\n@router.put(\"/{issue_id}/update\")\nasync def update_issue(\n    issue_id: str",
        "import:fastapi.\"user_issues\": mock_issues[\"issues\"]",
        "import:fastapi.create mock issue response\n    # In a full implementation",
        "import:fastapi.detail=\"Issue not found\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"contact_email\": issue_data.get(\"contact_email\")",
        "import:fastapi.\"created_at\": datetime.utcnow().isoformat()",
        "import:fastapi.\"unknown\")",
        "import:fastapi.\"constituency\": issue_data.get(\"constituency\")",
        "import:fastapi.detail=\"Issue name must be at least 3 characters\")\n    \n    if len(issue_data[\"summary\"]) < 10:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"user_id\": issue_data.get(\"user_id\"",
        "import:fastapi.\"user_agent\": issue_data.get(\"user_agent\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'.join(invalid_fields)}\"\n        )\n    \n    # For now",
        "import:fastapi.this would delete from the database\n    return {\n        \"success\": True",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"summary\": {\n            \"total_issues\": mock_issues[\"pagination\"][\"total\"]",
        "import:fastapi.\"Updated issue summary\")",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update an existing issue.\n    Users can modify their issues before approval.\n    \"\"\"\n    # Validate updateable fields\n    allowed_fields = [\"name\"",
        "import:fastapi.\"tags\"]\n    invalid_fields = [field for field in update_data.keys() if field not in allowed_fields]\n    \n    if invalid_fields:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.\"ip_address\": issue_data.get(\"ip_address\")",
        "import:fastapi.update_data: Dict[str",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Any",
        "import:fastapi.\"summary\": update_data.get(\"summary\"",
        "import:fastapi.\"demo-user\")",
        "import:fastapi.\"general\")",
        "import:fastapi.\"Approved issues will be visible to the community\"\n        ]\n    }\n\n\n@router.get(\"/user-issues\")\nasync def get_user_issues(\n    user_id: str",
        "import:fastapi.description=\"Update data\")",
        "import:fastapi.page_size)\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.detail=\"Issue description must be at least 20 characters\")\n    \n    # For now",
        "import:fastapi.\"medium\")",
        "import:fastapi.this would save to the database\n    issue_record = {\n        \"id\": f\"issue-{datetime.utcnow().timestamp()}\"",
        "import:fastapi.\"message\": \"Issue updated successfully\"",
        "import:fastapi.\"issue\": updated_issue\n    }\n\n\n@router.delete(\"/{issue_id}\")\nasync def delete_issue(\n    issue_id: str",
        "import:fastapi.\"pending_approval\": 3",
        "import:fastapi.\"update_history\": [\n            {\n                \"timestamp\": datetime.utcnow().isoformat()",
        "import:fastapi.\"summary\"",
        "import:fastapi.\"message\": \"Issue created successfully and is pending admin approval\"",
        "import:fastapi.description=\"User ID for verification\")",
        "import:fastapi.\"message\": \"Issue deleted successfully\"",
        "import:fastapi.\"action\": \"user_update\"",
        "import:fastapi.\"priority\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate field lengths\n    if len(issue_data[\"name\"]) < 3:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": issue_data[\"name\"]",
        "import:fastapi.\"description\"",
        "import:fastapi.create mock delete response\n    # In a full implementation",
        "import:fastapi.description=\"Filter by issue category\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete an issue.\n    Users can delete their issues if they haven't been approved yet.\n    \"\"\"\n    # For now",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"category\": issue_data.get(\"category\"",
        "import:fastapi.\"priority\": issue_data.get(\"priority\"",
        "import:fastapi.\"tags\": issue_data.get(\"tags\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.\"category\": category\n        }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.ElectedMember"
      ]
    },
    "POST:/{issue_id}/support": {
      "method": "POST",
      "path": "/{issue_id}/support",
      "file": "services/api-gateway/app/api/v1/issues.py",
      "line": 253,
      "dependencies": [
        "import:fastapi.description=\"Issue data\")",
        "import:fastapi.\"rejected\": 1",
        "import:fastapi.\"priority\": update_data.get(\"priority\"",
        "import:fastapi.constituency: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by constituency\")",
        "import:fastapi.category",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issues created by a specific user.\n    Provides paginated list of user's issues with filtering options.\n    \"\"\"\n    # For now",
        "import:fastapi.\"category\"",
        "import:fastapi.\"economic\": 23",
        "import:fastapi.\"category\": update_data.get(\"category\"",
        "import:fastapi.\"You will receive updates on the approval status\"",
        "import:fastapi.detail=\"Issue summary must be at least 10 characters\")\n    \n    if len(issue_data[\"description\"]) < 20:\n        raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.user_id: str = Query(...",
        "import:fastapi.\"category\": category",
        "import:fastapi.Politician",
        "import:fastapi.\"name\": update_data.get(\"name\"",
        "import:fastapi.\"low\": 18\n            }\n        }\n    }",
        "import:fastapi.ge=1",
        "import:fastapi.create mock user issues\n    # In a full implementation",
        "import:fastapi.le=100",
        "import:fastapi.\"infrastructure\": 12",
        "import:fastapi.this would query the database\n    community_issues = generate_mock_community_issues(status",
        "import:fastapi.\"location\": issue_data.get(\"location\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"metadata\": {\n            \"source\": \"web\"",
        "import:fastapi.[])",
        "import:fastapi.this would query the database\n    mock_issues = generate_mock_user_issues(user_id",
        "import:fastapi.\"Updated issue description\")",
        "import:fastapi.\"deleted_issue_id\": issue_id",
        "import:fastapi.HTTPException",
        "import:fastapi.\"attachments\": issue_data.get(\"attachments\"",
        "function:get_community_issues",
        "import:fastapi.create mock community issues\n    # In a full implementation",
        "import:fastapi.\"approved\": 5",
        "import:fastapi.priority: Optional[str] = Query(None",
        "import:fastapi.\"issue\": issue_record",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by priority\")",
        "import:fastapi.\"deleted_at\": datetime.utcnow().isoformat()\n    }\n\n\n@router.get(\"/community/issues\")\nasync def get_community_issues(\n    status: Optional[str] = Query(None",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"An admin will review and approve your issue\"",
        "import:fastapi.\"status\": \"pending_approval\"",
        "import:fastapi.\"priority\": priority\n        }",
        "import:fastapi.\"pagination\": mock_issues[\"pagination\"]",
        "import:fastapi.page",
        "import:fastapi.\"updated_at\": datetime.utcnow().isoformat()",
        "import:fastapi.description=\"Filter by issue status\")",
        "import:fastapi.create mock update response\n    # In a full implementation",
        "import:fastapi.\"resolved\": 2\n        }\n    }\n\n\n@router.get(\"/{issue_id}\")\nasync def get_issue_detail(\n    issue_id: str",
        "import:fastapi.\"by_priority\": {\n                \"high\": 25",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"postal_code\": issue_data.get(\"postal_code\")",
        "import:fastapi.\"filters\": {\n            \"status\": status",
        "import:fastapi.\"changes\": list(update_data.keys())\n            }\n        ]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.this would query the database\n    issue_detail = generate_mock_issue_detail(issue_id)\n    \n    if not issue_detail:\n        raise HTTPException(status_code=404",
        "import:fastapi.Party",
        "import:fastapi.status",
        "import:fastapi.detail=f\"Invalid fields for update: {'",
        "import:fastapi.priority",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific issue.\n    Provides complete issue details and status information.\n    \"\"\"\n    # For now",
        "import:fastapi.this would update the database\n    updated_issue = {\n        \"id\": issue_id",
        "import:fastapi.\"description\": update_data.get(\"description\"",
        "import:fastapi.\"Updated Issue Name\")",
        "import:fastapi.\"next_steps\": [\n            \"Your issue has been submitted for review\"",
        "import:fastapi.create mock issue detail\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new user issue.\n    Users can report issues that need government attention.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.\"summary\": issue_data[\"summary\"]",
        "import:fastapi.\"issue\": issue_detail\n    }\n\n\n@router.put(\"/{issue_id}/update\")\nasync def update_issue(\n    issue_id: str",
        "import:fastapi.\"user_issues\": mock_issues[\"issues\"]",
        "import:fastapi.create mock issue response\n    # In a full implementation",
        "import:fastapi.detail=\"Issue not found\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"contact_email\": issue_data.get(\"contact_email\")",
        "import:fastapi.\"created_at\": datetime.utcnow().isoformat()",
        "import:fastapi.\"unknown\")",
        "import:fastapi.\"constituency\": issue_data.get(\"constituency\")",
        "import:fastapi.\"healthcare\": 20\n            }",
        "import:fastapi.detail=\"Issue name must be at least 3 characters\")\n    \n    if len(issue_data[\"summary\"]) < 10:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"user_id\": issue_data.get(\"user_id\"",
        "import:fastapi.\"user_agent\": issue_data.get(\"user_agent\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'.join(invalid_fields)}\"\n        )\n    \n    # For now",
        "import:fastapi.\"pagination\": community_issues[\"pagination\"]",
        "import:fastapi.this would delete from the database\n    return {\n        \"success\": True",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"summary\": {\n            \"total_issues\": mock_issues[\"pagination\"][\"total\"]",
        "import:fastapi.\"Updated issue summary\")",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update an existing issue.\n    Users can modify their issues before approval.\n    \"\"\"\n    # Validate updateable fields\n    allowed_fields = [\"name\"",
        "import:fastapi.\"tags\"]\n    invalid_fields = [field for field in update_data.keys() if field not in allowed_fields]\n    \n    if invalid_fields:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get community issues for public viewing.\n    Provides approved issues that are visible to all users.\n    \"\"\"\n    # For now",
        "import:fastapi.\"ip_address\": issue_data.get(\"ip_address\")",
        "import:fastapi.update_data: Dict[str",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Any",
        "import:fastapi.\"medium\": 45",
        "import:fastapi.\"summary\": update_data.get(\"summary\"",
        "import:fastapi.\"demo-user\")",
        "import:fastapi.constituency",
        "import:fastapi.\"general\")",
        "import:fastapi.\"Approved issues will be visible to the community\"\n        ]\n    }\n\n\n@router.get(\"/user-issues\")\nasync def get_user_issues(\n    user_id: str",
        "import:fastapi.\"social\": 18",
        "import:fastapi.\"by_category\": {\n                \"environmental\": 15",
        "import:fastapi.description=\"Update data\")",
        "import:fastapi.page_size)\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.detail=\"Issue description must be at least 20 characters\")\n    \n    # For now",
        "import:fastapi.\"constituency\": constituency",
        "import:fastapi.\"medium\")",
        "import:fastapi.this would save to the database\n    issue_record = {\n        \"id\": f\"issue-{datetime.utcnow().timestamp()}\"",
        "import:fastapi.\"message\": \"Issue updated successfully\"",
        "import:fastapi.\"community_issues\": community_issues[\"issues\"]",
        "import:fastapi.\"issue\": updated_issue\n    }\n\n\n@router.delete(\"/{issue_id}\")\nasync def delete_issue(\n    issue_id: str",
        "import:fastapi.\"pending_approval\": 3",
        "import:fastapi.\"update_history\": [\n            {\n                \"timestamp\": datetime.utcnow().isoformat()",
        "import:fastapi.\"summary\"",
        "import:fastapi.\"message\": \"Issue created successfully and is pending admin approval\"",
        "import:fastapi.description=\"User ID for verification\")",
        "import:fastapi.\"message\": \"Issue deleted successfully\"",
        "import:fastapi.\"action\": \"user_update\"",
        "import:fastapi.\"summary\": {\n            \"total_community_issues\": community_issues[\"pagination\"][\"total\"]",
        "import:fastapi.\"priority\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate field lengths\n    if len(issue_data[\"name\"]) < 3:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": issue_data[\"name\"]",
        "import:fastapi.\"description\"",
        "import:fastapi.create mock delete response\n    # In a full implementation",
        "import:fastapi.description=\"Filter by issue category\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete an issue.\n    Users can delete their issues if they haven't been approved yet.\n    \"\"\"\n    # For now",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"category\": issue_data.get(\"category\"",
        "import:fastapi.\"priority\": issue_data.get(\"priority\"",
        "import:fastapi.\"tags\": issue_data.get(\"tags\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.\"category\": category\n        }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/{issue_id}/supporters": {
      "method": "GET",
      "path": "/{issue_id}/supporters",
      "file": "services/api-gateway/app/api/v1/issues.py",
      "line": 287,
      "dependencies": [
        "import:fastapi.description=\"Issue data\")",
        "import:fastapi.\"rejected\": 1",
        "import:fastapi.\"priority\": update_data.get(\"priority\"",
        "import:fastapi.\"support\": support_record",
        "import:fastapi.constituency: Optional[str] = Query(None",
        "import:fastapi.\"created_at\": datetime.utcnow().isoformat()\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Filter by constituency\")",
        "import:fastapi.category",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issues created by a specific user.\n    Provides paginated list of user's issues with filtering options.\n    \"\"\"\n    # For now",
        "import:fastapi.create mock support response\n    # In a full implementation",
        "import:fastapi.\"category\"",
        "import:fastapi.\"economic\": 23",
        "import:fastapi.\"category\": update_data.get(\"category\"",
        "import:fastapi.\"You will receive updates on the approval status\"",
        "import:fastapi.detail=\"Issue summary must be at least 10 characters\")\n    \n    if len(issue_data[\"description\"]) < 20:\n        raise HTTPException(status_code=400",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.post(\"/create\")\nasync def create_issue(\n    issue_data: Dict[str",
        "import:fastapi.user_id: str = Query(...",
        "import:fastapi.\"category\": category",
        "import:fastapi.Politician",
        "import:fastapi.\"name\": update_data.get(\"name\"",
        "import:fastapi.ge=1",
        "import:fastapi.\"total_supporters\": 42  # Mock total\n    }",
        "import:fastapi.create mock user issues\n    # In a full implementation",
        "import:fastapi.le=100",
        "import:fastapi.\"infrastructure\": 12",
        "import:fastapi.this would query the database\n    community_issues = generate_mock_community_issues(status",
        "import:fastapi.\"location\": issue_data.get(\"location\")\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"metadata\": {\n            \"source\": \"web\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Support an issue.\n    Users can show support for community issues.\n    \"\"\"\n    # Validate required fields\n    if \"user_id\" not in support_data:\n        raise HTTPException(status_code=400",
        "import:fastapi.[])",
        "import:fastapi.this would query the database\n    mock_issues = generate_mock_user_issues(user_id",
        "import:fastapi.\"Updated issue description\")",
        "import:fastapi.\"deleted_issue_id\": issue_id",
        "import:fastapi.HTTPException",
        "import:fastapi.\"attachments\": issue_data.get(\"attachments\"",
        "import:fastapi.\"user_id\": support_data[\"user_id\"]",
        "import:fastapi.create mock community issues\n    # In a full implementation",
        "import:fastapi.\"approved\": 5",
        "import:fastapi.priority: Optional[str] = Query(None",
        "import:fastapi.\"issue\": issue_record",
        "import:fastapi.support_data: Dict[str",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by priority\")",
        "import:fastapi.\"deleted_at\": datetime.utcnow().isoformat()\n    }\n\n\n@router.get(\"/community/issues\")\nasync def get_community_issues(\n    status: Optional[str] = Query(None",
        "import:fastapi.\"issue_id\": issue_id",
        "import:fastapi.\"description\": issue_data[\"description\"]",
        "import:fastapi.\"An admin will review and approve your issue\"",
        "import:fastapi.\"status\": \"pending_approval\"",
        "import:fastapi.\"priority\": priority\n        }",
        "import:fastapi.\"pagination\": mock_issues[\"pagination\"]",
        "import:fastapi.page",
        "import:fastapi.\"updated_at\": datetime.utcnow().isoformat()",
        "import:fastapi.description=\"Filter by issue status\")",
        "import:fastapi.create mock update response\n    # In a full implementation",
        "import:fastapi.\"resolved\": 2\n        }\n    }\n\n\n@router.get(\"/{issue_id}\")\nasync def get_issue_detail(\n    issue_id: str",
        "function:support_issue",
        "import:fastapi.\"by_priority\": {\n                \"high\": 25",
        "import:fastapi.Query\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.\"user_id\": user_id",
        "import:fastapi.\"postal_code\": issue_data.get(\"postal_code\")",
        "import:fastapi.\"filters\": {\n            \"status\": status",
        "import:fastapi.\"changes\": list(update_data.keys())\n            }\n        ]\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.this would query the database\n    issue_detail = generate_mock_issue_detail(issue_id)\n    \n    if not issue_detail:\n        raise HTTPException(status_code=404",
        "import:fastapi.Party",
        "import:fastapi.status",
        "import:fastapi.detail=f\"Invalid fields for update: {'",
        "import:fastapi.priority",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific issue.\n    Provides complete issue details and status information.\n    \"\"\"\n    # For now",
        "import:fastapi.this would update the database\n    updated_issue = {\n        \"id\": issue_id",
        "import:fastapi.\"description\": update_data.get(\"description\"",
        "import:fastapi.\"Updated Issue Name\")",
        "import:fastapi.\"next_steps\": [\n            \"Your issue has been submitted for review\"",
        "import:fastapi.create mock issue detail\n    # In a full implementation",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Create a new user issue.\n    Users can report issues that need government attention.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"name\"",
        "import:fastapi.this would save to the database\n    support_record = {\n        \"id\": f\"support-{datetime.utcnow().timestamp()}\"",
        "import:fastapi.\"constituency\": support_data.get(\"constituency\")",
        "import:fastapi.\"summary\": issue_data[\"summary\"]",
        "import:fastapi.\"issue\": issue_detail\n    }\n\n\n@router.put(\"/{issue_id}/update\")\nasync def update_issue(\n    issue_id: str",
        "import:fastapi.description=\"Support data\")",
        "import:fastapi.\"user_issues\": mock_issues[\"issues\"]",
        "import:fastapi.create mock issue response\n    # In a full implementation",
        "import:fastapi.detail=\"Issue not found\")\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"contact_email\": issue_data.get(\"contact_email\")",
        "import:fastapi.\"created_at\": datetime.utcnow().isoformat()",
        "import:fastapi.\"unknown\")",
        "import:fastapi.\"constituency\": issue_data.get(\"constituency\")",
        "import:fastapi.\"healthcare\": 20\n            }",
        "import:fastapi.detail=\"Issue name must be at least 3 characters\")\n    \n    if len(issue_data[\"summary\"]) < 10:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"user_id\": issue_data.get(\"user_id\"",
        "import:fastapi.\"user_agent\": issue_data.get(\"user_agent\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'.join(invalid_fields)}\"\n        )\n    \n    # For now",
        "import:fastapi.\"pagination\": community_issues[\"pagination\"]",
        "import:fastapi.this would delete from the database\n    return {\n        \"success\": True",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"summary\": {\n            \"total_issues\": mock_issues[\"pagination\"][\"total\"]",
        "import:fastapi.\"Updated issue summary\")",
        "import:fastapi.category: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Update an existing issue.\n    Users can modify their issues before approval.\n    \"\"\"\n    # Validate updateable fields\n    allowed_fields = [\"name\"",
        "import:fastapi.\"tags\"]\n    invalid_fields = [field for field in update_data.keys() if field not in allowed_fields]\n    \n    if invalid_fields:\n        raise HTTPException(\n            status_code=400",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get community issues for public viewing.\n    Provides approved issues that are visible to all users.\n    \"\"\"\n    # For now",
        "import:fastapi.\"ip_address\": issue_data.get(\"ip_address\")",
        "import:fastapi.update_data: Dict[str",
        "import:fastapi.\"support_type\": support_data.get(\"support_type\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Any",
        "import:fastapi.\"medium\": 45",
        "import:fastapi.\"summary\": update_data.get(\"summary\"",
        "import:fastapi.\"demo-user\")",
        "import:fastapi.constituency",
        "import:fastapi.\"general\")",
        "import:fastapi.\"Approved issues will be visible to the community\"\n        ]\n    }\n\n\n@router.get(\"/user-issues\")\nasync def get_user_issues(\n    user_id: str",
        "import:fastapi.\"low\": 18\n            }\n        }\n    }\n\n\n@router.post(\"/{issue_id}/support\")\nasync def support_issue(\n    issue_id: str",
        "import:fastapi.\"social\": 18",
        "import:fastapi.\"by_category\": {\n                \"environmental\": 15",
        "import:fastapi.description=\"Update data\")",
        "import:fastapi.page_size)\n    \n    return {\n        \"success\": True",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.detail=\"Issue description must be at least 20 characters\")\n    \n    # For now",
        "import:fastapi.\"constituency\": constituency",
        "import:fastapi.\"medium\")",
        "import:fastapi.this would save to the database\n    issue_record = {\n        \"id\": f\"issue-{datetime.utcnow().timestamp()}\"",
        "import:fastapi.\"message\": \"Issue updated successfully\"",
        "import:fastapi.\"community_issues\": community_issues[\"issues\"]",
        "import:fastapi.\"issue\": updated_issue\n    }\n\n\n@router.delete(\"/{issue_id}\")\nasync def delete_issue(\n    issue_id: str",
        "import:fastapi.\"pending_approval\": 3",
        "import:fastapi.\"update_history\": [\n            {\n                \"timestamp\": datetime.utcnow().isoformat()",
        "import:fastapi.\"summary\"",
        "import:fastapi.\"message\": \"Issue created successfully and is pending admin approval\"",
        "import:fastapi.description=\"User ID for verification\")",
        "import:fastapi.\"message\": \"Issue deleted successfully\"",
        "import:fastapi.\"action\": \"user_update\"",
        "import:fastapi.\"summary\": {\n            \"total_community_issues\": community_issues[\"pagination\"][\"total\"]",
        "import:fastapi.detail=\"Missing user_id\")\n    \n    # For now",
        "import:fastapi.\"message\": \"Issue supported successfully\"",
        "import:fastapi.\"priority\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    # Validate field lengths\n    if len(issue_data[\"name\"]) < 3:\n        raise HTTPException(status_code=400",
        "import:fastapi.\"name\": issue_data[\"name\"]",
        "import:fastapi.\"description\"",
        "import:fastapi.\"comment\": support_data.get(\"comment\")",
        "import:fastapi.create mock delete response\n    # In a full implementation",
        "import:fastapi.description=\"Filter by issue category\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Delete an issue.\n    Users can delete their issues if they haven't been approved yet.\n    \"\"\"\n    # For now",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"category\": issue_data.get(\"category\"",
        "import:fastapi.\"priority\": issue_data.get(\"priority\"",
        "import:fastapi.\"tags\": issue_data.get(\"tags\"",
        "import:fastapi.Body",
        "import:fastapi.Dict",
        "import:fastapi.\"category\": category\n        }",
        "import:fastapi.APIRouter",
        "import:fastapi.\"description\"]\n    for field in required_fields:\n        if field not in issue_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.ElectedMember"
      ]
    },
    "POST:/register": {
      "method": "POST",
      "path": "/register",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 251,
      "dependencies": [
        "import:datetime.SECRET_KEY",
        "import:datetime.datetime",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.token: str",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.timedelta",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.HTTPException",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.UserSession",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.BackgroundTasks",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.min_length=8",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.Request",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.max_length=255",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.Depends",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "function:check_rate_limit",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(..."
      ]
    },
    "POST:/token": {
      "method": "POST",
      "path": "/token",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 305,
      "dependencies": [
        "import:datetime.SECRET_KEY",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.is_active=True",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.username=new_user.username",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.UserSession",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.Request",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.is_active=new_user.is_active",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.email=user_data.email",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.token: str",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.full_name=new_user.full_name",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user account.\n    \n    Implements checklist item 5.7: User registration endpoint\n    \"\"\"\n    # Check if username already exists\n    existing_user = db.query(User).filter(User.username == user_data.username).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.max_length=255",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.is_verified=False  # Email verification would be implemented separately\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    logger.info(f\"New user registered: {new_user.username}\")\n    \n    return UserProfile(\n        id=str(new_user.id)",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.created_at=new_user.created_at.isoformat() if new_user.created_at else None\n    )",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "function:register_user",
        "import:datetime.response_model=UserProfile)\nasync def register_user(\n    user_data: UserRegister",
        "import:datetime.detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    hashed_password = hash_password(user_data.password)\n    new_user = User(\n        username=user_data.username",
        "import:datetime.timedelta",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True\n\n\n@router.post(\"/register\"",
        "import:datetime.HTTPException",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.BackgroundTasks",
        "import:datetime.min_length=8",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.full_name=user_data.full_name",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.is_verified=new_user.is_verified",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(...",
        "import:datetime.datetime",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.hashed_password=hashed_password",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.email=new_user.email",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.detail=\"Username already registered\"\n        )\n    \n    # Check if email already exists\n    existing_email = db.query(User).filter(User.email == user_data.email).first()\n    if existing_email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.Depends",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(..."
      ]
    },
    "GET:/me": {
      "method": "GET",
      "path": "/me",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 361,
      "dependencies": [
        "import:datetime.SECRET_KEY",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.is_active=True",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.username=new_user.username",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.UserSession",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.Request",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.is_active=new_user.is_active",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.email=user_data.email",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.token: str",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.full_name=new_user.full_name",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user account.\n    \n    Implements checklist item 5.7: User registration endpoint\n    \"\"\"\n    # Check if username already exists\n    existing_user = db.query(User).filter(User.username == user_data.username).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.# Could be extracted from request\n        user_agent=None   # Could be extracted from request\n    )\n    db.add(session)\n    db.commit()\n    \n    logger.info(f\"User logged in: {user.username}\")\n    \n    return Token(\n        access_token=access_token",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.max_length=255",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.is_verified=False  # Email verification would be implemented separately\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    logger.info(f\"New user registered: {new_user.username}\")\n    \n    return UserProfile(\n        id=str(new_user.id)",
        "import:datetime.)\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "function:login_for_access_token",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.token_type=\"bearer\"",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "import:datetime.response_model=UserProfile)\nasync def register_user(\n    user_data: UserRegister",
        "import:datetime.detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    hashed_password = hash_password(user_data.password)\n    new_user = User(\n        username=user_data.username",
        "import:datetime.timedelta",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True\n\n\n@router.post(\"/register\"",
        "import:datetime.HTTPException",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.expires_delta=access_token_expires\n    )\n    \n    # Create user session\n    session = UserSession(\n        user_id=user.id",
        "import:datetime.response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends()",
        "import:datetime.BackgroundTasks",
        "import:datetime.min_length=8",
        "import:datetime.detail=\"Inactive user account\"\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.created_at=new_user.created_at.isoformat() if new_user.created_at else None\n    )\n\n\n@router.post(\"/token\"",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.full_name=user_data.full_name",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.is_verified=new_user.is_verified",
        "import:datetime.session_token=access_token",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Authenticate user and return access token.\n    \n    Implements checklist item 5.7: User login endpoint\n    Implements checklist item 10.1: JWT authentication\n    \"\"\"\n    # Try to find user by username or email\n    user = db.query(User).filter(\n        (User.username == form_data.username) | (User.email == form_data.username)\n    ).first()\n    \n    if not user or not verify_password(form_data.password",
        "import:datetime.ip_address=None",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(...",
        "import:datetime.expires_at=datetime.utcnow() + access_token_expires",
        "import:datetime.datetime",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.hashed_password=hashed_password",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.email=new_user.email",
        "import:datetime.user=user.to_dict()\n    )",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.detail=\"Username already registered\"\n        )\n    \n    # Check if email already exists\n    existing_email = db.query(User).filter(User.email == user_data.email).first()\n    if existing_email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.Depends",
        "import:datetime.detail=\"Incorrect username/email or password\"",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(..."
      ]
    },
    "POST:/logout": {
      "method": "POST",
      "path": "/logout",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 379,
      "dependencies": [
        "import:datetime.username=current_user.username",
        "import:datetime.SECRET_KEY",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.is_active=True",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.username=new_user.username",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.UserSession",
        "import:datetime.email=current_user.email",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.Request",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.is_active=new_user.is_active",
        "import:datetime.response_model=UserProfile)\nasync def read_users_me(current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Get current user profile.\n    \n    Implements checklist item 5.7: User profile endpoint\n    \"\"\"\n    return UserProfile(\n        id=str(current_user.id)",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.email=user_data.email",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.token: str",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.full_name=new_user.full_name",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "function:read_users_me",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user account.\n    \n    Implements checklist item 5.7: User registration endpoint\n    \"\"\"\n    # Check if username already exists\n    existing_user = db.query(User).filter(User.username == user_data.username).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.# Could be extracted from request\n        user_agent=None   # Could be extracted from request\n    )\n    db.add(session)\n    db.commit()\n    \n    logger.info(f\"User logged in: {user.username}\")\n    \n    return Token(\n        access_token=access_token",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.is_active=current_user.is_active",
        "import:datetime.max_length=255",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.is_verified=False  # Email verification would be implemented separately\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    logger.info(f\"New user registered: {new_user.username}\")\n    \n    return UserProfile(\n        id=str(new_user.id)",
        "import:datetime.)\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.token_type=\"bearer\"",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "import:datetime.response_model=UserProfile)\nasync def register_user(\n    user_data: UserRegister",
        "import:datetime.detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    hashed_password = hash_password(user_data.password)\n    new_user = User(\n        username=user_data.username",
        "import:datetime.timedelta",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True\n\n\n@router.post(\"/register\"",
        "import:datetime.HTTPException",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.expires_delta=access_token_expires\n    )\n    \n    # Create user session\n    session = UserSession(\n        user_id=user.id",
        "import:datetime.response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends()",
        "import:datetime.BackgroundTasks",
        "import:datetime.min_length=8",
        "import:datetime.detail=\"Inactive user account\"\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.created_at=new_user.created_at.isoformat() if new_user.created_at else None\n    )\n\n\n@router.post(\"/token\"",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.full_name=current_user.full_name",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.is_verified=current_user.is_verified",
        "import:datetime.full_name=user_data.full_name",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.is_verified=new_user.is_verified",
        "import:datetime.session_token=access_token",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Authenticate user and return access token.\n    \n    Implements checklist item 5.7: User login endpoint\n    Implements checklist item 10.1: JWT authentication\n    \"\"\"\n    # Try to find user by username or email\n    user = db.query(User).filter(\n        (User.username == form_data.username) | (User.email == form_data.username)\n    ).first()\n    \n    if not user or not verify_password(form_data.password",
        "import:datetime.ip_address=None",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(...",
        "import:datetime.expires_at=datetime.utcnow() + access_token_expires",
        "import:datetime.datetime",
        "import:datetime.created_at=current_user.created_at.isoformat() if current_user.created_at else None\n    )",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.hashed_password=hashed_password",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.email=new_user.email",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.user=user.to_dict()\n    )\n\n\n@router.get(\"/me\"",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.detail=\"Username already registered\"\n        )\n    \n    # Check if email already exists\n    existing_email = db.query(User).filter(User.email == user_data.email).first()\n    if existing_email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.Depends",
        "import:datetime.detail=\"Incorrect username/email or password\"",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(..."
      ]
    },
    "POST:/reset-password": {
      "method": "POST",
      "path": "/reset-password",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 395,
      "dependencies": [
        "import:datetime.username=current_user.username",
        "import:datetime.SECRET_KEY",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.is_active=True",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.username=new_user.username",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.UserSession",
        "import:datetime.email=current_user.email",
        "import:datetime.created_at=current_user.created_at.isoformat() if current_user.created_at else None\n    )\n\n\n@router.post(\"/logout\")\nasync def logout_user(current_user: User = Depends(get_current_user)",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.Request",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.is_active=new_user.is_active",
        "import:datetime.response_model=UserProfile)\nasync def read_users_me(current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Get current user profile.\n    \n    Implements checklist item 5.7: User profile endpoint\n    \"\"\"\n    return UserProfile(\n        id=str(current_user.id)",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.email=user_data.email",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.token: str",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.db: DBSession = Depends(get_db)):\n    \"\"\"\n    Logout user and invalidate session.\n    \n    Implements checklist item 5.7: User logout endpoint\n    \"\"\"\n    # Remove user session\n    db.query(UserSession).filter(UserSession.user_id == current_user.id).delete()\n    db.commit()\n    \n    logger.info(f\"User logged out: {current_user.username}\")\n    \n    return {\"message\": \"Successfully logged out\"}",
        "import:datetime.full_name=new_user.full_name",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user account.\n    \n    Implements checklist item 5.7: User registration endpoint\n    \"\"\"\n    # Check if username already exists\n    existing_user = db.query(User).filter(User.username == user_data.username).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "function:logout_user",
        "import:datetime.user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.# Could be extracted from request\n        user_agent=None   # Could be extracted from request\n    )\n    db.add(session)\n    db.commit()\n    \n    logger.info(f\"User logged in: {user.username}\")\n    \n    return Token(\n        access_token=access_token",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.is_active=current_user.is_active",
        "import:datetime.max_length=255",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.is_verified=False  # Email verification would be implemented separately\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    logger.info(f\"New user registered: {new_user.username}\")\n    \n    return UserProfile(\n        id=str(new_user.id)",
        "import:datetime.)\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.token_type=\"bearer\"",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "import:datetime.response_model=UserProfile)\nasync def register_user(\n    user_data: UserRegister",
        "import:datetime.detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    hashed_password = hash_password(user_data.password)\n    new_user = User(\n        username=user_data.username",
        "import:datetime.timedelta",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True\n\n\n@router.post(\"/register\"",
        "import:datetime.HTTPException",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.expires_delta=access_token_expires\n    )\n    \n    # Create user session\n    session = UserSession(\n        user_id=user.id",
        "import:datetime.response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends()",
        "import:datetime.BackgroundTasks",
        "import:datetime.min_length=8",
        "import:datetime.detail=\"Inactive user account\"\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.created_at=new_user.created_at.isoformat() if new_user.created_at else None\n    )\n\n\n@router.post(\"/token\"",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.full_name=current_user.full_name",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.is_verified=current_user.is_verified",
        "import:datetime.full_name=user_data.full_name",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.is_verified=new_user.is_verified",
        "import:datetime.session_token=access_token",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Authenticate user and return access token.\n    \n    Implements checklist item 5.7: User login endpoint\n    Implements checklist item 10.1: JWT authentication\n    \"\"\"\n    # Try to find user by username or email\n    user = db.query(User).filter(\n        (User.username == form_data.username) | (User.email == form_data.username)\n    ).first()\n    \n    if not user or not verify_password(form_data.password",
        "import:datetime.ip_address=None",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(...",
        "import:datetime.expires_at=datetime.utcnow() + access_token_expires",
        "import:datetime.datetime",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.hashed_password=hashed_password",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.email=new_user.email",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.user=user.to_dict()\n    )\n\n\n@router.get(\"/me\"",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.detail=\"Username already registered\"\n        )\n    \n    # Check if email already exists\n    existing_email = db.query(User).filter(User.email == user_data.email).first()\n    if existing_email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.Depends",
        "import:datetime.detail=\"Incorrect username/email or password\"",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(..."
      ]
    },
    "POST:/confirm-reset-password": {
      "method": "POST",
      "path": "/confirm-reset-password",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 473,
      "dependencies": [
        "import:datetime.username=current_user.username",
        "import:datetime.SECRET_KEY",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n        )\n    \n    # Generate reset token\n    token = generate_reset_token()\n    expires_at = datetime.now(timezone.utc) + timedelta(hours=PASSWORD_RESET_TOKEN_EXPIRE_HOURS)\n    \n    # Invalidate any existing reset tokens for this user\n    db.query(PasswordResetToken).filter(\n        PasswordResetToken.user_id == user.id\n    ).delete()\n    \n    # Create new reset token\n    reset_token = PasswordResetToken(\n        user_id=user.id",
        "import:datetime.is_active=True",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.username=new_user.username",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n        )\n    \n    if not user.is_active:\n        # Don't allow password reset for inactive accounts\n        logger.warning(f\"Password reset requested for inactive user: {user.email}\")\n        return PasswordResetResponse(\n            message=\"If an account with that email exists",
        "import:datetime.UserSession",
        "import:datetime.email=current_user.email",
        "import:datetime.created_at=current_user.created_at.isoformat() if current_user.created_at else None\n    )\n\n\n@router.post(\"/logout\")\nasync def logout_user(current_user: User = Depends(get_current_user)",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.Request",
        "import:datetime.user.email",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.is_active=new_user.is_active",
        "import:datetime.response_model=UserProfile)\nasync def read_users_me(current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Get current user profile.\n    \n    Implements checklist item 5.7: User profile endpoint\n    \"\"\"\n    return UserProfile(\n        id=str(current_user.id)",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.email=user_data.email",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.token: str",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.full_name=new_user.full_name",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user account.\n    \n    Implements checklist item 5.7: User registration endpoint\n    \"\"\"\n    # Check if username already exists\n    existing_user = db.query(User).filter(User.username == user_data.username).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.token=token",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.# Could be extracted from request\n        user_agent=None   # Could be extracted from request\n    )\n    db.add(session)\n    db.commit()\n    \n    logger.info(f\"User logged in: {user.username}\")\n    \n    return Token(\n        access_token=access_token",
        "import:datetime.reset_request: PasswordResetRequest",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.is_active=current_user.is_active",
        "import:datetime.max_length=255",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.is_verified=False  # Email verification would be implemented separately\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    logger.info(f\"New user registered: {new_user.username}\")\n    \n    return UserProfile(\n        id=str(new_user.id)",
        "import:datetime.)\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.background_tasks: BackgroundTasks",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "import:datetime.a password reset link has been sent.\"",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Request password reset for a user account.\n    \n    Implements checklist item 30.1: Create password reset endpoint /api/v1/auth/reset-password\n    Implements checklist item 30.2: Implement password reset token generation\n    Implements checklist item 30.6: Add rate limiting to password reset\n    \"\"\"\n    \n    # Check rate limiting\n    if not check_rate_limit(request",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.token_type=\"bearer\"",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n    )",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "import:datetime.response_model=UserProfile)\nasync def register_user(\n    user_data: UserRegister",
        "import:datetime.detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    hashed_password = hash_password(user_data.password)\n    new_user = User(\n        username=user_data.username",
        "import:datetime.timedelta",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True\n\n\n@router.post(\"/register\"",
        "import:datetime.HTTPException",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.expires_delta=access_token_expires\n    )\n    \n    # Create user session\n    session = UserSession(\n        user_id=user.id",
        "import:datetime.response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends()",
        "import:datetime.BackgroundTasks",
        "import:datetime.min_length=8",
        "import:datetime.detail=\"Inactive user account\"\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.created_at=new_user.created_at.isoformat() if new_user.created_at else None\n    )\n\n\n@router.post(\"/token\"",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.full_name=current_user.full_name",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.is_verified=current_user.is_verified",
        "import:datetime.full_name=user_data.full_name",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.always return success even if user doesn't exist\n        # This prevents email enumeration attacks\n        logger.info(f\"Password reset requested for non-existent email: {reset_request.email}\")\n        return PasswordResetResponse(\n            message=\"If an account with that email exists",
        "import:datetime.is_verified=new_user.is_verified",
        "import:datetime.session_token=access_token",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Authenticate user and return access token.\n    \n    Implements checklist item 5.7: User login endpoint\n    Implements checklist item 10.1: JWT authentication\n    \"\"\"\n    # Try to find user by username or email\n    user = db.query(User).filter(\n        (User.username == form_data.username) | (User.email == form_data.username)\n    ).first()\n    \n    if not user or not verify_password(form_data.password",
        "import:datetime.ip_address=None",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(...",
        "import:datetime.user.full_name\n    )\n    \n    logger.info(f\"Password reset token generated for user {user.email}\")\n    \n    return PasswordResetResponse(\n        message=\"If an account with that email exists",
        "import:datetime.expires_at=datetime.utcnow() + access_token_expires",
        "import:datetime.datetime",
        "import:datetime.db):\n        raise HTTPException(\n            status_code=429",
        "import:datetime.token",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.hashed_password=hashed_password",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.ip_address=request.client.host if request.client else None\n    )\n    \n    db.add(reset_token)\n    db.commit()\n    \n    # Send email in background (Item 30.3: Create password reset email template)\n    background_tasks.add_task(\n        send_password_reset_email",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.email=new_user.email",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.expires_at=expires_at",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.user=user.to_dict()\n    )\n\n\n@router.get(\"/me\"",
        "function:request_password_reset",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.db: DBSession = Depends(get_db)):\n    \"\"\"\n    Logout user and invalidate session.\n    \n    Implements checklist item 5.7: User logout endpoint\n    \"\"\"\n    # Remove user session\n    db.query(UserSession).filter(UserSession.user_id == current_user.id).delete()\n    db.commit()\n    \n    logger.info(f\"User logged out: {current_user.username}\")\n    \n    return {\"message\": \"Successfully logged out\"}\n\n\n@router.post(\"/reset-password\"",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.detail=\"Username already registered\"\n        )\n    \n    # Check if email already exists\n    existing_email = db.query(User).filter(User.email == user_data.email).first()\n    if existing_email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.Depends",
        "import:datetime.detail=\"Incorrect username/email or password\"",
        "import:datetime.detail=f\"Too many password reset requests. Maximum {PASSWORD_RESET_RATE_LIMIT} requests per hour allowed.\"\n        )\n    \n    # Find user by email\n    user = db.query(User).filter(User.email == reset_request.email).first()\n    \n    if not user:\n        # For security",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(...",
        "import:datetime.response_model=PasswordResetResponse)\nasync def request_password_reset(\n    request: Request"
      ]
    },
    "GET:/reset-password/validate/{token}": {
      "method": "GET",
      "path": "/reset-password/validate/{token}",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 535,
      "dependencies": [
        "import:datetime.username=current_user.username",
        "import:datetime.SECRET_KEY",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n        )\n    \n    # Generate reset token\n    token = generate_reset_token()\n    expires_at = datetime.now(timezone.utc) + timedelta(hours=PASSWORD_RESET_TOKEN_EXPIRE_HOURS)\n    \n    # Invalidate any existing reset tokens for this user\n    db.query(PasswordResetToken).filter(\n        PasswordResetToken.user_id == user.id\n    ).delete()\n    \n    # Create new reset token\n    reset_token = PasswordResetToken(\n        user_id=user.id",
        "import:datetime.is_active=True",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.username=new_user.username",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n        )\n    \n    if not user.is_active:\n        # Don't allow password reset for inactive accounts\n        logger.warning(f\"Password reset requested for inactive user: {user.email}\")\n        return PasswordResetResponse(\n            message=\"If an account with that email exists",
        "import:datetime.UserSession",
        "import:datetime.email=current_user.email",
        "import:datetime.created_at=current_user.created_at.isoformat() if current_user.created_at else None\n    )\n\n\n@router.post(\"/logout\")\nasync def logout_user(current_user: User = Depends(get_current_user)",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.Request",
        "import:datetime.user.email",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.is_active=new_user.is_active",
        "import:datetime.response_model=UserProfile)\nasync def read_users_me(current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Get current user profile.\n    \n    Implements checklist item 5.7: User profile endpoint\n    \"\"\"\n    return UserProfile(\n        id=str(current_user.id)",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.email=user_data.email",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.token: str",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.reset_confirm: PasswordResetConfirm",
        "import:datetime.full_name=new_user.full_name",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.response_model=PasswordResetConfirmResponse)\nasync def confirm_password_reset(\n    request: Request",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user account.\n    \n    Implements checklist item 5.7: User registration endpoint\n    \"\"\"\n    # Check if username already exists\n    existing_user = db.query(User).filter(User.username == user_data.username).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.token=token",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.# Could be extracted from request\n        user_agent=None   # Could be extracted from request\n    )\n    db.add(session)\n    db.commit()\n    \n    logger.info(f\"User logged in: {user.username}\")\n    \n    return Token(\n        access_token=access_token",
        "import:datetime.reset_request: PasswordResetRequest",
        "function:confirm_password_reset",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Confirm password reset and update user password.\n    \n    This endpoint completes the password reset flow by validating the token\n    and updating the user's password.\n    \"\"\"\n    \n    # Find the reset token\n    reset_token = db.query(PasswordResetToken).filter(\n        PasswordResetToken.token == reset_confirm.token\n    ).first()\n    \n    if not reset_token:\n        logger.warning(f\"Invalid reset token used: {reset_confirm.token[:8]}...\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.is_active=current_user.is_active",
        "import:datetime.max_length=255",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.is_verified=False  # Email verification would be implemented separately\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    logger.info(f\"New user registered: {new_user.username}\")\n    \n    return UserProfile(\n        id=str(new_user.id)",
        "import:datetime.)\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.background_tasks: BackgroundTasks",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "import:datetime.a password reset link has been sent.\"",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Request password reset for a user account.\n    \n    Implements checklist item 30.1: Create password reset endpoint /api/v1/auth/reset-password\n    Implements checklist item 30.2: Implement password reset token generation\n    Implements checklist item 30.6: Add rate limiting to password reset\n    \"\"\"\n    \n    # Check rate limiting\n    if not check_rate_limit(request",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.token_type=\"bearer\"",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "import:datetime.response_model=UserProfile)\nasync def register_user(\n    user_data: UserRegister",
        "import:datetime.detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    hashed_password = hash_password(user_data.password)\n    new_user = User(\n        username=user_data.username",
        "import:datetime.timedelta",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True\n\n\n@router.post(\"/register\"",
        "import:datetime.HTTPException",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.expires_delta=access_token_expires\n    )\n    \n    # Create user session\n    session = UserSession(\n        user_id=user.id",
        "import:datetime.response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends()",
        "import:datetime.BackgroundTasks",
        "import:datetime.min_length=8",
        "import:datetime.detail=\"Inactive user account\"\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Get the user\n    user = db.query(User).filter(User.id == reset_token.user_id).first()\n    \n    if not user or not user.is_active:\n        logger.error(f\"Reset token belongs to non-existent or inactive user: {reset_token.user_id}\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.created_at=new_user.created_at.isoformat() if new_user.created_at else None\n    )\n\n\n@router.post(\"/token\"",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.full_name=current_user.full_name",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Check if token is valid\n    if not reset_token.is_valid():\n        logger.warning(f\"Expired or used reset token: {reset_confirm.token[:8]}...\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n    )\n\n\n@router.post(\"/confirm-reset-password\"",
        "import:datetime.is_verified=current_user.is_verified",
        "import:datetime.full_name=user_data.full_name",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.always return success even if user doesn't exist\n        # This prevents email enumeration attacks\n        logger.info(f\"Password reset requested for non-existent email: {reset_request.email}\")\n        return PasswordResetResponse(\n            message=\"If an account with that email exists",
        "import:datetime.is_verified=new_user.is_verified",
        "import:datetime.session_token=access_token",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Authenticate user and return access token.\n    \n    Implements checklist item 5.7: User login endpoint\n    Implements checklist item 10.1: JWT authentication\n    \"\"\"\n    # Try to find user by username or email\n    user = db.query(User).filter(\n        (User.username == form_data.username) | (User.email == form_data.username)\n    ).first()\n    \n    if not user or not verify_password(form_data.password",
        "import:datetime.ip_address=None",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(...",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Update user password\n    user.hashed_password = hash_password(reset_confirm.new_password)\n    user.updated_at = datetime.now(timezone.utc)\n    \n    # Mark token as used\n    reset_token.used_at = datetime.now(timezone.utc)\n    \n    # Invalidate all user sessions for security\n    # Note: This would require session management implementation\n    \n    db.commit()\n    \n    logger.info(f\"Password successfully reset for user {user.email}\")\n    \n    return PasswordResetConfirmResponse(\n        message=\"Password has been successfully reset. You can now log in with your new password.\"\n    )",
        "import:datetime.user.full_name\n    )\n    \n    logger.info(f\"Password reset token generated for user {user.email}\")\n    \n    return PasswordResetResponse(\n        message=\"If an account with that email exists",
        "import:datetime.expires_at=datetime.utcnow() + access_token_expires",
        "import:datetime.datetime",
        "import:datetime.db):\n        raise HTTPException(\n            status_code=429",
        "import:datetime.token",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.hashed_password=hashed_password",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.ip_address=request.client.host if request.client else None\n    )\n    \n    db.add(reset_token)\n    db.commit()\n    \n    # Send email in background (Item 30.3: Create password reset email template)\n    background_tasks.add_task(\n        send_password_reset_email",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.email=new_user.email",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.expires_at=expires_at",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.user=user.to_dict()\n    )\n\n\n@router.get(\"/me\"",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.db: DBSession = Depends(get_db)):\n    \"\"\"\n    Logout user and invalidate session.\n    \n    Implements checklist item 5.7: User logout endpoint\n    \"\"\"\n    # Remove user session\n    db.query(UserSession).filter(UserSession.user_id == current_user.id).delete()\n    db.commit()\n    \n    logger.info(f\"User logged out: {current_user.username}\")\n    \n    return {\"message\": \"Successfully logged out\"}\n\n\n@router.post(\"/reset-password\"",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.detail=\"Username already registered\"\n        )\n    \n    # Check if email already exists\n    existing_email = db.query(User).filter(User.email == user_data.email).first()\n    if existing_email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.Depends",
        "import:datetime.detail=\"Incorrect username/email or password\"",
        "import:datetime.detail=f\"Too many password reset requests. Maximum {PASSWORD_RESET_RATE_LIMIT} requests per hour allowed.\"\n        )\n    \n    # Find user by email\n    user = db.query(User).filter(User.email == reset_request.email).first()\n    \n    if not user:\n        # For security",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(...",
        "import:datetime.response_model=PasswordResetResponse)\nasync def request_password_reset(\n    request: Request"
      ]
    },
    "GET:/google/authorize": {
      "method": "GET",
      "path": "/google/authorize",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 574,
      "dependencies": [
        "import:datetime.username=current_user.username",
        "import:datetime.SECRET_KEY",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.\"expires_at\": reset_token.expires_at.isoformat()",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n        )\n    \n    # Generate reset token\n    token = generate_reset_token()\n    expires_at = datetime.now(timezone.utc) + timedelta(hours=PASSWORD_RESET_TOKEN_EXPIRE_HOURS)\n    \n    # Invalidate any existing reset tokens for this user\n    db.query(PasswordResetToken).filter(\n        PasswordResetToken.user_id == user.id\n    ).delete()\n    \n    # Create new reset token\n    reset_token = PasswordResetToken(\n        user_id=user.id",
        "import:datetime.is_active=True",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.username=new_user.username",
        "import:datetime.\"email\": user.email",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n        )\n    \n    if not user.is_active:\n        # Don't allow password reset for inactive accounts\n        logger.warning(f\"Password reset requested for inactive user: {user.email}\")\n        return PasswordResetResponse(\n            message=\"If an account with that email exists",
        "import:datetime.UserSession",
        "import:datetime.email=current_user.email",
        "import:datetime.created_at=current_user.created_at.isoformat() if current_user.created_at else None\n    )\n\n\n@router.post(\"/logout\")\nasync def logout_user(current_user: User = Depends(get_current_user)",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Get user info (without sensitive data)\n    user = db.query(User).filter(User.id == reset_token.user_id).first()\n    \n    if not user or not user.is_active:\n        raise HTTPException(\n            status_code=400",
        "import:datetime.Request",
        "import:datetime.user.email",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.is_active=new_user.is_active",
        "import:datetime.response_model=UserProfile)\nasync def read_users_me(current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Get current user profile.\n    \n    Implements checklist item 5.7: User profile endpoint\n    \"\"\"\n    return UserProfile(\n        id=str(current_user.id)",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    return {\n        \"valid\": True",
        "import:datetime.email=user_data.email",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.token: str",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.reset_confirm: PasswordResetConfirm",
        "import:datetime.full_name=new_user.full_name",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.response_model=PasswordResetConfirmResponse)\nasync def confirm_password_reset(\n    request: Request",
        "import:datetime.\"time_remaining\": int((reset_token.expires_at - datetime.now(timezone.utc)).total_seconds())\n    }",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user account.\n    \n    Implements checklist item 5.7: User registration endpoint\n    \"\"\"\n    # Check if username already exists\n    existing_user = db.query(User).filter(User.username == user_data.username).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.token=token",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.# Could be extracted from request\n        user_agent=None   # Could be extracted from request\n    )\n    db.add(session)\n    db.commit()\n    \n    logger.info(f\"User logged in: {user.username}\")\n    \n    return Token(\n        access_token=access_token",
        "import:datetime.reset_request: PasswordResetRequest",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Confirm password reset and update user password.\n    \n    This endpoint completes the password reset flow by validating the token\n    and updating the user's password.\n    \"\"\"\n    \n    # Find the reset token\n    reset_token = db.query(PasswordResetToken).filter(\n        PasswordResetToken.token == reset_confirm.token\n    ).first()\n    \n    if not reset_token:\n        logger.warning(f\"Invalid reset token used: {reset_confirm.token[:8]}...\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.is_active=current_user.is_active",
        "import:datetime.max_length=255",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.is_verified=False  # Email verification would be implemented separately\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    logger.info(f\"New user registered: {new_user.username}\")\n    \n    return UserProfile(\n        id=str(new_user.id)",
        "import:datetime.)\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.background_tasks: BackgroundTasks",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Validate a password reset token without consuming it.\n    \n    This endpoint can be used by the frontend to check if a reset token\n    is valid before showing the password reset form.\n    \"\"\"\n    \n    reset_token = db.query(PasswordResetToken).filter(\n        PasswordResetToken.token == token\n    ).first()\n    \n    if not reset_token or not reset_token.is_valid():\n        raise HTTPException(\n            status_code=400",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "import:datetime.a password reset link has been sent.\"",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Request password reset for a user account.\n    \n    Implements checklist item 30.1: Create password reset endpoint /api/v1/auth/reset-password\n    Implements checklist item 30.2: Implement password reset token generation\n    Implements checklist item 30.6: Add rate limiting to password reset\n    \"\"\"\n    \n    # Check rate limiting\n    if not check_rate_limit(request",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.token_type=\"bearer\"",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "import:datetime.response_model=UserProfile)\nasync def register_user(\n    user_data: UserRegister",
        "import:datetime.detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    hashed_password = hash_password(user_data.password)\n    new_user = User(\n        username=user_data.username",
        "import:datetime.timedelta",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True\n\n\n@router.post(\"/register\"",
        "import:datetime.HTTPException",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.expires_delta=access_token_expires\n    )\n    \n    # Create user session\n    session = UserSession(\n        user_id=user.id",
        "import:datetime.response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends()",
        "import:datetime.BackgroundTasks",
        "import:datetime.min_length=8",
        "import:datetime.detail=\"Inactive user account\"\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Get the user\n    user = db.query(User).filter(User.id == reset_token.user_id).first()\n    \n    if not user or not user.is_active:\n        logger.error(f\"Reset token belongs to non-existent or inactive user: {reset_token.user_id}\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.created_at=new_user.created_at.isoformat() if new_user.created_at else None\n    )\n\n\n@router.post(\"/token\"",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.full_name=current_user.full_name",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Check if token is valid\n    if not reset_token.is_valid():\n        logger.warning(f\"Expired or used reset token: {reset_confirm.token[:8]}...\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n    )\n\n\n@router.post(\"/confirm-reset-password\"",
        "import:datetime.is_verified=current_user.is_verified",
        "import:datetime.full_name=user_data.full_name",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.always return success even if user doesn't exist\n        # This prevents email enumeration attacks\n        logger.info(f\"Password reset requested for non-existent email: {reset_request.email}\")\n        return PasswordResetResponse(\n            message=\"If an account with that email exists",
        "import:datetime.is_verified=new_user.is_verified",
        "import:datetime.session_token=access_token",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Authenticate user and return access token.\n    \n    Implements checklist item 5.7: User login endpoint\n    Implements checklist item 10.1: JWT authentication\n    \"\"\"\n    # Try to find user by username or email\n    user = db.query(User).filter(\n        (User.username == form_data.username) | (User.email == form_data.username)\n    ).first()\n    \n    if not user or not verify_password(form_data.password",
        "import:datetime.ip_address=None",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(...",
        "import:datetime.user.full_name\n    )\n    \n    logger.info(f\"Password reset token generated for user {user.email}\")\n    \n    return PasswordResetResponse(\n        message=\"If an account with that email exists",
        "import:datetime.expires_at=datetime.utcnow() + access_token_expires",
        "import:datetime.datetime",
        "import:datetime.db):\n        raise HTTPException(\n            status_code=429",
        "import:datetime.token",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.hashed_password=hashed_password",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.ip_address=request.client.host if request.client else None\n    )\n    \n    db.add(reset_token)\n    db.commit()\n    \n    # Send email in background (Item 30.3: Create password reset email template)\n    background_tasks.add_task(\n        send_password_reset_email",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.email=new_user.email",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.expires_at=expires_at",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "function:validate_reset_token",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.user=user.to_dict()\n    )\n\n\n@router.get(\"/me\"",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.db: DBSession = Depends(get_db)):\n    \"\"\"\n    Logout user and invalidate session.\n    \n    Implements checklist item 5.7: User logout endpoint\n    \"\"\"\n    # Remove user session\n    db.query(UserSession).filter(UserSession.user_id == current_user.id).delete()\n    db.commit()\n    \n    logger.info(f\"User logged out: {current_user.username}\")\n    \n    return {\"message\": \"Successfully logged out\"}\n\n\n@router.post(\"/reset-password\"",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.detail=\"Username already registered\"\n        )\n    \n    # Check if email already exists\n    existing_email = db.query(User).filter(User.email == user_data.email).first()\n    if existing_email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.Depends",
        "import:datetime.detail=\"Incorrect username/email or password\"",
        "import:datetime.detail=f\"Too many password reset requests. Maximum {PASSWORD_RESET_RATE_LIMIT} requests per hour allowed.\"\n        )\n    \n    # Find user by email\n    user = db.query(User).filter(User.email == reset_request.email).first()\n    \n    if not user:\n        # For security",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(...",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Update user password\n    user.hashed_password = hash_password(reset_confirm.new_password)\n    user.updated_at = datetime.now(timezone.utc)\n    \n    # Mark token as used\n    reset_token.used_at = datetime.now(timezone.utc)\n    \n    # Invalidate all user sessions for security\n    # Note: This would require session management implementation\n    \n    db.commit()\n    \n    logger.info(f\"Password successfully reset for user {user.email}\")\n    \n    return PasswordResetConfirmResponse(\n        message=\"Password has been successfully reset. You can now log in with your new password.\"\n    )\n\n\n@router.get(\"/reset-password/validate/{token}\")\nasync def validate_reset_token(\n    token: str",
        "import:datetime.response_model=PasswordResetResponse)\nasync def request_password_reset(\n    request: Request"
      ]
    },
    "POST:/google/callback": {
      "method": "POST",
      "path": "/google/callback",
      "file": "services/api-gateway/app/api/v1/auth.py",
      "line": 602,
      "dependencies": [
        "import:datetime.username=current_user.username",
        "import:datetime.SECRET_KEY",
        "import:datetime.Field\nfrom jose import JWTError",
        "import:datetime.\"expires_at\": reset_token.expires_at.isoformat()",
        "import:datetime.AWS SES",
        "import:datetime.headers={\"WWW-Authenticate\": \"Bearer\"}",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n        )\n    \n    # Generate reset token\n    token = generate_reset_token()\n    expires_at = datetime.now(timezone.utc) + timedelta(hours=PASSWORD_RESET_TOKEN_EXPIRE_HOURS)\n    \n    # Invalidate any existing reset tokens for this user\n    db.query(PasswordResetToken).filter(\n        PasswordResetToken.user_id == user.id\n    ).delete()\n    \n    # Create new reset token\n    reset_token = PasswordResetToken(\n        user_id=user.id",
        "import:datetime.is_active=True",
        "import:datetime.description=\"Username or email\")\n    password: str = Field(...",
        "import:datetime.expires_in=ACCESS_TOKEN_EXPIRE_MINUTES * 60",
        "import:datetime.description=\"Token type (bearer)\")\n    expires_in: int = Field(...",
        "import:datetime.username=new_user.username",
        "import:datetime.detail=\"Google OAuth not configured\"\n        )\n    \n    # Build Google OAuth authorization URL\n    params = {\n        'client_id': settings.GOOGLE_CLIENT_ID",
        "import:datetime.\"email\": user.email",
        "import:datetime.description=\"Token expiration time in seconds\")\n\n\nclass PasswordResetConfirmResponse(BaseModel):\n    \"\"\"Response model for password reset confirmation.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Token expiration time in seconds\")\n    user: dict = Field(...",
        "import:datetime.description=\"User ID\")\n    username: str = Field(...",
        "import:datetime.EmailStr",
        "import:datetime.description=\"Email address of the user\")\n\n\nclass PasswordResetConfirm(BaseModel):\n    \"\"\"Request model for password reset confirmation.\"\"\"\n    token: str = Field(...",
        "import:datetime.'scope': 'openid email profile'",
        "import:datetime.OAuth2PasswordRequestForm\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import and_\nfrom pydantic import BaseModel",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n        )\n    \n    if not user.is_active:\n        # Don't allow password reset for inactive accounts\n        logger.warning(f\"Password reset requested for inactive user: {user.email}\")\n        return PasswordResetResponse(\n            message=\"If an account with that email exists",
        "import:datetime.UserSession",
        "import:datetime.email=current_user.email",
        "import:datetime.created_at=current_user.created_at.isoformat() if current_user.created_at else None\n    )\n\n\n@router.post(\"/logout\")\nasync def logout_user(current_user: User = Depends(get_current_user)",
        "import:datetime.deprecated=\"auto\")\n\n# OAuth2 scheme for token endpoint\noauth2_scheme = OAuth2PasswordBearer(tokenUrl=\"/api/v1/auth/token\")\n\n# Password reset configuration\nPASSWORD_RESET_TOKEN_EXPIRE_HOURS = 1  # 1 hour\nPASSWORD_RESET_RATE_LIMIT = 3  # Max 3 requests per hour per IP\n\n\nclass PasswordResetRequest(BaseModel):\n    \"\"\"Request model for password reset.\"\"\"\n    email: EmailStr = Field(...",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Get user info (without sensitive data)\n    user = db.query(User).filter(User.id == reset_token.user_id).first()\n    \n    if not user or not user.is_active:\n        raise HTTPException(\n            status_code=400",
        "import:datetime.Request",
        "import:datetime.user.email",
        "import:datetime.click the link below:\n    {reset_url}\n    \n    This link will expire in {PASSWORD_RESET_TOKEN_EXPIRE_HOURS} hour(s).\n    \n    If you didn't request this password reset",
        "import:datetime.is_active=new_user.is_active",
        "import:datetime.response_model=UserProfile)\nasync def read_users_me(current_user: User = Depends(get_current_user)):\n    \"\"\"\n    Get current user profile.\n    \n    Implements checklist item 5.7: User profile endpoint\n    \"\"\"\n    return UserProfile(\n        id=str(current_user.id)",
        "import:datetime.description=\"Password reset token\")\n    new_password: str = Field(...",
        "import:datetime.description=\"Full name\")\n    password: str = Field(...",
        "import:datetime.PasswordResetToken",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    return {\n        \"valid\": True",
        "import:datetime.email=user_data.email",
        "import:datetime.min_length=2",
        "import:datetime.description=\"Account creation date\")\n\n\nclass GoogleOAuthRequest(BaseModel):\n    \"\"\"Request model for Google OAuth login.\"\"\"\n    code: str = Field(...",
        "import:datetime.token: str",
        "import:datetime.The OpenPolicy Team\n    \n    ---\n    This is an automated message. Please do not reply to this email.\n    For support",
        "import:datetime.hashed_password: str) -> bool:\n    \"\"\"Verify a password against its hash.\"\"\"\n    return pwd_context.verify(plain_password",
        "import:datetime.reset_confirm: PasswordResetConfirm",
        "import:datetime.full_name=new_user.full_name",
        "import:datetime.description=\"Full name\")\n    is_active: bool = Field(...",
        "import:datetime.please ignore this email.\n    Your password will remain unchanged.\n    \n    For security reasons",
        "import:datetime.response_model=PasswordResetConfirmResponse)\nasync def confirm_password_reset(\n    request: Request",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Register a new user account.\n    \n    Implements checklist item 5.7: User registration endpoint\n    \"\"\"\n    # Check if username already exists\n    existing_user = db.query(User).filter(User.username == user_data.username).first()\n    if existing_user:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.token=token",
        "import:datetime.description=\"Account active status\")\n    is_verified: bool = Field(...",
        "import:datetime.description=\"Password (minimum 8 characters)\")\n\n\nclass Token(BaseModel):\n    \"\"\"Response model for authentication token.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.user.hashed_password):\n        raise HTTPException(\n            status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.# Could be extracted from request\n        user_agent=None   # Could be extracted from request\n    )\n    db.add(session)\n    db.commit()\n    \n    logger.info(f\"User logged in: {user.username}\")\n    \n    return Token(\n        access_token=access_token",
        "import:datetime.reset_request: PasswordResetRequest",
        "import:datetime.jwt\nfrom passlib.context import CryptContext\nfrom app.database import get_db\nfrom app.models.users import User",
        "import:datetime.user_name: str):\n    \"\"\"\n    Send password reset email to user.\n    \n    This is a placeholder implementation - in production would use\n    email service like SendGrid",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Confirm password reset and update user password.\n    \n    This endpoint completes the password reset flow by validating the token\n    and updating the user's password.\n    \"\"\"\n    \n    # Find the reset token\n    reset_token = db.query(PasswordResetToken).filter(\n        PasswordResetToken.token == reset_confirm.token\n    ).first()\n    \n    if not reset_token:\n        logger.warning(f\"Invalid reset token used: {reset_confirm.token[:8]}...\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.is_active=current_user.is_active",
        "import:datetime.max_length=255",
        "import:datetime.OAuthAccount\nfrom app.config import settings\nimport logging\nimport requests\nfrom urllib.parse import urlencode\n\n# Configure logging\nlogger = logging.getLogger(__name__)\n\nrouter = APIRouter()\nsecurity = HTTPBearer()\n\n# JWT Configuration\nSECRET_KEY = settings.SECRET_KEY\nALGORITHM = settings.ALGORITHM\nACCESS_TOKEN_EXPIRE_MINUTES = settings.ACCESS_TOKEN_EXPIRE_MINUTES\n\n# Password hashing\npwd_context = CryptContext(schemes=[\"bcrypt\"]",
        "import:datetime.timezone\nfrom typing import Optional\nfrom fastapi import APIRouter",
        "import:datetime.is_verified=False  # Email verification would be implemented separately\n    )\n    \n    db.add(new_user)\n    db.commit()\n    db.refresh(new_user)\n    \n    logger.info(f\"New user registered: {new_user.username}\")\n    \n    return UserProfile(\n        id=str(new_user.id)",
        "import:datetime.)\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.background_tasks: BackgroundTasks",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Validate a password reset token without consuming it.\n    \n    This endpoint can be used by the frontend to check if a reset token\n    is valid before showing the password reset form.\n    \"\"\"\n    \n    reset_token = db.query(PasswordResetToken).filter(\n        PasswordResetToken.token == token\n    ).first()\n    \n    if not reset_token or not reset_token.is_valid():\n        raise HTTPException(\n            status_code=400",
        "import:datetime.description=\"Email verification status\")\n    created_at: str = Field(...",
        "import:datetime.a password reset link has been sent.\"",
        "import:datetime.expires_delta: Optional[timedelta] = None) -> str:\n    \"\"\"Create a JWT access token.\"\"\"\n    to_encode = data.copy()\n    if expires_delta:\n        expire = datetime.utcnow() + expires_delta\n    else:\n        expire = datetime.utcnow() + timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    \n    to_encode.update({\"exp\": expire})\n    encoded_jwt = jwt.encode(to_encode",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Request password reset for a user account.\n    \n    Implements checklist item 30.1: Create password reset endpoint /api/v1/auth/reset-password\n    Implements checklist item 30.2: Implement password reset token generation\n    Implements checklist item 30.6: Add rate limiting to password reset\n    \"\"\"\n    \n    # Check rate limiting\n    if not check_rate_limit(request",
        "function:google_oauth_authorize",
        "import:datetime.db: DBSession) -> bool:\n    \"\"\"\n    Check rate limiting for password reset requests.\n    \n    Implements Item 30.6: Add rate limiting to password reset.\n    \"\"\"\n    client_ip = request.client.host if request.client else \"unknown\"\n    \n    # Check how many reset requests from this IP in the last hour\n    one_hour_ago = datetime.now(timezone.utc) - timedelta(hours=1)\n    \n    recent_requests = db.query(PasswordResetToken).filter(\n        and_(\n            PasswordResetToken.ip_address == client_ip",
        "import:datetime.'redirect_uri': settings.GOOGLE_REDIRECT_URI",
        "import:datetime.token_type=\"bearer\"",
        "import:datetime.detail=\"Inactive user\"\n        )\n    \n    return user\n\n\ndef send_password_reset_email(email: str",
        "import:datetime.status\nfrom fastapi.security import HTTPBearer",
        "import:datetime.'access_type': 'offline'",
        "import:datetime.response_model=UserProfile)\nasync def register_user(\n    user_data: UserRegister",
        "import:datetime.detail=\"Email already registered\"\n        )\n    \n    # Create new user\n    hashed_password = hash_password(user_data.password)\n    new_user = User(\n        username=user_data.username",
        "import:datetime.timedelta",
        "import:datetime.PasswordResetToken.created_at >= one_hour_ago\n        )\n    ).count()\n    \n    if recent_requests >= PASSWORD_RESET_RATE_LIMIT:\n        logger.warning(f\"Rate limit exceeded for IP {client_ip}: {recent_requests} requests in last hour\")\n        return False\n    \n    return True\n\n\n@router.post(\"/register\"",
        "import:datetime.HTTPException",
        "import:datetime.description=\"User information\")\n    oauth_provider: str = Field(...",
        "import:datetime.expires_delta=access_token_expires\n    )\n    \n    # Create user session\n    session = UserSession(\n        user_id=user.id",
        "import:datetime.response_model=Token)\nasync def login_for_access_token(\n    form_data: OAuth2PasswordRequestForm = Depends()",
        "import:datetime.BackgroundTasks",
        "import:datetime.min_length=8",
        "import:datetime.detail=\"Inactive user account\"\n        )\n    \n    # Create access token\n    access_token_expires = timedelta(minutes=ACCESS_TOKEN_EXPIRE_MINUTES)\n    access_token = create_access_token(\n        data={\"sub\": user.username}",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Get the user\n    user = db.query(User).filter(User.id == reset_token.user_id).first()\n    \n    if not user or not user.is_active:\n        logger.error(f\"Reset token belongs to non-existent or inactive user: {reset_token.user_id}\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.\"time_remaining\": int((reset_token.expires_at - datetime.now(timezone.utc)).total_seconds())\n    }\n\n\n@router.get(\"/google/authorize\")\nasync def google_oauth_authorize():\n    \"\"\"\n    Redirect user to Google OAuth authorization page.\n    \n    Implements BUG-002: OAuth Integration (Google OAuth backend)\n    \"\"\"\n    if not settings.GOOGLE_CLIENT_ID:\n        raise HTTPException(\n            status_code=status.HTTP_501_NOT_IMPLEMENTED",
        "import:datetime.or SMTP server.\n    \"\"\"\n    reset_url = f\"https://openpolicy.ca/reset-password?token={token}\"\n    \n    # Email template (Item 30.3)\n    email_template = f\"\"\"\n    Subject: Reset Your OpenPolicy Account Password\n    \n    Hello {user_name}",
        "import:datetime.created_at=new_user.created_at.isoformat() if new_user.created_at else None\n    )\n\n\n@router.post(\"/token\"",
        "import:datetime.description=\"Success message\")\n    expires_in: int = Field(...",
        "import:datetime.max_length=50",
        "import:datetime.full_name=current_user.full_name",
        "import:datetime.)\n    \n    try:\n        payload = jwt.decode(token",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Check if token is valid\n    if not reset_token.is_valid():\n        logger.warning(f\"Expired or used reset token: {reset_confirm.token[:8]}...\")\n        raise HTTPException(\n            status_code=400",
        "import:datetime.description=\"JWT access token\")\n    token_type: str = Field(...",
        "import:datetime.expires_in=PASSWORD_RESET_TOKEN_EXPIRE_HOURS * 3600\n    )\n\n\n@router.post(\"/confirm-reset-password\"",
        "import:datetime.is_verified=current_user.is_verified",
        "import:datetime.full_name=user_data.full_name",
        "import:datetime.algorithms=[ALGORITHM])\n        return payload\n    except JWTError:\n        return None\n\n\nasync def get_current_user(token: str = Depends(oauth2_scheme)",
        "import:datetime.always return success even if user doesn't exist\n        # This prevents email enumeration attacks\n        logger.info(f\"Password reset requested for non-existent email: {reset_request.email}\")\n        return PasswordResetResponse(\n            message=\"If an account with that email exists",
        "import:datetime.is_verified=new_user.is_verified",
        "import:datetime.session_token=access_token",
        "import:datetime.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Authenticate user and return access token.\n    \n    Implements checklist item 5.7: User login endpoint\n    Implements checklist item 10.1: JWT authentication\n    \"\"\"\n    # Try to find user by username or email\n    user = db.query(User).filter(\n        (User.username == form_data.username) | (User.email == form_data.username)\n    ).first()\n    \n    if not user or not verify_password(form_data.password",
        "import:datetime.ip_address=None",
        "import:datetime.'prompt': 'consent'\n    }\n    \n    auth_url = f\"{settings.GOOGLE_AUTHORIZATION_URL}?{urlencode(params)}\"\n    \n    return {\"authorization_url\": auth_url}",
        "import:datetime.description=\"Email address\")\n    full_name: str = Field(...",
        "import:datetime.user.full_name\n    )\n    \n    logger.info(f\"Password reset token generated for user {user.email}\")\n    \n    return PasswordResetResponse(\n        message=\"If an account with that email exists",
        "import:datetime.expires_at=datetime.utcnow() + access_token_expires",
        "import:datetime.datetime",
        "import:datetime.db):\n        raise HTTPException(\n            status_code=429",
        "import:datetime.token",
        "import:datetime.algorithm=ALGORITHM)\n    return encoded_jwt\n\n\ndef verify_token(token: str) -> Optional[dict]:\n    \"\"\"Verify and decode a JWT token.\"\"\"\n    try:\n        payload = jwt.decode(token",
        "import:datetime.hashed_password=hashed_password",
        "import:datetime.contact us at support@openpolicy.ca\n    \"\"\"\n    \n    # In production",
        "import:datetime.ip_address=request.client.host if request.client else None\n    )\n    \n    db.add(reset_token)\n    db.commit()\n    \n    # Send email in background (Item 30.3: Create password reset email template)\n    background_tasks.add_task(\n        send_password_reset_email",
        "import:datetime.OAuth2PasswordBearer",
        "import:datetime.description=\"New password (minimum 8 characters)\")\n\n\nclass PasswordResetResponse(BaseModel):\n    \"\"\"Response model for password reset request.\"\"\"\n    message: str = Field(...",
        "import:datetime.description=\"Username (3-50 characters)\")\n    email: EmailStr = Field(...",
        "import:datetime.db: DBSession = Depends(get_db)) -> User:\n    \"\"\"Get the current authenticated user from JWT token.\"\"\"\n    credentials_exception = HTTPException(\n        status_code=status.HTTP_401_UNAUTHORIZED",
        "import:datetime.email=new_user.email",
        "import:datetime.this would send the actual email\n    logger.info(f\"Password reset email would be sent to {email}\")\n    logger.info(f\"Reset URL: {reset_url}\")\n    logger.info(f\"Email content: {email_template}\")\n\n\ndef check_rate_limit(request: Request",
        "import:datetime.expires_at=expires_at",
        "import:datetime.hashed_password)\n\n\ndef create_access_token(data: dict",
        "import:datetime.description=\"User information\")\n\n\nclass UserProfile(BaseModel):\n    \"\"\"Response model for user profile.\"\"\"\n    id: str = Field(...",
        "import:datetime.detail=\"Could not validate credentials\"",
        "import:datetime.description=\"OAuth provider (google)\")\n    message: str = Field(...",
        "import:datetime.description=\"Success message\")\n\n\ndef generate_reset_token() -> str:\n    \"\"\"Generate a secure password reset token.\"\"\"\n    # Generate a random token using secrets module for cryptographic security\n    token = secrets.token_urlsafe(32)\n    return token\n\n\ndef hash_password(password: str) -> str:\n    \"\"\"Hash a password using bcrypt for security.\"\"\"\n    return pwd_context.hash(password)\n\n\ndef verify_password(plain_password: str",
        "import:datetime.min_length=3",
        "import:datetime.user=user.to_dict()\n    )\n\n\n@router.get(\"/me\"",
        "import:datetime.algorithms=[ALGORITHM])\n        username: str = payload.get(\"sub\")\n        if username is None:\n            raise credentials_exception\n    except JWTError:\n        raise credentials_exception\n    \n    user = db.query(User).filter(User.username == username).first()\n    if user is None:\n        raise credentials_exception\n    \n    if not user.is_active:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.description=\"User password\")\n\n\nclass UserRegister(BaseModel):\n    \"\"\"Request model for user registration.\"\"\"\n    username: str = Field(...",
        "import:datetime.this link can only be used once.\n    \n    Best regards",
        "import:datetime.description=\"Username\")\n    email: str = Field(...",
        "import:datetime.We received a request to reset your password for your OpenPolicy account.\n    \n    To reset your password",
        "import:datetime.db: DBSession = Depends(get_db)):\n    \"\"\"\n    Logout user and invalidate session.\n    \n    Implements checklist item 5.7: User logout endpoint\n    \"\"\"\n    # Remove user session\n    db.query(UserSession).filter(UserSession.user_id == current_user.id).delete()\n    db.commit()\n    \n    logger.info(f\"User logged out: {current_user.username}\")\n    \n    return {\"message\": \"Successfully logged out\"}\n\n\n@router.post(\"/reset-password\"",
        "import:datetime.description=\"Authorization code from Google\")\n\n\nclass GoogleOAuthResponse(BaseModel):\n    \"\"\"Response model for Google OAuth login.\"\"\"\n    access_token: str = Field(...",
        "import:datetime.'response_type': 'code'",
        "import:datetime.detail=\"Username already registered\"\n        )\n    \n    # Check if email already exists\n    existing_email = db.query(User).filter(User.email == user_data.email).first()\n    if existing_email:\n        raise HTTPException(\n            status_code=status.HTTP_400_BAD_REQUEST",
        "import:datetime.Depends",
        "import:datetime.detail=\"Incorrect username/email or password\"",
        "import:datetime.detail=f\"Too many password reset requests. Maximum {PASSWORD_RESET_RATE_LIMIT} requests per hour allowed.\"\n        )\n    \n    # Find user by email\n    user = db.query(User).filter(User.email == reset_request.email).first()\n    \n    if not user:\n        # For security",
        "import:datetime.description=\"Success message\")\n\n\nclass UserLogin(BaseModel):\n    \"\"\"Request model for user login.\"\"\"\n    username: str = Field(...",
        "import:datetime.detail=\"Invalid or expired reset token.\"\n        )\n    \n    # Update user password\n    user.hashed_password = hash_password(reset_confirm.new_password)\n    user.updated_at = datetime.now(timezone.utc)\n    \n    # Mark token as used\n    reset_token.used_at = datetime.now(timezone.utc)\n    \n    # Invalidate all user sessions for security\n    # Note: This would require session management implementation\n    \n    db.commit()\n    \n    logger.info(f\"Password successfully reset for user {user.email}\")\n    \n    return PasswordResetConfirmResponse(\n        message=\"Password has been successfully reset. You can now log in with your new password.\"\n    )\n\n\n@router.get(\"/reset-password/validate/{token}\")\nasync def validate_reset_token(\n    token: str",
        "import:datetime.response_model=PasswordResetResponse)\nasync def request_password_reset(\n    request: Request"
      ]
    },
    "GET:/get-bill": {
      "method": "GET",
      "path": "/get-bill",
      "file": "services/api-gateway/app/api/v1/chat.py",
      "line": 18,
      "dependencies": [
        "import:fastapi.Riding\n\nrouter = APIRouter()",
        "import:fastapi.Party",
        "import:fastapi.Any",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Depends",
        "import:fastapi.Dict",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.VoteQuestion",
        "import:fastapi.APIRouter",
        "import:fastapi.Politician",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/get-issue": {
      "method": "GET",
      "path": "/get-issue",
      "file": "services/api-gateway/app/api/v1/chat.py",
      "line": 75,
      "dependencies": [
        "import:fastapi.\"introduced_date\": bill.introduced",
        "import:fastapi.this would come from the database\n    bill_data = {\n        \"id\": str(bill.id)",
        "import:fastapi.\"key_topics\": [\n            \"policy implementation\"",
        "import:fastapi.\"public interest\"",
        "import:fastapi.'is_government_bill') else True",
        "import:fastapi.\"sponsor\": {\n            \"name\": \"Hon. Member\"",
        "import:fastapi.\"regulatory framework\"",
        "import:fastapi.\"related_issues\": [\n            \"economic development\"",
        "import:fastapi.\"party\": \"Government\"",
        "import:fastapi.\"chat_context\": {\n            \"bill_type\": \"legislation\"",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.\"bill_number\": bill.number",
        "function:get_bill_for_chat",
        "import:fastapi.\"data\": bill_data",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"public safety\"\n        ]",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"environmental protection\"",
        "import:fastapi.\"social welfare\"",
        "import:fastapi.Politician",
        "import:fastapi.\"complexity_level\": \"moderate\"",
        "import:fastapi.\"short_title\": bill.short_title_en",
        "import:fastapi.Any",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/get-bill\")\nasync def get_bill_for_chat(\n    bill_number: str",
        "import:fastapi.Depends",
        "import:fastapi.VoteQuestion",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill information for AI chat context.\n    Provides bill summary and context for chat interactions.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.number == bill_number).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"summary\": f\"Bill {bill.number}: {bill.name_en}. This bill addresses {bill.short_title_en} and is currently in {bill.status_code} status.\"",
        "import:fastapi.\"controversy_level\": \"low\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.Party",
        "import:fastapi.\"government oversight\"\n        ]",
        "import:fastapi.\"public_interest\": \"high\"",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Dict",
        "import:fastapi.\"is_government_bill\": bill.is_government_bill if hasattr(bill",
        "import:fastapi.\"message\": \"Bill information retrieved successfully for chat\"\n    }",
        "import:fastapi.create mock bill data for chat\n    # In a full implementation",
        "import:fastapi.APIRouter",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"constituency\": \"Unknown\"\n        }"
      ]
    },
    "POST:/bill-chat": {
      "method": "POST",
      "path": "/bill-chat",
      "file": "services/api-gateway/app/api/v1/chat.py",
      "line": 110,
      "dependencies": [
        "import:fastapi.\"summary\": \"This is a sample issue for demonstration purposes.\"",
        "import:fastapi.\"chat_context\": {\n            \"issue_type\": \"policy_concern\"",
        "import:fastapi.\"data\": issue_data",
        "import:fastapi.\"category\": \"policy\"",
        "import:fastapi.\"introduced_date\": bill.introduced",
        "import:fastapi.this would come from the database\n    bill_data = {\n        \"id\": str(bill.id)",
        "import:fastapi.\"key_topics\": [\n            \"policy implementation\"",
        "import:fastapi.\"public interest\"",
        "import:fastapi.\"name\": \"Sample Issue\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issue information for AI chat context.\n    Provides issue details and context for chat interactions.\n    \"\"\"\n    # For now",
        "import:fastapi.'is_government_bill') else True",
        "import:fastapi.\"sponsor\": {\n            \"name\": \"Hon. Member\"",
        "import:fastapi.\"regulatory framework\"",
        "import:fastapi.\"related_issues\": [\n            \"economic development\"",
        "import:fastapi.\"status\": \"active\"",
        "function:get_issue_for_chat",
        "import:fastapi.\"party\": \"Government\"",
        "import:fastapi.\"chat_context\": {\n            \"bill_type\": \"legislation\"",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.this would come from the database\n    issue_data = {\n        \"id\": issue_id",
        "import:fastapi.\"data\": bill_data",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"public safety\"\n        ]",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"environmental protection\"",
        "import:fastapi.\"social welfare\"",
        "import:fastapi.Politician",
        "import:fastapi.\"complexity_level\": \"moderate\"",
        "import:fastapi.\"message\": \"Bill information retrieved successfully for chat\"\n    }\n\n\n@router.get(\"/get-issue\")\nasync def get_issue_for_chat(\n    issue_id: str",
        "import:fastapi.\"short_title\": bill.short_title_en",
        "import:fastapi.Any",
        "import:fastapi.\"created_date\": datetime.utcnow().isoformat()",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/get-bill\")\nasync def get_bill_for_chat(\n    bill_number: str",
        "import:fastapi.Depends",
        "import:fastapi.VoteQuestion",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill information for AI chat context.\n    Provides bill summary and context for chat interactions.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.number == bill_number).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"summary\": f\"Bill {bill.number}: {bill.name_en}. This bill addresses {bill.short_title_en} and is currently in {bill.status_code} status.\"",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"controversy_level\": \"low\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"description\": \"Detailed description of the issue and its implications.\"",
        "import:fastapi.Party",
        "import:fastapi.\"government oversight\"\n        ]",
        "import:fastapi.\"message\": \"Issue information retrieved successfully for chat\"\n    }",
        "import:fastapi.\"public_interest\": \"medium\"",
        "import:fastapi.\"public_interest\": \"high\"",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.Dict",
        "import:fastapi.\"is_government_bill\": bill.is_government_bill if hasattr(bill",
        "import:fastapi.create mock bill data for chat\n    # In a full implementation",
        "import:fastapi.APIRouter",
        "import:fastapi.\"resolution_urgency\": \"normal\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.create mock issue data\n    # In a full implementation",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"constituency\": \"Unknown\"\n        }"
      ]
    },
    "POST:/issue-chat": {
      "method": "POST",
      "path": "/issue-chat",
      "file": "services/api-gateway/app/api/v1/chat.py",
      "line": 155,
      "dependencies": [
        "import:fastapi.\"summary\": \"This is a sample issue for demonstration purposes.\"",
        "import:fastapi.\"chat_metadata\": {\n            \"timestamp\": datetime.utcnow().isoformat()",
        "import:fastapi.\"chat_context\": {\n            \"issue_type\": \"policy_concern\"",
        "import:fastapi.\"data\": issue_data",
        "import:fastapi.\"category\": \"policy\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    bill_number = chat_data[\"bill_number\"]\n    summary = chat_data[\"summary\"]\n    instruction = chat_data[\"instruction\"]\n    \n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.number == bill_number).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"introduced_date\": bill.introduced",
        "import:fastapi.this would come from the database\n    bill_data = {\n        \"id\": str(bill.id)",
        "import:fastapi.\"key_topics\": [\n            \"policy implementation\"",
        "import:fastapi.\"public interest\"",
        "import:fastapi.\"user_instruction\"]\n        }\n    }",
        "import:fastapi.\"name\": \"Sample Issue\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issue information for AI chat context.\n    Provides issue details and context for chat interactions.\n    \"\"\"\n    # For now",
        "import:fastapi.'is_government_bill') else True",
        "import:fastapi.\"sponsor\": {\n            \"name\": \"Hon. Member\"",
        "import:fastapi.\"regulatory framework\"",
        "import:fastapi.\"related_issues\": [\n            \"economic development\"",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"party\": \"Government\"",
        "import:fastapi.\"bill_status\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Process AI chat interactions for bills.\n    Users can ask questions about bills and get contextual responses.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_number\"",
        "import:fastapi.\"chat_context\": {\n            \"bill_type\": \"legislation\"",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.\"summary\"",
        "import:fastapi.this would come from the database\n    issue_data = {\n        \"id\": issue_id",
        "import:fastapi.\"data\": bill_data",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"public safety\"\n        ]",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"environmental protection\"",
        "import:fastapi.\"instruction\"]\n    for field in required_fields:\n        if field not in chat_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"social welfare\"",
        "import:fastapi.Politician",
        "import:fastapi.\"message\": \"Issue information retrieved successfully for chat\"\n    }\n\n\n@router.post(\"/bill-chat\")\nasync def bill_chat(\n    chat_data: Dict[str",
        "import:fastapi.\"complexity_level\": \"moderate\"",
        "import:fastapi.\"message\": \"Bill information retrieved successfully for chat\"\n    }\n\n\n@router.get(\"/get-issue\")\nasync def get_issue_for_chat(\n    issue_id: str",
        "import:fastapi.create mock AI responses\n    # In a full implementation",
        "import:fastapi.\"context_used\": [\"bill_summary\"",
        "import:fastapi.\"short_title\": bill.short_title_en",
        "import:fastapi.instruction)\n    \n    return {\n        \"success\": True",
        "import:fastapi.this would integrate with an AI service\n    ai_response = generate_bill_chat_response(bill_number",
        "function:bill_chat",
        "import:fastapi.Any",
        "import:fastapi.\"created_date\": datetime.utcnow().isoformat()",
        "import:fastapi.summary",
        "import:fastapi.\"instruction_type\": classify_instruction(instruction)",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/get-bill\")\nasync def get_bill_for_chat(\n    bill_number: str",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.VoteQuestion",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill information for AI chat context.\n    Provides bill summary and context for chat interactions.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.number == bill_number).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"response\": ai_response",
        "import:fastapi.\"summary\": f\"Bill {bill.number}: {bill.name_en}. This bill addresses {bill.short_title_en} and is currently in {bill.status_code} status.\"",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"response_length\": len(ai_response)",
        "import:fastapi.\"controversy_level\": \"low\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"description\": \"Detailed description of the issue and its implications.\"",
        "import:fastapi.Party",
        "import:fastapi.\"status\": bill.status_code\n        }",
        "import:fastapi.\"government oversight\"\n        ]",
        "import:fastapi.\"public_interest\": \"medium\"",
        "import:fastapi.\"public_interest\": \"high\"",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.\"bill_info\": {\n            \"number\": bill_number",
        "import:fastapi.Dict",
        "import:fastapi.\"is_government_bill\": bill.is_government_bill if hasattr(bill",
        "import:fastapi.create mock bill data for chat\n    # In a full implementation",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Chat data\")",
        "import:fastapi.\"resolution_urgency\": \"normal\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.create mock issue data\n    # In a full implementation",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"constituency\": \"Unknown\"\n        }"
      ]
    },
    "GET:/chat-suggestions": {
      "method": "GET",
      "path": "/chat-suggestions",
      "file": "services/api-gateway/app/api/v1/chat.py",
      "line": 195,
      "dependencies": [
        "import:fastapi.\"chat_metadata\": {\n            \"timestamp\": datetime.utcnow().isoformat()",
        "import:fastapi.\"name\": \"Sample Issue\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issue information for AI chat context.\n    Provides issue details and context for chat interactions.\n    \"\"\"\n    # For now",
        "import:fastapi.\"related_issues\": [\n            \"economic development\"",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.\"instruction\"]\n    for field in required_fields:\n        if field not in chat_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"environmental protection\"",
        "import:fastapi.Politician",
        "import:fastapi.instruction)\n    \n    return {\n        \"success\": True",
        "import:fastapi.this would integrate with an AI service\n    ai_response = generate_bill_chat_response(bill_number",
        "import:fastapi.\"controversy_level\": \"low\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"description\": \"Detailed description of the issue and its implications.\"",
        "function:issue_chat",
        "import:fastapi.\"status\": bill.status_code\n        }",
        "import:fastapi.\"public_interest\": \"high\"",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.create mock bill data for chat\n    # In a full implementation",
        "import:fastapi.description=\"Chat data\")",
        "import:fastapi.\"resolution_urgency\": \"normal\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Process AI chat interactions for issues.\n    Users can ask questions about issues and get contextual responses.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"issue_id\"",
        "import:fastapi.HTTPException",
        "import:fastapi.\"constituency\": \"Unknown\"\n        }",
        "import:fastapi.\"introduced_date\": bill.introduced",
        "import:fastapi.\"key_topics\": [\n            \"policy implementation\"",
        "import:fastapi.\"regulatory framework\"",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"bill_status\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Process AI chat interactions for bills.\n    Users can ask questions about bills and get contextual responses.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_number\"",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.\"message\": \"Issue information retrieved successfully for chat\"\n    }\n\n\n@router.post(\"/bill-chat\")\nasync def bill_chat(\n    chat_data: Dict[str",
        "import:fastapi.\"context_used\": [\"bill_summary\"",
        "import:fastapi.\"created_date\": datetime.utcnow().isoformat()",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/get-bill\")\nasync def get_bill_for_chat(\n    bill_number: str",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    issue_id = chat_data[\"issue_id\"]\n    summary = chat_data[\"summary\"]\n    instruction = chat_data[\"instruction\"]\n    \n    # For now",
        "import:fastapi.Party",
        "import:fastapi.\"is_government_bill\": bill.is_government_bill if hasattr(bill",
        "import:fastapi.create mock issue data\n    # In a full implementation",
        "import:fastapi.\"summary\": \"This is a sample issue for demonstration purposes.\"",
        "import:fastapi.\"chat_context\": {\n            \"issue_type\": \"policy_concern\"",
        "import:fastapi.\"user_instruction\"]\n        }\n    }\n\n\n@router.post(\"/issue-chat\")\nasync def issue_chat(\n    chat_data: Dict[str",
        "import:fastapi.\"category\": \"policy\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    bill_number = chat_data[\"bill_number\"]\n    summary = chat_data[\"summary\"]\n    instruction = chat_data[\"instruction\"]\n    \n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.number == bill_number).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"user_instruction\"]\n        }\n    }",
        "import:fastapi.\"public interest\"",
        "import:fastapi.'is_government_bill') else True",
        "import:fastapi.\"data\": bill_data",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.create mock AI responses\n    # In a full implementation",
        "import:fastapi.\"complexity_level\": \"moderate\"",
        "import:fastapi.\"message\": \"Bill information retrieved successfully for chat\"\n    }\n\n\n@router.get(\"/get-issue\")\nasync def get_issue_for_chat(\n    issue_id: str",
        "import:fastapi.\"short_title\": bill.short_title_en",
        "import:fastapi.\"status\": \"active\"\n        }",
        "import:fastapi.Any",
        "import:fastapi.summary",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill information for AI chat context.\n    Provides bill summary and context for chat interactions.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.number == bill_number).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"response\": ai_response",
        "import:fastapi.\"summary\": f\"Bill {bill.number}: {bill.name_en}. This bill addresses {bill.short_title_en} and is currently in {bill.status_code} status.\"",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"bill_info\": {\n            \"number\": bill_number",
        "import:fastapi.\"data\": issue_data",
        "import:fastapi.this would come from the database\n    bill_data = {\n        \"id\": str(bill.id)",
        "import:fastapi.\"sponsor\": {\n            \"name\": \"Hon. Member\"",
        "import:fastapi.\"party\": \"Government\"",
        "import:fastapi.\"chat_context\": {\n            \"bill_type\": \"legislation\"",
        "import:fastapi.\"summary\"",
        "import:fastapi.this would come from the database\n    issue_data = {\n        \"id\": issue_id",
        "import:fastapi.\"public safety\"\n        ]",
        "import:fastapi.\"social welfare\"",
        "import:fastapi.\"context_used\": [\"issue_summary\"",
        "import:fastapi.\"instruction_type\": classify_instruction(instruction)",
        "import:fastapi.VoteQuestion",
        "import:fastapi.this would integrate with an AI service\n    ai_response = generate_issue_chat_response(issue_id",
        "import:fastapi.\"issue_status\"",
        "import:fastapi.\"government oversight\"\n        ]",
        "import:fastapi.\"issue_info\": {\n            \"id\": issue_id",
        "import:fastapi.\"public_interest\": \"medium\"",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"response_length\": len(ai_response)",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/chat-history": {
      "method": "GET",
      "path": "/chat-history",
      "file": "services/api-gateway/app/api/v1/chat.py",
      "line": 228,
      "dependencies": [
        "import:fastapi.\"chat_metadata\": {\n            \"timestamp\": datetime.utcnow().isoformat()",
        "import:fastapi.user_role)\n        context = \"issue\"\n    else:\n        # General suggestions\n        suggestions = generate_general_chat_suggestions(user_role)\n        context = \"general\"\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"name\": \"Sample Issue\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get issue information for AI chat context.\n    Provides issue details and context for chat interactions.\n    \"\"\"\n    # For now",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get contextual chat suggestions for bills or issues.\n    Provides role-based and context-aware suggestions.\n    \"\"\"\n    if bill_number:\n        # Bill-specific suggestions\n        suggestions = generate_bill_chat_suggestions(bill_number",
        "import:fastapi.\"related_issues\": [\n            \"economic development\"",
        "import:fastapi.issue_id: Optional[str] = None",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.\"instruction\"]\n    for field in required_fields:\n        if field not in chat_data:\n            raise HTTPException(status_code=400",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"environmental protection\"",
        "import:fastapi.Politician",
        "import:fastapi.\"user_instruction\"]\n        }\n    }\n\n\n@router.get(\"/chat-suggestions\")\nasync def get_chat_suggestions(\n    bill_number: Optional[str] = None",
        "import:fastapi.\"context\": context",
        "import:fastapi.instruction)\n    \n    return {\n        \"success\": True",
        "import:fastapi.this would integrate with an AI service\n    ai_response = generate_bill_chat_response(bill_number",
        "import:fastapi.\"controversy_level\": \"low\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.\"description\": \"Detailed description of the issue and its implications.\"",
        "import:fastapi.\"status\": bill.status_code\n        }",
        "import:fastapi.\"public_interest\": \"high\"",
        "import:fastapi.Body\nfrom sqlalchemy.orm import Session as DBSession\nfrom typing import Optional",
        "import:fastapi.create mock bill data for chat\n    # In a full implementation",
        "import:fastapi.description=\"Chat data\")",
        "import:fastapi.\"resolution_urgency\": \"normal\"\n        }\n    }\n    \n    return {\n        \"success\": True",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Process AI chat interactions for issues.\n    Users can ask questions about issues and get contextual responses.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"issue_id\"",
        "import:fastapi.HTTPException",
        "import:fastapi.\"constituency\": \"Unknown\"\n        }",
        "import:fastapi.\"suggestions\": suggestions",
        "import:fastapi.\"introduced_date\": bill.introduced",
        "import:fastapi.\"key_topics\": [\n            \"policy implementation\"",
        "import:fastapi.\"regulatory framework\"",
        "import:fastapi.\"status\": \"active\"",
        "import:fastapi.\"bill_status\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Process AI chat interactions for bills.\n    Users can ask questions about bills and get contextual responses.\n    \"\"\"\n    # Validate required fields\n    required_fields = [\"bill_number\"",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.\"message\": \"Issue information retrieved successfully for chat\"\n    }\n\n\n@router.post(\"/bill-chat\")\nasync def bill_chat(\n    chat_data: Dict[str",
        "import:fastapi.\"context_used\": [\"bill_summary\"",
        "import:fastapi.\"created_date\": datetime.utcnow().isoformat()",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/get-bill\")\nasync def get_bill_for_chat(\n    bill_number: str",
        "import:fastapi.Depends",
        "import:fastapi.Any] = Body(...",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    issue_id = chat_data[\"issue_id\"]\n    summary = chat_data[\"summary\"]\n    instruction = chat_data[\"instruction\"]\n    \n    # For now",
        "import:fastapi.Party",
        "import:fastapi.\"is_government_bill\": bill.is_government_bill if hasattr(bill",
        "import:fastapi.create mock issue data\n    # In a full implementation",
        "import:fastapi.\"summary\": \"This is a sample issue for demonstration purposes.\"",
        "import:fastapi.\"user_role\": user_role",
        "import:fastapi.\"chat_context\": {\n            \"issue_type\": \"policy_concern\"",
        "import:fastapi.\"user_instruction\"]\n        }\n    }\n\n\n@router.post(\"/issue-chat\")\nasync def issue_chat(\n    chat_data: Dict[str",
        "import:fastapi.\"category\": \"policy\"",
        "import:fastapi.detail=f\"Missing required field: {field}\")\n    \n    bill_number = chat_data[\"bill_number\"]\n    summary = chat_data[\"summary\"]\n    instruction = chat_data[\"instruction\"]\n    \n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.number == bill_number).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"public interest\"",
        "import:fastapi.'is_government_bill') else True",
        "import:fastapi.\"data\": bill_data",
        "import:fastapi.List\nfrom datetime import datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.create mock AI responses\n    # In a full implementation",
        "import:fastapi.\"complexity_level\": \"moderate\"",
        "import:fastapi.\"message\": \"Bill information retrieved successfully for chat\"\n    }\n\n\n@router.get(\"/get-issue\")\nasync def get_issue_for_chat(\n    issue_id: str",
        "function:get_chat_suggestions",
        "import:fastapi.\"short_title\": bill.short_title_en",
        "import:fastapi.\"status\": \"active\"\n        }",
        "import:fastapi.Any",
        "import:fastapi.\"total_suggestions\": len(suggestions)\n    }",
        "import:fastapi.summary",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get bill information for AI chat context.\n    Provides bill summary and context for chat interactions.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.number == bill_number).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"response\": ai_response",
        "import:fastapi.\"summary\": f\"Bill {bill.number}: {bill.name_en}. This bill addresses {bill.short_title_en} and is currently in {bill.status_code} status.\"",
        "import:fastapi.\"priority\": \"medium\"",
        "import:fastapi.\"bill_info\": {\n            \"number\": bill_number",
        "import:fastapi.\"data\": issue_data",
        "import:fastapi.this would come from the database\n    bill_data = {\n        \"id\": str(bill.id)",
        "import:fastapi.\"sponsor\": {\n            \"name\": \"Hon. Member\"",
        "import:fastapi.\"party\": \"Government\"",
        "import:fastapi.\"chat_context\": {\n            \"bill_type\": \"legislation\"",
        "import:fastapi.\"summary\"",
        "import:fastapi.this would come from the database\n    issue_data = {\n        \"id\": issue_id",
        "import:fastapi.user_role)\n        context = \"bill\"\n    elif issue_id:\n        # Issue-specific suggestions\n        suggestions = generate_issue_chat_suggestions(issue_id",
        "import:fastapi.\"public safety\"\n        ]",
        "import:fastapi.\"social welfare\"",
        "import:fastapi.\"context_used\": [\"issue_summary\"",
        "import:fastapi.\"instruction_type\": classify_instruction(instruction)",
        "import:fastapi.VoteQuestion",
        "import:fastapi.this would integrate with an AI service\n    ai_response = generate_issue_chat_response(issue_id",
        "import:fastapi.user_role: Optional[str] = None",
        "import:fastapi.\"issue_status\"",
        "import:fastapi.\"government oversight\"\n        ]",
        "import:fastapi.\"issue_info\": {\n            \"id\": issue_id",
        "import:fastapi.\"public_interest\": \"medium\"",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.\"response_length\": len(ai_response)",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/offices": {
      "method": "GET",
      "path": "/offices",
      "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py",
      "line": 32,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.DataSource",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.VoteResponse",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.Optional",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    OfficeResponse",
        "import:fastapi.Jurisdiction",
        "import:fastapi.VoteSearchParams\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Offices Endpoints\n# ============================================================================",
        "import:fastapi.Vote",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.VoteListResponse",
        "import:fastapi.BillSearchParams",
        "import:fastapi.BillResponse",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.Dict",
        "import:fastapi.Office",
        "import:fastapi.APIRouter",
        "import:fastapi.BillListResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.DataSourceResponse"
      ]
    },
    "GET:/offices/{office_id}": {
      "method": "GET",
      "path": "/offices/{office_id}",
      "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py",
      "line": 138,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.response_model=OfficeListResponse)\nasync def list_offices(\n    jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by jurisdiction ID\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.VoteSearchParams\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Offices Endpoints\n# ============================================================================\n\n@router.get(\"/offices\"",
        "import:fastapi.pagination=pagination)",
        "import:fastapi.jurisdiction_id=str(office.jurisdiction_id)",
        "import:fastapi.ge=1",
        "import:fastapi.government_level: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by office type\")",
        "import:fastapi.le=100",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all offices across all government levels.\n    \n    Supports filtering by jurisdiction",
        "import:fastapi.BillSearchParams",
        "import:fastapi.name=office.name",
        "import:fastapi.has_next=page < total_pages",
        "function:list_offices",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.Office",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.HTTPException",
        "import:fastapi.office type",
        "import:fastapi.Representative",
        "import:fastapi.DataSource",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.VoteResponse",
        "import:fastapi.extras=office.extras",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.JurisdictionResponse\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.and province.\n    \"\"\"\n    # Build base query\n    query = db.query(Office).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Office.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if office_type:\n        query = query.filter(Office.office_type == office_type)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get offices\n    offices = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    office_responses = []\n    for office in offices:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == office.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.office_type: Optional[str] = Query(None",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.Depends",
        "import:fastapi.VoteListResponse",
        "import:fastapi.updated_at=office.updated_at\n        ))\n    \n    # Create pagination info\n    from app.schemas.multi_level_government import PaginationInfo\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.government level",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_response = JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        office_responses.append(OfficeResponse(\n            id=str(office.id)",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.phone=office.phone",
        "import:fastapi.created_at=office.created_at",
        "import:fastapi.Optional",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    OfficeResponse",
        "import:fastapi.Jurisdiction",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.Query",
        "import:fastapi.jurisdiction=jurisdiction_response",
        "import:fastapi.total=total",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.office_type=office.office_type",
        "import:fastapi.BillResponse",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.location=office.location",
        "import:fastapi.email=office.email",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.Vote",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return OfficeListResponse(items=office_responses",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.BillListResponse"
      ]
    },
    "GET:/bills": {
      "method": "GET",
      "path": "/bills",
      "file": "services/api-gateway/src/api/v1/export.py",
      "line": 73,
      "dependencies": [
        "import:fastapi.Any]]",
        "import:fastapi.Member",
        "import:fastapi.dict) else ''\n                flat_item[field] = value\n            else:\n                flat_item[field] = item.get(field",
        "import:fastapi.'') if isinstance(value",
        "import:fastapi.Debate",
        "import:fastapi.root_name: str",
        "import:fastapi.key)\n                for nested_key",
        "import:fastapi.tags=[\"export\"])\n\ndef serialize_to_csv(data: List[Dict[str",
        "import:fastapi.key)\n                elem.text = str(value) if value is not None else ''\n    \n    # Pretty print(X)ML\n    rough_string = ET.tostring(root",
        "import:fastapi.fields: List[str]) -> str:\n    \"\"\"Convert data to CSV format\"\"\"\n    output = io.StringIO()\n    writer = csv.DictWriter(output",
        "import:fastapi.nested_key)\n                    child_elem.text = str(nested_value) if nested_value is not None else ''\n            else:\n                elem = ET.SubElement(item_elem",
        "import:fastapi.item_name)\n        for key",
        "import:fastapi.'')\n        writer.writerow(flat_item)\n    \n    return output.getvalue()\n\ndef serialize_to_xml(data: List[Dict[str",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.Any\nimport csv\nimport json\nimport io\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.Vote\nfrom .bills import get_bills_list\nfrom .members import get_members_list\nfrom .debates import get_debates_list\nfrom .committees import get_committees_list\n\nrouter = APIRouter(prefix=\"/export\"",
        "import:fastapi.Query",
        "import:fastapi.Committee",
        "import:fastapi.item_name: str) -> str:\n    \"\"\"\n    Convert data to XML format\n    Based on legacy XML export patterns\n    \"\"\"\n    root = ET.Element(root_name)\n    \n    for item in data:\n        item_elem = ET.SubElement(root",
        "import:fastapi.nested_value in value.items():\n                    child_elem = ET.SubElement(nested_elem",
        "function:serialize_to_xml",
        "import:fastapi.List",
        "import:fastapi.encoding='str')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent=\"  \")",
        "import:fastapi.dict):\n                # Handle nested objects\n                nested_elem = ET.SubElement(item_elem",
        "import:fastapi.Dict",
        "import:fastapi.value in item.items():\n            if isinstance(value",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException",
        "import:fastapi.fieldnames=fields)\n    writer.writeheader()\n    \n    for item in data:\n        # Flatten nested objects\n        flat_item = {}\n        for field in fields:\n            if '.' in field:\n                # Handle nested fields like \"party.name\"\n                parts = field.split('.')\n                value = item\n                for part in parts:\n                    value = value.get(part"
      ]
    },
    "GET:/bills/{bill_id}": {
      "method": "GET",
      "path": "/bills/{bill_id}",
      "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py",
      "line": 355,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.response_model=OfficeListResponse)\nasync def list_offices(\n    jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by sponsor representative ID\")",
        "import:fastapi.title=bill.title",
        "import:fastapi.description=\"Filter by jurisdiction ID\")",
        "import:fastapi.email=sponsor.email",
        "import:fastapi.name=sponsor.name",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        # Get sponsor details if available\n        sponsor_response = None\n        if bill.sponsor_id:\n            sponsor = db.query(Representative).filter(\n                Representative.id == bill.sponsor_id\n            ).first()\n            \n            if sponsor:\n                sponsor_response = RepresentativeResponse(\n                    id=str(sponsor.id)",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.VoteSearchParams\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Offices Endpoints\n# ============================================================================\n\n@router.get(\"/offices\"",
        "import:fastapi.pagination=pagination)",
        "import:fastapi.JurisdictionResponse\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.jurisdiction_id=str(office.jurisdiction_id)",
        "import:fastapi.ge=1",
        "import:fastapi.riding=sponsor.riding",
        "import:fastapi.response_model=OfficeResponse)\nasync def get_office(\n    office_id: str = Path(...",
        "import:fastapi.updated_at=bill.updated_at\n        ))\n    \n    # Create pagination info\n    from app.schemas.multi_level_government import PaginationInfo\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.government_level: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by office type\")",
        "import:fastapi.le=100",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all offices across all government levels.\n    \n    Supports filtering by jurisdiction",
        "import:fastapi.BillSearchParams",
        "import:fastapi.name=office.name",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return BillListResponse(items=bill_responses",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.party=sponsor.party",
        "import:fastapi.Office",
        "import:fastapi.jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by introduction date (before)\")",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.HTTPException",
        "import:fastapi.office type",
        "import:fastapi.Representative",
        "import:fastapi.status=bill.status",
        "import:fastapi.DataSource",
        "import:fastapi.updated_at=sponsor.updated_at\n                )\n        \n        bill_responses.append(BillResponse(\n            id=str(bill.id)",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.VoteResponse",
        "import:fastapi.extras=office.extras",
        "import:fastapi.introduced_after: Optional[datetime] = Query(None",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.extras=bill.extras",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.metadata_json=sponsor.metadata_json",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.JurisdictionResponse\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get bills\n    bills = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    bill_responses = []\n    for bill in bills:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == bill.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.and province.\n    \"\"\"\n    # Build base query\n    query = db.query(Office).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Office.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if office_type:\n        query = query.filter(Office.office_type == office_type)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get offices\n    offices = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    office_responses = []\n    for office in offices:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == office.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.office_type: Optional[str] = Query(None",
        "import:fastapi.position=sponsor.position",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.Depends",
        "import:fastapi.VoteListResponse",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/offices/{office_id}\"",
        "import:fastapi.created_at=bill.created_at",
        "import:fastapi.updated_at=office.updated_at\n        ))\n    \n    # Create pagination info\n    from app.schemas.multi_level_government import PaginationInfo\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.government level",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_response = JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.RepresentativeResponse\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        office_responses.append(OfficeResponse(\n            id=str(office.id)",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n    \n    return OfficeResponse(\n        id=str(office.id)",
        "import:fastapi.jurisdiction_id=str(bill.jurisdiction_id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.phone=office.phone",
        "import:fastapi.created_at=office.created_at",
        "import:fastapi.description=\"Filter by bill status\")",
        "import:fastapi.Optional",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    OfficeResponse",
        "import:fastapi.sponsor_id=str(bill.sponsor_id) if bill.sponsor_id else None",
        "function:list_bills",
        "import:fastapi.filtering",
        "import:fastapi.Jurisdiction",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=office.updated_at\n    )\n\n\n# ============================================================================\n# Bills Endpoints\n# ============================================================================\n\n@router.get(\"/bills\"",
        "import:fastapi.Query",
        "import:fastapi.jurisdiction=jurisdiction_response",
        "import:fastapi.total=total",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.office_type=office.office_type",
        "import:fastapi.created_at=sponsor.created_at",
        "import:fastapi.BillResponse",
        "import:fastapi.summary=bill.summary",
        "import:fastapi.sponsor_id: Optional[str] = Query(None",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.phone=sponsor.phone",
        "import:fastapi.description=\"Filter by introduction date (after)\")",
        "import:fastapi.location=office.location",
        "import:fastapi.email=office.email",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific office by ID.\n    \n    Returns detailed information about an office including jurisdiction and government level.\n    \"\"\"\n    office = db.query(Office).filter(Office.id == office_id).first()\n    \n    if not office:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"Office not found\")\n    \n    # Get jurisdiction details\n    jurisdiction = db.query(Jurisdiction).filter(\n        Jurisdiction.id == office.jurisdiction_id\n    ).first()\n    \n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.Vote",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.description=\"Office ID\")",
        "import:fastapi.jurisdiction_id=str(sponsor.jurisdiction_id)",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all bills across all government levels.\n    \n    Supports search",
        "import:fastapi.sponsor=sponsor_response",
        "import:fastapi.website=sponsor.website",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Bill).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Bill.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if status:\n        query = query.filter(Bill.status == status)\n    \n    if sponsor_id:\n        query = query.filter(Bill.sponsor_id == sponsor_id)\n    \n    if introduced_after:\n        query = query.filter(Bill.introduced_date >= introduced_after)\n    \n    if introduced_before:\n        query = query.filter(Bill.introduced_date <= introduced_before)\n    \n    # Apply search if query provided\n    if q:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.bills.title) @@ plainto_tsquery('english'",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return OfficeListResponse(items=office_responses",
        "import:fastapi.extras=sponsor.extras",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.introduced_before: Optional[datetime] = Query(None",
        "import:fastapi.BillListResponse",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    jurisdiction_response = JurisdictionResponse(\n        id=str(jurisdiction.id)"
      ]
    },
    "GET:/votes": {
      "method": "GET",
      "path": "/votes",
      "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py",
      "line": 450,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # Get jurisdiction details\n    jurisdiction = db.query(Jurisdiction).filter(\n        Jurisdiction.id == bill.jurisdiction_id\n    ).first()\n    \n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.response_model=OfficeListResponse)\nasync def list_offices(\n    jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by sponsor representative ID\")",
        "import:fastapi.title=bill.title",
        "import:fastapi.description=\"Filter by jurisdiction ID\")",
        "import:fastapi.email=sponsor.email",
        "import:fastapi.name=sponsor.name",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        # Get sponsor details if available\n        sponsor_response = None\n        if bill.sponsor_id:\n            sponsor = db.query(Representative).filter(\n                Representative.id == bill.sponsor_id\n            ).first()\n            \n            if sponsor:\n                sponsor_response = RepresentativeResponse(\n                    id=str(sponsor.id)",
        "import:fastapi.response_model=BillResponse)\nasync def get_bill(\n    bill_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.VoteSearchParams\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Offices Endpoints\n# ============================================================================\n\n@router.get(\"/offices\"",
        "import:fastapi.JurisdictionResponse\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.jurisdiction_id=str(office.jurisdiction_id)",
        "import:fastapi.ge=1",
        "import:fastapi.riding=sponsor.riding",
        "import:fastapi.response_model=OfficeResponse)\nasync def get_office(\n    office_id: str = Path(...",
        "import:fastapi.updated_at=bill.updated_at\n        ))\n    \n    # Create pagination info\n    from app.schemas.multi_level_government import PaginationInfo\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.government_level: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by office type\")",
        "import:fastapi.le=100",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all offices across all government levels.\n    \n    Supports filtering by jurisdiction",
        "import:fastapi.BillSearchParams",
        "import:fastapi.name=office.name",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return BillListResponse(items=bill_responses",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.party=sponsor.party",
        "import:fastapi.Office",
        "import:fastapi.jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by introduction date (before)\")",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.HTTPException",
        "import:fastapi.office type",
        "import:fastapi.Representative",
        "import:fastapi.status=bill.status",
        "import:fastapi.DataSource",
        "import:fastapi.updated_at=sponsor.updated_at\n                )\n        \n        bill_responses.append(BillResponse(\n            id=str(bill.id)",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.VoteResponse",
        "import:fastapi.extras=office.extras",
        "import:fastapi.introduced_after: Optional[datetime] = Query(None",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.extras=bill.extras",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.RepresentativeResponse\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.metadata_json=sponsor.metadata_json",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.JurisdictionResponse\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get bills\n    bills = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    bill_responses = []\n    for bill in bills:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == bill.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.and province.\n    \"\"\"\n    # Build base query\n    query = db.query(Office).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Office.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if office_type:\n        query = query.filter(Office.office_type == office_type)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get offices\n    offices = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    office_responses = []\n    for office in offices:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == office.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.office_type: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific bill by ID.\n    \n    Returns detailed information about a bill including jurisdiction",
        "import:fastapi.position=sponsor.position",
        "import:fastapi.description=\"Bill ID\")",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.Depends",
        "import:fastapi.VoteListResponse",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/offices/{office_id}\"",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/bills/{bill_id}\"",
        "import:fastapi.created_at=bill.created_at",
        "import:fastapi.updated_at=office.updated_at\n        ))\n    \n    # Create pagination info\n    from app.schemas.multi_level_government import PaginationInfo\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.government level",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_response = JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.RepresentativeResponse\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        office_responses.append(OfficeResponse(\n            id=str(office.id)",
        "import:fastapi.and sponsor.\n    \"\"\"\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    \n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n    \n    return OfficeResponse(\n        id=str(office.id)",
        "import:fastapi.jurisdiction_id=str(bill.jurisdiction_id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.phone=office.phone",
        "import:fastapi.created_at=office.created_at",
        "import:fastapi.description=\"Filter by bill status\")",
        "import:fastapi.Optional",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    OfficeResponse",
        "import:fastapi.sponsor_id=str(bill.sponsor_id) if bill.sponsor_id else None",
        "import:fastapi.filtering",
        "import:fastapi.Jurisdiction",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=office.updated_at\n    )\n\n\n# ============================================================================\n# Bills Endpoints\n# ============================================================================\n\n@router.get(\"/bills\"",
        "import:fastapi.Query",
        "import:fastapi.jurisdiction=jurisdiction_response",
        "import:fastapi.total=total",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.office_type=office.office_type",
        "import:fastapi.created_at=sponsor.created_at",
        "import:fastapi.BillResponse",
        "import:fastapi.summary=bill.summary",
        "import:fastapi.sponsor_id: Optional[str] = Query(None",
        "import:fastapi.updated_at=sponsor.updated_at\n            )\n    \n    return BillResponse(\n        id=str(bill.id)",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.updated_at=bill.updated_at\n    )\n\n\n# ============================================================================\n# Votes Endpoints\n# ============================================================================",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.phone=sponsor.phone",
        "import:fastapi.description=\"Filter by introduction date (after)\")",
        "import:fastapi.location=office.location",
        "import:fastapi.email=office.email",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific office by ID.\n    \n    Returns detailed information about an office including jurisdiction and government level.\n    \"\"\"\n    office = db.query(Office).filter(Office.id == office_id).first()\n    \n    if not office:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n    \n    # Get sponsor details if available\n    sponsor_response = None\n    if bill.sponsor_id:\n        sponsor = db.query(Representative).filter(\n            Representative.id == bill.sponsor_id\n        ).first()\n        \n        if sponsor:\n            sponsor_response = RepresentativeResponse(\n                id=str(sponsor.id)",
        "import:fastapi.detail=\"Office not found\")\n    \n    # Get jurisdiction details\n    jurisdiction = db.query(Jurisdiction).filter(\n        Jurisdiction.id == office.jurisdiction_id\n    ).first()\n    \n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.Vote",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.description=\"Office ID\")",
        "import:fastapi.jurisdiction_id=str(sponsor.jurisdiction_id)",
        "import:fastapi.OfficeListResponse",
        "function:get_bill",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all bills across all government levels.\n    \n    Supports search",
        "import:fastapi.sponsor=sponsor_response",
        "import:fastapi.website=sponsor.website",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Bill).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Bill.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if status:\n        query = query.filter(Bill.status == status)\n    \n    if sponsor_id:\n        query = query.filter(Bill.sponsor_id == sponsor_id)\n    \n    if introduced_after:\n        query = query.filter(Bill.introduced_date >= introduced_after)\n    \n    if introduced_before:\n        query = query.filter(Bill.introduced_date <= introduced_before)\n    \n    # Apply search if query provided\n    if q:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.bills.title) @@ plainto_tsquery('english'",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return OfficeListResponse(items=office_responses",
        "import:fastapi.extras=sponsor.extras",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.introduced_before: Optional[datetime] = Query(None",
        "import:fastapi.BillListResponse",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    jurisdiction_response = JurisdictionResponse(\n        id=str(jurisdiction.id)"
      ]
    },
    "GET:/data-sources": {
      "method": "GET",
      "path": "/data-sources",
      "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py",
      "line": 611,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # Get jurisdiction details\n    jurisdiction = db.query(Jurisdiction).filter(\n        Jurisdiction.id == bill.jurisdiction_id\n    ).first()\n    \n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.response_model=OfficeListResponse)\nasync def list_offices(\n    jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by sponsor representative ID\")",
        "import:fastapi.representative_id: Optional[str] = Query(None",
        "import:fastapi.title=bill.title",
        "import:fastapi.description=\"Filter by jurisdiction ID\")",
        "import:fastapi.email=sponsor.email",
        "import:fastapi.description=\"Filter by vote date (before)\")",
        "import:fastapi.name=sponsor.name",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        # Get sponsor details if available\n        sponsor_response = None\n        if bill.sponsor_id:\n            sponsor = db.query(Representative).filter(\n                Representative.id == bill.sponsor_id\n            ).first()\n            \n            if sponsor:\n                sponsor_response = RepresentativeResponse(\n                    id=str(sponsor.id)",
        "import:fastapi.response_model=BillResponse)\nasync def get_bill(\n    bill_id: str = Path(...",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.updated_at=bill.updated_at\n    )\n\n\n# ============================================================================\n# Votes Endpoints\n# ============================================================================\n\n@router.get(\"/votes\"",
        "import:fastapi.VoteSearchParams\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Offices Endpoints\n# ============================================================================\n\n@router.get(\"/offices\"",
        "import:fastapi.sponsor=None",
        "import:fastapi.JurisdictionResponse\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.vote_after: Optional[datetime] = Query(None",
        "import:fastapi.description=\"Search query for bill title\")",
        "import:fastapi.jurisdiction_id=str(office.jurisdiction_id)",
        "import:fastapi.ge=1",
        "import:fastapi.vote_before: Optional[datetime] = Query(None",
        "import:fastapi.riding=sponsor.riding",
        "import:fastapi.response_model=OfficeResponse)\nasync def get_office(\n    office_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return VoteListResponse(items=vote_responses",
        "import:fastapi.updated_at=bill.updated_at\n        ))\n    \n    # Create pagination info\n    from app.schemas.multi_level_government import PaginationInfo\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.government_level: Optional[str] = Query(None",
        "import:fastapi.session=vote.session",
        "import:fastapi.description=\"Filter by office type\")",
        "import:fastapi.website=representative.website",
        "import:fastapi.le=100",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all offices across all government levels.\n    \n    Supports filtering by jurisdiction",
        "import:fastapi.BillSearchParams",
        "import:fastapi.name=office.name",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return BillListResponse(items=bill_responses",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.phone=representative.phone",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.riding=representative.riding",
        "import:fastapi.party=sponsor.party",
        "import:fastapi.Office",
        "import:fastapi.jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.description=\"Filter by introduction date (before)\")",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.HTTPException",
        "import:fastapi.office type",
        "import:fastapi.Representative",
        "import:fastapi.status=bill.status",
        "import:fastapi.DataSource",
        "import:fastapi.updated_at=sponsor.updated_at\n                )\n        \n        bill_responses.append(BillResponse(\n            id=str(bill.id)",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.status: Optional[str] = Query(None",
        "import:fastapi.VoteResponse",
        "import:fastapi.extras=office.extras",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        bill_response = BillResponse(\n            id=str(bill.id)",
        "import:fastapi.introduced_after: Optional[datetime] = Query(None",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    bill_id: Optional[str] = Query(None",
        "import:fastapi.extras=bill.extras",
        "import:fastapi.func",
        "import:fastapi.updated_at=vote.updated_at\n        ))\n    \n    # Create pagination info\n    from app.schemas.multi_level_government import PaginationInfo\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.and_",
        "import:fastapi.RepresentativeResponse\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.metadata_json=sponsor.metadata_json",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.description=\"Filter by bill ID\")",
        "import:fastapi.JurisdictionResponse\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.representative=representative_response",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get bills\n    bills = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    bill_responses = []\n    for bill in bills:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == bill.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.# Skip sponsor to avoid circular reference\n            created_at=bill.created_at",
        "import:fastapi.and province.\n    \"\"\"\n    # Build base query\n    query = db.query(Office).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Office.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if office_type:\n        query = query.filter(Office.office_type == office_type)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get offices\n    offices = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    office_responses = []\n    for office in offices:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == office.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.office_type: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific bill by ID.\n    \n    Returns detailed information about a bill including jurisdiction",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all votes across all government levels.\n    \n    Supports filtering and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Vote).join(Bill).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if bill_id:\n        query = query.filter(Vote.bill_id == bill_id)\n    \n    if representative_id:\n        query = query.filter(Vote.representative_id == representative_id)\n    \n    if vote_position:\n        query = query.filter(Vote.vote_position == vote_position)\n    \n    if vote_after:\n        query = query.filter(Vote.vote_date >= vote_after)\n    \n    if vote_before:\n        query = query.filter(Vote.vote_date <= vote_before)\n    \n    if session:\n        query = query.filter(Vote.session == session)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get votes\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_responses = []\n    for vote in votes:\n        # Get bill details\n        bill = db.query(Bill).filter(Bill.id == vote.bill_id).first()\n        \n        # Get representative details\n        representative = db.query(Representative).filter(\n            Representative.id == vote.representative_id\n        ).first()\n        \n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == bill.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        from app.schemas.multi_level_government import (\n            GovernmentLevelResponse",
        "import:fastapi.extras=vote.extras",
        "import:fastapi.position=sponsor.position",
        "import:fastapi.description=\"Bill ID\")",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.introduced_date=bill.introduced_date",
        "import:fastapi.Depends",
        "import:fastapi.vote_date=vote.vote_date",
        "import:fastapi.VoteListResponse",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/offices/{office_id}\"",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/bills/{bill_id}\"",
        "import:fastapi.pagination=pagination)\n\n\n# ============================================================================\n# Data Sources Endpoints\n# ============================================================================",
        "import:fastapi.created_at=bill.created_at",
        "import:fastapi.name=representative.name",
        "import:fastapi.created_at=representative.created_at",
        "import:fastapi.updated_at=office.updated_at\n        ))\n    \n    # Create pagination info\n    from app.schemas.multi_level_government import PaginationInfo\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.government level",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.party=representative.party",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_response = JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.RepresentativeResponse\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.response_model=BillListResponse)\nasync def list_bills(\n    q: Optional[str] = Query(None",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.updated_at=bill.updated_at\n        )\n        \n        representative_response = RepresentativeResponse(\n            id=str(representative.id)",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.vote_position: Optional[str] = Query(None",
        "import:fastapi.email=representative.email",
        "import:fastapi.extras=representative.extras",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        office_responses.append(OfficeResponse(\n            id=str(office.id)",
        "import:fastapi.and sponsor.\n    \"\"\"\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    \n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n    \n    return OfficeResponse(\n        id=str(office.id)",
        "import:fastapi.jurisdiction_id=str(bill.jurisdiction_id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.phone=office.phone",
        "import:fastapi.jurisdiction_id=str(representative.jurisdiction_id)",
        "import:fastapi.created_at=office.created_at",
        "import:fastapi.description=\"Filter by bill status\")",
        "import:fastapi.Optional",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    OfficeResponse",
        "import:fastapi.sponsor_id=str(bill.sponsor_id) if bill.sponsor_id else None",
        "import:fastapi.filtering",
        "import:fastapi.Jurisdiction",
        "import:fastapi.description=\"Filter by vote position\")",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.updated_at=office.updated_at\n    )\n\n\n# ============================================================================\n# Bills Endpoints\n# ============================================================================\n\n@router.get(\"/bills\"",
        "import:fastapi.Query",
        "import:fastapi.jurisdiction=jurisdiction_response",
        "import:fastapi.vote_position=vote.vote_position",
        "import:fastapi.total=total",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.office_type=office.office_type",
        "import:fastapi.created_at=sponsor.created_at",
        "import:fastapi.BillResponse",
        "import:fastapi.summary=bill.summary",
        "import:fastapi.sponsor_id: Optional[str] = Query(None",
        "import:fastapi.updated_at=sponsor.updated_at\n            )\n    \n    return BillResponse(\n        id=str(bill.id)",
        "import:fastapi.BillResponse\n        )\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.description=\"Filter by session\")",
        "import:fastapi.province: Optional[str] = Query(None",
        "function:list_votes",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.description=\"Filter by representative ID\")",
        "import:fastapi.description=\"Filter by vote date (after)\")",
        "import:fastapi.phone=sponsor.phone",
        "import:fastapi.description=\"Filter by introduction date (after)\")",
        "import:fastapi.location=office.location",
        "import:fastapi.email=office.email",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.metadata_json=representative.metadata_json",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific office by ID.\n    \n    Returns detailed information about an office including jurisdiction and government level.\n    \"\"\"\n    office = db.query(Office).filter(Office.id == office_id).first()\n    \n    if not office:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=representative.updated_at\n        )\n        \n        vote_responses.append(VoteResponse(\n            id=str(vote.id)",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n    \n    # Get sponsor details if available\n    sponsor_response = None\n    if bill.sponsor_id:\n        sponsor = db.query(Representative).filter(\n            Representative.id == bill.sponsor_id\n        ).first()\n        \n        if sponsor:\n            sponsor_response = RepresentativeResponse(\n                id=str(sponsor.id)",
        "import:fastapi.detail=\"Office not found\")\n    \n    # Get jurisdiction details\n    jurisdiction = db.query(Jurisdiction).filter(\n        Jurisdiction.id == office.jurisdiction_id\n    ).first()\n    \n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    from app.schemas.multi_level_government import GovernmentLevelResponse",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.description=\"Office ID\")",
        "import:fastapi.bill_id=str(vote.bill_id)",
        "import:fastapi.jurisdiction_id=str(sponsor.jurisdiction_id)",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.bill=bill_response",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all bills across all government levels.\n    \n    Supports search",
        "import:fastapi.sponsor=sponsor_response",
        "import:fastapi.position=representative.position",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.website=sponsor.website",
        "import:fastapi.bill_number=bill.bill_number",
        "import:fastapi.and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Bill).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Bill.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if status:\n        query = query.filter(Bill.status == status)\n    \n    if sponsor_id:\n        query = query.filter(Bill.sponsor_id == sponsor_id)\n    \n    if introduced_after:\n        query = query.filter(Bill.introduced_date >= introduced_after)\n    \n    if introduced_before:\n        query = query.filter(Bill.introduced_date <= introduced_before)\n    \n    # Apply search if query provided\n    if q:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.bills.title) @@ plainto_tsquery('english'",
        "import:fastapi.representative_id=str(vote.representative_id)",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return OfficeListResponse(items=office_responses",
        "import:fastapi.extras=sponsor.extras",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.introduced_before: Optional[datetime] = Query(None",
        "import:fastapi.BillListResponse",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    jurisdiction_response = JurisdictionResponse(\n        id=str(jurisdiction.id)",
        "import:fastapi.created_at=vote.created_at"
      ]
    },
    "GET:/government-levels": {
      "method": "GET",
      "path": "/government-levels",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 37,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.OfficeResponse",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.VoteResponse",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.Optional",
        "import:fastapi.Jurisdiction",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.GovernmentLevelListResponse",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.VoteListResponse",
        "import:fastapi.BillSearchParams",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================",
        "import:fastapi.SystemStats",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.BillResponse",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.Dict",
        "import:fastapi.Office",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.DataSourceResponse"
      ]
    },
    "GET:/government-levels/{level_id}": {
      "method": "GET",
      "path": "/government-levels/{level_id}",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 83,
      "dependencies": [
        "import:fastapi.level_order=level.level_order",
        "import:fastapi.Bill",
        "import:fastapi.OfficeResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.VoteResponse",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================\n\n@router.get(\"/government-levels\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.func",
        "import:fastapi.name=level.name",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination)",
        "import:fastapi.Optional",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=GovernmentLevelListResponse)\nasync def list_government_levels(\n    page: int = Query(1",
        "import:fastapi.Jurisdiction",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=level.description",
        "import:fastapi.GovernmentLevelListResponse",
        "function:list_government_levels",
        "import:fastapi.Provincial",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.le=100",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.VoteListResponse",
        "import:fastapi.BillSearchParams",
        "import:fastapi.total=total",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return GovernmentLevelListResponse(items=level_responses",
        "import:fastapi.SystemStats",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.updated_at=level.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.Municipal).\n    \n    Returns government levels ordered by their level_order.\n    \"\"\"\n    # Get total count\n    total = db.query(GovernmentLevel).count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get government levels\n    levels = db.query(GovernmentLevel).order_by(GovernmentLevel.level_order).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    level_responses = []\n    for level in levels:\n        level_responses.append(GovernmentLevelResponse(\n            id=str(level.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all government levels (Federal",
        "import:fastapi.BillResponse",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.Dict",
        "import:fastapi.Office",
        "import:fastapi.created_at=level.created_at",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.DataSourceResponse"
      ]
    },
    "GET:/jurisdictions": {
      "method": "GET",
      "path": "/jurisdictions",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 112,
      "dependencies": [
        "import:fastapi.level_order=level.level_order",
        "import:fastapi.Bill",
        "import:fastapi.OfficeResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/government-levels/{level_id}\"",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.response_model=GovernmentLevelResponse)\nasync def get_government_level(\n    level_id: str = Path(...",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.updated_at=level.updated_at\n    )\n\n\n# ============================================================================\n# Jurisdictions Endpoints\n# ============================================================================",
        "import:fastapi.VoteResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific government level by ID.\n    \n    Returns detailed information about a government level.\n    \"\"\"\n    level = db.query(GovernmentLevel).filter(GovernmentLevel.id == level_id).first()\n    \n    if not level:\n        raise HTTPException(status_code=404",
        "import:fastapi.detail=\"Government level not found\")\n    \n    return GovernmentLevelResponse(\n        id=str(level.id)",
        "function:get_government_level",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================\n\n@router.get(\"/government-levels\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.func",
        "import:fastapi.name=level.name",
        "import:fastapi.and_",
        "import:fastapi.Optional",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=GovernmentLevelListResponse)\nasync def list_government_levels(\n    page: int = Query(1",
        "import:fastapi.Jurisdiction",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=level.description",
        "import:fastapi.GovernmentLevelListResponse",
        "import:fastapi.Provincial",
        "import:fastapi.Depends",
        "import:fastapi.Query",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.le=100",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.VoteListResponse",
        "import:fastapi.BillSearchParams",
        "import:fastapi.total=total",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return GovernmentLevelListResponse(items=level_responses",
        "import:fastapi.description=\"Government level ID\")",
        "import:fastapi.SystemStats",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.updated_at=level.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.Municipal).\n    \n    Returns government levels ordered by their level_order.\n    \"\"\"\n    # Get total count\n    total = db.query(GovernmentLevel).count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get government levels\n    levels = db.query(GovernmentLevel).order_by(GovernmentLevel.level_order).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    level_responses = []\n    for level in levels:\n        level_responses.append(GovernmentLevelResponse(\n            id=str(level.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all government levels (Federal",
        "import:fastapi.BillResponse",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.Dict",
        "import:fastapi.Office",
        "import:fastapi.created_at=level.created_at",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.DataSourceResponse"
      ]
    },
    "GET:/jurisdictions/{jurisdiction_id}": {
      "method": "GET",
      "path": "/jurisdictions/{jurisdiction_id}",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 193,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.name=level.name",
        "import:fastapi.pagination=pagination)",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=GovernmentLevelListResponse)\nasync def list_government_levels(\n    page: int = Query(1",
        "import:fastapi.le=100",
        "import:fastapi.BillSearchParams",
        "import:fastapi.description=\"Government level ID\")",
        "import:fastapi.updated_at=level.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.Municipal).\n    \n    Returns government levels ordered by their level_order.\n    \"\"\"\n    # Get total count\n    total = db.query(GovernmentLevel).count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get government levels\n    levels = db.query(GovernmentLevel).order_by(GovernmentLevel.level_order).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    level_responses = []\n    for level in levels:\n        level_responses.append(GovernmentLevelResponse(\n            id=str(level.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all government levels (Federal",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_responses.append(JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.Office",
        "import:fastapi.created_at=level.created_at",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "function:list_jurisdictions",
        "import:fastapi.response_model=JurisdictionListResponse)\nasync def list_jurisdictions(\n    government_level: Optional[str] = Query(None",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.VoteResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific government level by ID.\n    \n    Returns detailed information about a government level.\n    \"\"\"\n    level = db.query(GovernmentLevel).filter(GovernmentLevel.id == level_id).first()\n    \n    if not level:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=level.updated_at\n    )\n\n\n# ============================================================================\n# Jurisdictions Endpoints\n# ============================================================================\n\n@router.get(\"/jurisdictions\"",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.description=level.description",
        "import:fastapi.GovernmentLevelListResponse",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.Provincial",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.Depends",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return GovernmentLevelListResponse(items=level_responses",
        "import:fastapi.VoteListResponse",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.description=\"Filter by jurisdiction type\")",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.response_model=GovernmentLevelResponse)\nasync def get_government_level(\n    level_id: str = Path(...",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.jurisdiction_type: Optional[str] = Query(None",
        "import:fastapi.detail=\"Government level not found\")\n    \n    return GovernmentLevelResponse(\n        id=str(level.id)",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.Optional",
        "import:fastapi.Jurisdiction",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all jurisdictions across all government levels.\n    \n    Supports filtering by government level",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.SystemStats",
        "import:fastapi.BillResponse",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.level_order=level.level_order",
        "import:fastapi.OfficeResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/government-levels/{level_id}\"",
        "import:fastapi.and jurisdiction type.\n    \"\"\"\n    # Build base query\n    query = db.query(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if jurisdiction_type:\n        query = query.filter(Jurisdiction.jurisdiction_type == jurisdiction_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get jurisdictions\n    jurisdictions = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    jurisdiction_responses = []\n    for jurisdiction in jurisdictions:\n        # Get government level details\n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================\n\n@router.get(\"/government-levels\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.province",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return JurisdictionListResponse(items=jurisdiction_responses"
      ]
    },
    "GET:/representatives": {
      "method": "GET",
      "path": "/representatives",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 241,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/jurisdictions/{jurisdiction_id}\"",
        "function:get_jurisdiction",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.name=level.name",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=GovernmentLevelListResponse)\nasync def list_government_levels(\n    page: int = Query(1",
        "import:fastapi.le=100",
        "import:fastapi.BillSearchParams",
        "import:fastapi.description=\"Government level ID\")",
        "import:fastapi.updated_at=level.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.Municipal).\n    \n    Returns government levels ordered by their level_order.\n    \"\"\"\n    # Get total count\n    total = db.query(GovernmentLevel).count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get government levels\n    levels = db.query(GovernmentLevel).order_by(GovernmentLevel.level_order).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    level_responses = []\n    for level in levels:\n        level_responses.append(GovernmentLevelResponse(\n            id=str(level.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all government levels (Federal",
        "import:fastapi.response_model=JurisdictionResponse)\nasync def get_jurisdiction(\n    jurisdiction_id: str = Path(...",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_responses.append(JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.Office",
        "import:fastapi.created_at=level.created_at",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.description=\"Jurisdiction ID\")",
        "import:fastapi.response_model=JurisdictionListResponse)\nasync def list_jurisdictions(\n    government_level: Optional[str] = Query(None",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    return JurisdictionResponse(\n        id=str(jurisdiction.id)",
        "import:fastapi.VoteResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific government level by ID.\n    \n    Returns detailed information about a government level.\n    \"\"\"\n    level = db.query(GovernmentLevel).filter(GovernmentLevel.id == level_id).first()\n    \n    if not level:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n\n\n# ============================================================================\n# Representatives Endpoints\n# ============================================================================",
        "import:fastapi.updated_at=level.updated_at\n    )\n\n\n# ============================================================================\n# Jurisdictions Endpoints\n# ============================================================================\n\n@router.get(\"/jurisdictions\"",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.description=level.description",
        "import:fastapi.GovernmentLevelListResponse",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.Provincial",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.Depends",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return GovernmentLevelListResponse(items=level_responses",
        "import:fastapi.VoteListResponse",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.description=\"Filter by jurisdiction type\")",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.response_model=GovernmentLevelResponse)\nasync def get_government_level(\n    level_id: str = Path(...",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific jurisdiction by ID.\n    \n    Returns detailed information about a jurisdiction including its government level.\n    \"\"\"\n    jurisdiction = db.query(Jurisdiction).filter(Jurisdiction.id == jurisdiction_id).first()\n    \n    if not jurisdiction:\n        raise HTTPException(status_code=404",
        "import:fastapi.jurisdiction_type: Optional[str] = Query(None",
        "import:fastapi.detail=\"Government level not found\")\n    \n    return GovernmentLevelResponse(\n        id=str(level.id)",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.detail=\"Jurisdiction not found\")\n    \n    # Get government level details\n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.Optional",
        "import:fastapi.Jurisdiction",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all jurisdictions across all government levels.\n    \n    Supports filtering by government level",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.SystemStats",
        "import:fastapi.BillResponse",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.level_order=level.level_order",
        "import:fastapi.OfficeResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/government-levels/{level_id}\"",
        "import:fastapi.and jurisdiction type.\n    \"\"\"\n    # Build base query\n    query = db.query(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if jurisdiction_type:\n        query = query.filter(Jurisdiction.jurisdiction_type == jurisdiction_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get jurisdictions\n    jurisdictions = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    jurisdiction_responses = []\n    for jurisdiction in jurisdictions:\n        # Get government level details\n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================\n\n@router.get(\"/government-levels\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.province",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return JurisdictionListResponse(items=jurisdiction_responses"
      ]
    },
    "GET:/representatives/{representative_id}": {
      "method": "GET",
      "path": "/representatives/{representative_id}",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 359,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by political party\")",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/jurisdictions/{jurisdiction_id}\"",
        "import:fastapi.description=\"Filter by jurisdiction ID\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.name=level.name",
        "import:fastapi.pagination=pagination)",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=GovernmentLevelListResponse)\nasync def list_government_levels(\n    page: int = Query(1",
        "import:fastapi.position=rep.position",
        "import:fastapi.party=rep.party",
        "import:fastapi.jurisdiction_id=str(rep.jurisdiction_id)",
        "import:fastapi.government_level: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.BillSearchParams",
        "import:fastapi.description=\"Government level ID\")",
        "import:fastapi.updated_at=level.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.Municipal).\n    \n    Returns government levels ordered by their level_order.\n    \"\"\"\n    # Get total count\n    total = db.query(GovernmentLevel).count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get government levels\n    levels = db.query(GovernmentLevel).order_by(GovernmentLevel.level_order).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    level_responses = []\n    for level in levels:\n        level_responses.append(GovernmentLevelResponse(\n            id=str(level.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all government levels (Federal",
        "import:fastapi.response_model=JurisdictionResponse)\nasync def get_jurisdiction(\n    jurisdiction_id: str = Path(...",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n\n\n# ============================================================================\n# Representatives Endpoints\n# ============================================================================\n\n@router.get(\"/representatives\"",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_responses.append(JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.Office",
        "import:fastapi.created_at=level.created_at",
        "import:fastapi.jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.description=\"Jurisdiction ID\")",
        "import:fastapi.website=rep.website",
        "import:fastapi.response_model=JurisdictionListResponse)\nasync def list_jurisdictions(\n    government_level: Optional[str] = Query(None",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.response_model=RepresentativeListResponse)\nasync def list_representatives(\n    q: Optional[str] = Query(None",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.name=rep.name",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    return JurisdictionResponse(\n        id=str(jurisdiction.id)",
        "import:fastapi.VoteResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific government level by ID.\n    \n    Returns detailed information about a government level.\n    \"\"\"\n    level = db.query(GovernmentLevel).filter(GovernmentLevel.id == level_id).first()\n    \n    if not level:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=level.updated_at\n    )\n\n\n# ============================================================================\n# Jurisdictions Endpoints\n# ============================================================================\n\n@router.get(\"/jurisdictions\"",
        "import:fastapi.updated_at=rep.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all representatives across all government levels.\n    \n    Supports search",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.position: Optional[str] = Query(None",
        "import:fastapi.phone=rep.phone",
        "import:fastapi.description=level.description",
        "import:fastapi.GovernmentLevelListResponse",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.Provincial",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.Depends",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return GovernmentLevelListResponse(items=level_responses",
        "import:fastapi.VoteListResponse",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.representatives.name) @@ plainto_tsquery('english'",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_response = JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.riding=rep.riding",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.description=\"Filter by jurisdiction type\")",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.response_model=GovernmentLevelResponse)\nasync def get_government_level(\n    level_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return RepresentativeListResponse(items=representative_responses",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific jurisdiction by ID.\n    \n    Returns detailed information about a jurisdiction including its government level.\n    \"\"\"\n    jurisdiction = db.query(Jurisdiction).filter(Jurisdiction.id == jurisdiction_id).first()\n    \n    if not jurisdiction:\n        raise HTTPException(status_code=404",
        "import:fastapi.jurisdiction_type: Optional[str] = Query(None",
        "import:fastapi.detail=\"Government level not found\")\n    \n    return GovernmentLevelResponse(\n        id=str(level.id)",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.detail=\"Jurisdiction not found\")\n    \n    # Get government level details\n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get representatives\n    representatives = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    representative_responses = []\n    for rep in representatives:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == rep.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.Optional",
        "import:fastapi.filtering",
        "import:fastapi.metadata_json=rep.metadata_json",
        "import:fastapi.Jurisdiction",
        "import:fastapi.created_at=rep.created_at",
        "import:fastapi.description=\"Items per page\")",
        "function:list_representatives",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all jurisdictions across all government levels.\n    \n    Supports filtering by government level",
        "import:fastapi.Query",
        "import:fastapi.jurisdiction=jurisdiction_response",
        "import:fastapi.total=total",
        "import:fastapi.extras=rep.extras",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.SystemStats",
        "import:fastapi.description=\"Filter by position\")",
        "import:fastapi.BillResponse",
        "import:fastapi.description=\"Search query for representative name\")",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.level_order=level.level_order",
        "import:fastapi.OfficeResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/government-levels/{level_id}\"",
        "import:fastapi.and jurisdiction type.\n    \"\"\"\n    # Build base query\n    query = db.query(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if jurisdiction_type:\n        query = query.filter(Jurisdiction.jurisdiction_type == jurisdiction_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get jurisdictions\n    jurisdictions = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    jurisdiction_responses = []\n    for jurisdiction in jurisdictions:\n        # Get government level details\n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.email=rep.email",
        "import:fastapi.and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Representative).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Representative.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if party:\n        query = query.filter(Representative.party.ilike(f\"%{party}%\"))\n    \n    if position:\n        query = query.filter(Representative.position == position)\n    \n    # Apply search if query provided\n    if q:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================\n\n@router.get(\"/government-levels\"",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.province",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        representative_responses.append(RepresentativeResponse(\n            id=str(rep.id)",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return JurisdictionListResponse(items=jurisdiction_responses"
      ]
    },
    "GET:/stats/system": {
      "method": "GET",
      "path": "/stats/system",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 428,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by political party\")",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/representatives/{representative_id}\"",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/jurisdictions/{jurisdiction_id}\"",
        "import:fastapi.description=\"Filter by jurisdiction ID\")",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.name=level.name",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=GovernmentLevelListResponse)\nasync def list_government_levels(\n    page: int = Query(1",
        "import:fastapi.position=rep.position",
        "import:fastapi.party=rep.party",
        "import:fastapi.jurisdiction_id=str(rep.jurisdiction_id)",
        "import:fastapi.government_level: Optional[str] = Query(None",
        "import:fastapi.website=representative.website",
        "import:fastapi.le=100",
        "import:fastapi.BillSearchParams",
        "import:fastapi.description=\"Government level ID\")",
        "import:fastapi.updated_at=level.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n    \n    return RepresentativeResponse(\n        id=str(representative.id)",
        "import:fastapi.phone=representative.phone",
        "import:fastapi.Municipal).\n    \n    Returns government levels ordered by their level_order.\n    \"\"\"\n    # Get total count\n    total = db.query(GovernmentLevel).count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get government levels\n    levels = db.query(GovernmentLevel).order_by(GovernmentLevel.level_order).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    level_responses = []\n    for level in levels:\n        level_responses.append(GovernmentLevelResponse(\n            id=str(level.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all government levels (Federal",
        "import:fastapi.response_model=JurisdictionResponse)\nasync def get_jurisdiction(\n    jurisdiction_id: str = Path(...",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n\n\n# ============================================================================\n# Representatives Endpoints\n# ============================================================================\n\n@router.get(\"/representatives\"",
        "import:fastapi.riding=representative.riding",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_responses.append(JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.Office",
        "import:fastapi.created_at=level.created_at",
        "import:fastapi.jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.description=\"Jurisdiction ID\")",
        "import:fastapi.website=rep.website",
        "import:fastapi.response_model=JurisdictionListResponse)\nasync def list_jurisdictions(\n    government_level: Optional[str] = Query(None",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.response_model=RepresentativeListResponse)\nasync def list_representatives(\n    q: Optional[str] = Query(None",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.name=rep.name",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    return JurisdictionResponse(\n        id=str(jurisdiction.id)",
        "import:fastapi.VoteResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific government level by ID.\n    \n    Returns detailed information about a government level.\n    \"\"\"\n    level = db.query(GovernmentLevel).filter(GovernmentLevel.id == level_id).first()\n    \n    if not level:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=level.updated_at\n    )\n\n\n# ============================================================================\n# Jurisdictions Endpoints\n# ============================================================================\n\n@router.get(\"/jurisdictions\"",
        "import:fastapi.updated_at=rep.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all representatives across all government levels.\n    \n    Supports search",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.position: Optional[str] = Query(None",
        "import:fastapi.phone=rep.phone",
        "import:fastapi.description=level.description",
        "import:fastapi.GovernmentLevelListResponse",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.Provincial",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.Depends",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return GovernmentLevelListResponse(items=level_responses",
        "import:fastapi.VoteListResponse",
        "function:get_representative",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.name=representative.name",
        "import:fastapi.created_at=representative.created_at",
        "import:fastapi.representatives.name) @@ plainto_tsquery('english'",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.party=representative.party",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_response = JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.riding=rep.riding",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.description=\"Filter by jurisdiction type\")",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.email=representative.email",
        "import:fastapi.extras=representative.extras",
        "import:fastapi.response_model=GovernmentLevelResponse)\nasync def get_government_level(\n    level_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return RepresentativeListResponse(items=representative_responses",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific jurisdiction by ID.\n    \n    Returns detailed information about a jurisdiction including its government level.\n    \"\"\"\n    jurisdiction = db.query(Jurisdiction).filter(Jurisdiction.id == jurisdiction_id).first()\n    \n    if not jurisdiction:\n        raise HTTPException(status_code=404",
        "import:fastapi.jurisdiction_type: Optional[str] = Query(None",
        "import:fastapi.detail=\"Government level not found\")\n    \n    return GovernmentLevelResponse(\n        id=str(level.id)",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.detail=\"Jurisdiction not found\")\n    \n    # Get government level details\n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get representatives\n    representatives = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    representative_responses = []\n    for rep in representatives:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == rep.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.jurisdiction_id=str(representative.jurisdiction_id)",
        "import:fastapi.updated_at=representative.updated_at\n    )\n\n\n# ============================================================================\n# Statistics Endpoints\n# ============================================================================",
        "import:fastapi.Optional",
        "import:fastapi.filtering",
        "import:fastapi.metadata_json=rep.metadata_json",
        "import:fastapi.Jurisdiction",
        "import:fastapi.created_at=rep.created_at",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all jurisdictions across all government levels.\n    \n    Supports filtering by government level",
        "import:fastapi.Query",
        "import:fastapi.jurisdiction=jurisdiction_response",
        "import:fastapi.total=total",
        "import:fastapi.extras=rep.extras",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.SystemStats",
        "import:fastapi.description=\"Filter by position\")",
        "import:fastapi.BillResponse",
        "import:fastapi.description=\"Search query for representative name\")",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.level_order=level.level_order",
        "import:fastapi.OfficeResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/government-levels/{level_id}\"",
        "import:fastapi.and jurisdiction type.\n    \"\"\"\n    # Build base query\n    query = db.query(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if jurisdiction_type:\n        query = query.filter(Jurisdiction.jurisdiction_type == jurisdiction_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get jurisdictions\n    jurisdictions = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    jurisdiction_responses = []\n    for jurisdiction in jurisdictions:\n        # Get government level details\n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.detail=\"Representative not found\")\n    \n    # Get jurisdiction details\n    jurisdiction = db.query(Jurisdiction).filter(\n        Jurisdiction.id == representative.jurisdiction_id\n    ).first()\n    \n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.email=rep.email",
        "import:fastapi.and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Representative).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Representative.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if party:\n        query = query.filter(Representative.party.ilike(f\"%{party}%\"))\n    \n    if position:\n        query = query.filter(Representative.position == position)\n    \n    # Apply search if query provided\n    if q:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================\n\n@router.get(\"/government-levels\"",
        "import:fastapi.metadata_json=representative.metadata_json",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific representative by ID.\n    \n    Returns detailed information about a representative including jurisdiction and government level.\n    \"\"\"\n    representative = db.query(Representative).filter(Representative.id == representative_id).first()\n    \n    if not representative:\n        raise HTTPException(status_code=404",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.province",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        representative_responses.append(RepresentativeResponse(\n            id=str(rep.id)",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.description=\"Representative ID\")",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.response_model=RepresentativeResponse)\nasync def get_representative(\n    representative_id: str = Path(...",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.position=representative.position",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return JurisdictionListResponse(items=jurisdiction_responses",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    jurisdiction_response = JurisdictionResponse(\n        id=str(jurisdiction.id)"
      ]
    },
    "GET:/stats/government-levels/{level_id}": {
      "method": "GET",
      "path": "/stats/government-levels/{level_id}",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 456,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by political party\")",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/representatives/{representative_id}\"",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/jurisdictions/{jurisdiction_id}\"",
        "import:fastapi.description=\"Filter by jurisdiction ID\")",
        "import:fastapi.total_offices=total_offices",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.name=level.name",
        "import:fastapi.updated_at=representative.updated_at\n    )\n\n\n# ============================================================================\n# Statistics Endpoints\n# ============================================================================\n\n@router.get(\"/stats/system\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=GovernmentLevelListResponse)\nasync def list_government_levels(\n    page: int = Query(1",
        "import:fastapi.position=rep.position",
        "import:fastapi.party=rep.party",
        "import:fastapi.jurisdiction_id=str(rep.jurisdiction_id)",
        "import:fastapi.government_level: Optional[str] = Query(None",
        "import:fastapi.website=representative.website",
        "import:fastapi.le=100",
        "import:fastapi.BillSearchParams",
        "import:fastapi.last_updated=datetime.utcnow()\n    )",
        "import:fastapi.description=\"Government level ID\")",
        "import:fastapi.updated_at=level.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n    \n    return RepresentativeResponse(\n        id=str(representative.id)",
        "import:fastapi.phone=representative.phone",
        "import:fastapi.Municipal).\n    \n    Returns government levels ordered by their level_order.\n    \"\"\"\n    # Get total count\n    total = db.query(GovernmentLevel).count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get government levels\n    levels = db.query(GovernmentLevel).order_by(GovernmentLevel.level_order).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    level_responses = []\n    for level in levels:\n        level_responses.append(GovernmentLevelResponse(\n            id=str(level.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all government levels (Federal",
        "import:fastapi.response_model=JurisdictionResponse)\nasync def get_jurisdiction(\n    jurisdiction_id: str = Path(...",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n\n\n# ============================================================================\n# Representatives Endpoints\n# ============================================================================\n\n@router.get(\"/representatives\"",
        "import:fastapi.riding=representative.riding",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_responses.append(JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.Office",
        "import:fastapi.created_at=level.created_at",
        "import:fastapi.jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.description=\"Jurisdiction ID\")",
        "import:fastapi.website=rep.website",
        "import:fastapi.response_model=JurisdictionListResponse)\nasync def list_jurisdictions(\n    government_level: Optional[str] = Query(None",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "import:fastapi.response_model=RepresentativeListResponse)\nasync def list_representatives(\n    q: Optional[str] = Query(None",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.name=rep.name",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    return JurisdictionResponse(\n        id=str(jurisdiction.id)",
        "import:fastapi.VoteResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific government level by ID.\n    \n    Returns detailed information about a government level.\n    \"\"\"\n    level = db.query(GovernmentLevel).filter(GovernmentLevel.id == level_id).first()\n    \n    if not level:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=level.updated_at\n    )\n\n\n# ============================================================================\n# Jurisdictions Endpoints\n# ============================================================================\n\n@router.get(\"/jurisdictions\"",
        "import:fastapi.updated_at=rep.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all representatives across all government levels.\n    \n    Supports search",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.total_jurisdictions=total_jurisdictions",
        "import:fastapi.position: Optional[str] = Query(None",
        "import:fastapi.phone=rep.phone",
        "import:fastapi.description=level.description",
        "import:fastapi.GovernmentLevelListResponse",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.Provincial",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.Depends",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return GovernmentLevelListResponse(items=level_responses",
        "import:fastapi.VoteListResponse",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.name=representative.name",
        "import:fastapi.created_at=representative.created_at",
        "import:fastapi.representatives.name) @@ plainto_tsquery('english'",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.party=representative.party",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_response = JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.riding=rep.riding",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.description=\"Filter by jurisdiction type\")",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.email=representative.email",
        "import:fastapi.extras=representative.extras",
        "import:fastapi.response_model=GovernmentLevelResponse)\nasync def get_government_level(\n    level_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return RepresentativeListResponse(items=representative_responses",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific jurisdiction by ID.\n    \n    Returns detailed information about a jurisdiction including its government level.\n    \"\"\"\n    jurisdiction = db.query(Jurisdiction).filter(Jurisdiction.id == jurisdiction_id).first()\n    \n    if not jurisdiction:\n        raise HTTPException(status_code=404",
        "import:fastapi.jurisdiction_type: Optional[str] = Query(None",
        "import:fastapi.detail=\"Government level not found\")\n    \n    return GovernmentLevelResponse(\n        id=str(level.id)",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.detail=\"Jurisdiction not found\")\n    \n    # Get government level details\n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get representatives\n    representatives = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    representative_responses = []\n    for rep in representatives:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == rep.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.jurisdiction_id=str(representative.jurisdiction_id)",
        "import:fastapi.Optional",
        "import:fastapi.filtering",
        "import:fastapi.metadata_json=rep.metadata_json",
        "import:fastapi.Jurisdiction",
        "import:fastapi.created_at=rep.created_at",
        "import:fastapi.description=\"Items per page\")",
        "function:get_system_stats",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all jurisdictions across all government levels.\n    \n    Supports filtering by government level",
        "import:fastapi.Query",
        "import:fastapi.jurisdiction=jurisdiction_response",
        "import:fastapi.total=total",
        "import:fastapi.extras=rep.extras",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.SystemStats",
        "import:fastapi.description=\"Filter by position\")",
        "import:fastapi.BillResponse",
        "import:fastapi.description=\"Search query for representative name\")",
        "import:fastapi.total_data_sources=total_data_sources",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.level_order=level.level_order",
        "import:fastapi.OfficeResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/government-levels/{level_id}\"",
        "import:fastapi.and jurisdiction type.\n    \"\"\"\n    # Build base query\n    query = db.query(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if jurisdiction_type:\n        query = query.filter(Jurisdiction.jurisdiction_type == jurisdiction_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get jurisdictions\n    jurisdictions = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    jurisdiction_responses = []\n    for jurisdiction in jurisdictions:\n        # Get government level details\n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.total_representatives=total_representatives",
        "import:fastapi.detail=\"Representative not found\")\n    \n    # Get jurisdiction details\n    jurisdiction = db.query(Jurisdiction).filter(\n        Jurisdiction.id == representative.jurisdiction_id\n    ).first()\n    \n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.email=rep.email",
        "import:fastapi.and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Representative).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Representative.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if party:\n        query = query.filter(Representative.party.ilike(f\"%{party}%\"))\n    \n    if position:\n        query = query.filter(Representative.position == position)\n    \n    # Apply search if query provided\n    if q:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================\n\n@router.get(\"/government-levels\"",
        "import:fastapi.metadata_json=representative.metadata_json",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific representative by ID.\n    \n    Returns detailed information about a representative including jurisdiction and government level.\n    \"\"\"\n    representative = db.query(Representative).filter(Representative.id == representative_id).first()\n    \n    if not representative:\n        raise HTTPException(status_code=404",
        "import:fastapi.response_model=SystemStats)\nasync def get_system_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get system-wide statistics.\n    \n    Returns counts of all major data types across the system.\n    \"\"\"\n    # Get counts\n    total_government_levels = db.query(GovernmentLevel).count()\n    total_jurisdictions = db.query(Jurisdiction).count()\n    total_representatives = db.query(Representative).count()\n    total_bills = db.query(Bill).count()\n    total_votes = db.query(Vote).count()\n    total_offices = db.query(Office).count()\n    total_data_sources = db.query(DataSource).count()\n    \n    return SystemStats(\n        total_government_levels=total_government_levels",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.province",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        representative_responses.append(RepresentativeResponse(\n            id=str(rep.id)",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.description=\"Representative ID\")",
        "import:fastapi.total_bills=total_bills",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.response_model=RepresentativeResponse)\nasync def get_representative(\n    representative_id: str = Path(...",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.position=representative.position",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.total_votes=total_votes",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return JurisdictionListResponse(items=jurisdiction_responses",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    jurisdiction_response = JurisdictionResponse(\n        id=str(jurisdiction.id)"
      ]
    },
    "GET:/stats/jurisdictions/{jurisdiction_id}": {
      "method": "GET",
      "path": "/stats/jurisdictions/{jurisdiction_id}",
      "file": "services/api-gateway/app/api/v1/multi_level_government.py",
      "line": 504,
      "dependencies": [
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.description=\"Filter by political party\")",
        "import:fastapi.description=\"Filter by province/territory\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/representatives/{representative_id}\"",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/jurisdictions/{jurisdiction_id}\"",
        "import:fastapi.description=\"Filter by jurisdiction ID\")",
        "import:fastapi.total_offices=total_offices",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.name=level.name",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get statistics for a specific government level.\n    \n    Returns counts of jurisdictions",
        "import:fastapi.and offices for the level.\n    \"\"\"\n    # Verify government level exists\n    gov_level = db.query(GovernmentLevel).filter(GovernmentLevel.id == level_id).first()\n    if not gov_level:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=representative.updated_at\n    )\n\n\n# ============================================================================\n# Statistics Endpoints\n# ============================================================================\n\n@router.get(\"/stats/system\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=GovernmentLevelListResponse)\nasync def list_government_levels(\n    page: int = Query(1",
        "import:fastapi.position=rep.position",
        "import:fastapi.party=rep.party",
        "import:fastapi.jurisdiction_id=str(rep.jurisdiction_id)",
        "import:fastapi.government_level: Optional[str] = Query(None",
        "import:fastapi.website=representative.website",
        "import:fastapi.le=100",
        "import:fastapi.BillSearchParams",
        "import:fastapi.detail=\"Government level not found\")\n    \n    # Get counts for this level\n    total_jurisdictions = db.query(Jurisdiction).filter(\n        Jurisdiction.government_level_id == level_id\n    ).count()\n    \n    total_representatives = db.query(Representative).join(Jurisdiction).filter(\n        Jurisdiction.government_level_id == level_id\n    ).count()\n    \n    total_bills = db.query(Bill).join(Jurisdiction).filter(\n        Jurisdiction.government_level_id == level_id\n    ).count()\n    \n    total_votes = db.query(Vote).join(Bill).join(Jurisdiction).filter(\n        Jurisdiction.government_level_id == level_id\n    ).count()\n    \n    total_offices = db.query(Office).join(Jurisdiction).filter(\n        Jurisdiction.government_level_id == level_id\n    ).count()\n    \n    return GovernmentLevelStats(\n        level_id=level_id",
        "import:fastapi.last_updated=datetime.utcnow()\n    )",
        "import:fastapi.description=\"Government level ID\")",
        "import:fastapi.updated_at=level.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.has_next=page < total_pages",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n    \n    return RepresentativeResponse(\n        id=str(representative.id)",
        "import:fastapi.phone=representative.phone",
        "import:fastapi.Municipal).\n    \n    Returns government levels ordered by their level_order.\n    \"\"\"\n    # Get total count\n    total = db.query(GovernmentLevel).count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get government levels\n    levels = db.query(GovernmentLevel).order_by(GovernmentLevel.level_order).offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    level_responses = []\n    for level in levels:\n        level_responses.append(GovernmentLevelResponse(\n            id=str(level.id)",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all government levels (Federal",
        "import:fastapi.response_model=JurisdictionResponse)\nasync def get_jurisdiction(\n    jurisdiction_id: str = Path(...",
        "import:fastapi.province=jurisdiction.province",
        "import:fastapi.updated_at=jurisdiction.updated_at\n    )\n\n\n# ============================================================================\n# Representatives Endpoints\n# ============================================================================\n\n@router.get(\"/representatives\"",
        "import:fastapi.riding=representative.riding",
        "import:fastapi.last_updated=datetime.utcnow()\n    )\n\n\n@router.get(\"/stats/government-levels/{level_id}\"",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_responses.append(JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.Office",
        "import:fastapi.created_at=level.created_at",
        "import:fastapi.jurisdiction_id: Optional[str] = Query(None",
        "import:fastapi.jurisdiction_type=jurisdiction.jurisdiction_type",
        "import:fastapi.description=\"Jurisdiction ID\")",
        "import:fastapi.website=rep.website",
        "import:fastapi.response_model=JurisdictionListResponse)\nasync def list_jurisdictions(\n    government_level: Optional[str] = Query(None",
        "import:fastapi.HTTPException",
        "import:fastapi.Representative",
        "function:get_government_level_stats",
        "import:fastapi.response_model=RepresentativeListResponse)\nasync def list_representatives(\n    q: Optional[str] = Query(None",
        "import:fastapi.DataSource",
        "import:fastapi.RepresentativeListResponse",
        "import:fastapi.Any\nfrom datetime import datetime",
        "import:fastapi.code=jurisdiction.code",
        "import:fastapi.name=rep.name",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    return JurisdictionResponse(\n        id=str(jurisdiction.id)",
        "import:fastapi.VoteResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific government level by ID.\n    \n    Returns detailed information about a government level.\n    \"\"\"\n    level = db.query(GovernmentLevel).filter(GovernmentLevel.id == level_id).first()\n    \n    if not level:\n        raise HTTPException(status_code=404",
        "import:fastapi.updated_at=level.updated_at\n    )\n\n\n# ============================================================================\n# Jurisdictions Endpoints\n# ============================================================================\n\n@router.get(\"/jurisdictions\"",
        "import:fastapi.updated_at=rep.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.JurisdictionResponse",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all representatives across all government levels.\n    \n    Supports search",
        "import:fastapi.func",
        "import:fastapi.and_",
        "import:fastapi.name=gov_level.name",
        "import:fastapi.total_jurisdictions=total_jurisdictions",
        "import:fastapi.position: Optional[str] = Query(None",
        "import:fastapi.phone=rep.phone",
        "import:fastapi.description=level.description",
        "import:fastapi.GovernmentLevelListResponse",
        "import:fastapi.government_level_id=str(jurisdiction.government_level_id)",
        "import:fastapi.Provincial",
        "import:fastapi.website=jurisdiction.website",
        "import:fastapi.Depends",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return GovernmentLevelListResponse(items=level_responses",
        "import:fastapi.VoteListResponse",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        ))\n    \n    # Create pagination info\n    pagination = PaginationInfo(\n        page=page",
        "import:fastapi.party: Optional[str] = Query(None",
        "import:fastapi.representatives",
        "import:fastapi.name=representative.name",
        "import:fastapi.created_at=representative.created_at",
        "import:fastapi.representatives.name) @@ plainto_tsquery('english'",
        "import:fastapi.or_\nfrom typing import List",
        "import:fastapi.timedelta\nimport math\n\nfrom app.database import get_db\nfrom app.models.government_levels_simple import (\n    GovernmentLevel",
        "import:fastapi.party=representative.party",
        "import:fastapi.updated_at=gov_level.updated_at\n        )\n        \n        jurisdiction_response = JurisdictionResponse(\n            id=str(jurisdiction.id)",
        "import:fastapi.created_at=jurisdiction.created_at",
        "import:fastapi.riding=rep.riding",
        "import:fastapi.DataSourceResponse",
        "import:fastapi.description=\"Filter by jurisdiction type\")",
        "import:fastapi.extras=jurisdiction.extras",
        "import:fastapi.email=representative.email",
        "import:fastapi.extras=representative.extras",
        "import:fastapi.response_model=GovernmentLevelResponse)\nasync def get_government_level(\n    level_id: str = Path(...",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return RepresentativeListResponse(items=representative_responses",
        "import:fastapi.level_order=gov_level.level_order",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific jurisdiction by ID.\n    \n    Returns detailed information about a jurisdiction including its government level.\n    \"\"\"\n    jurisdiction = db.query(Jurisdiction).filter(Jurisdiction.id == jurisdiction_id).first()\n    \n    if not jurisdiction:\n        raise HTTPException(status_code=404",
        "import:fastapi.level_name=gov_level.name",
        "import:fastapi.jurisdiction_type: Optional[str] = Query(None",
        "import:fastapi.detail=\"Government level not found\")\n    \n    return GovernmentLevelResponse(\n        id=str(level.id)",
        "import:fastapi.Path\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.detail=\"Jurisdiction not found\")\n    \n    # Get government level details\n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get representatives\n    representatives = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    representative_responses = []\n    for rep in representatives:\n        # Get jurisdiction details\n        jurisdiction = db.query(Jurisdiction).filter(\n            Jurisdiction.id == rep.jurisdiction_id\n        ).first()\n        \n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.jurisdiction_id=str(representative.jurisdiction_id)",
        "import:fastapi.Optional",
        "import:fastapi.filtering",
        "import:fastapi.metadata_json=rep.metadata_json",
        "import:fastapi.Jurisdiction",
        "import:fastapi.created_at=rep.created_at",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List all jurisdictions across all government levels.\n    \n    Supports filtering by government level",
        "import:fastapi.Query",
        "import:fastapi.jurisdiction=jurisdiction_response",
        "import:fastapi.total=total",
        "import:fastapi.extras=rep.extras",
        "import:fastapi.created_at=gov_level.created_at",
        "import:fastapi.bills",
        "import:fastapi.SystemStats",
        "import:fastapi.description=\"Filter by position\")",
        "import:fastapi.BillResponse",
        "import:fastapi.description=\"Search query for representative name\")",
        "import:fastapi.total_data_sources=total_data_sources",
        "import:fastapi.VoteSearchParams",
        "import:fastapi.province: Optional[str] = Query(None",
        "import:fastapi.government_level=gov_level_response",
        "import:fastapi.level_order=level.level_order",
        "import:fastapi.OfficeResponse",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.pagination=pagination)\n\n\n@router.get(\"/government-levels/{level_id}\"",
        "import:fastapi.and jurisdiction type.\n    \"\"\"\n    # Build base query\n    query = db.query(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if jurisdiction_type:\n        query = query.filter(Jurisdiction.jurisdiction_type == jurisdiction_type)\n    \n    # Get total count\n    total = query.count()\n    \n    # Calculate pagination\n    total_pages = math.ceil(total / page_size)\n    offset = (page - 1) * page_size\n    \n    # Get jurisdictions\n    jurisdictions = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    jurisdiction_responses = []\n    for jurisdiction in jurisdictions:\n        # Get government level details\n        gov_level = db.query(GovernmentLevel).filter(\n            GovernmentLevel.id == jurisdiction.government_level_id\n        ).first()\n        \n        gov_level_response = GovernmentLevelResponse(\n            id=str(gov_level.id)",
        "import:fastapi.total_representatives=total_representatives",
        "import:fastapi.detail=\"Representative not found\")\n    \n    # Get jurisdiction details\n    jurisdiction = db.query(Jurisdiction).filter(\n        Jurisdiction.id == representative.jurisdiction_id\n    ).first()\n    \n    gov_level = db.query(GovernmentLevel).filter(\n        GovernmentLevel.id == jurisdiction.government_level_id\n    ).first()\n    \n    gov_level_response = GovernmentLevelResponse(\n        id=str(gov_level.id)",
        "import:fastapi.response_model=GovernmentLevelStats)\nasync def get_government_level_stats(\n    level_id: str = Path(...",
        "import:fastapi.email=rep.email",
        "import:fastapi.and pagination.\n    \"\"\"\n    # Build base query\n    query = db.query(Representative).join(Jurisdiction).join(GovernmentLevel)\n    \n    # Apply filters\n    if jurisdiction_id:\n        query = query.filter(Representative.jurisdiction_id == jurisdiction_id)\n    \n    if government_level:\n        query = query.filter(Jurisdiction.government_level_id == government_level)\n    \n    if province:\n        query = query.filter(Jurisdiction.province == province)\n    \n    if party:\n        query = query.filter(Representative.party.ilike(f\"%{party}%\"))\n    \n    if position:\n        query = query.filter(Representative.position == position)\n    \n    # Apply search if query provided\n    if q:\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.DataSourceListResponse",
        "import:fastapi.PaginationInfo\n)\n\nrouter = APIRouter()\n\n\n# ============================================================================\n# Government Levels Endpoints\n# ============================================================================\n\n@router.get(\"/government-levels\"",
        "import:fastapi.metadata_json=representative.metadata_json",
        "import:fastapi.total_pages=total_pages",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get a specific representative by ID.\n    \n    Returns detailed information about a representative including jurisdiction and government level.\n    \"\"\"\n    representative = db.query(Representative).filter(Representative.id == representative_id).first()\n    \n    if not representative:\n        raise HTTPException(status_code=404",
        "import:fastapi.response_model=SystemStats)\nasync def get_system_stats(db: DBSession = Depends(get_db)):\n    \"\"\"\n    Get system-wide statistics.\n    \n    Returns counts of all major data types across the system.\n    \"\"\"\n    # Get counts\n    total_government_levels = db.query(GovernmentLevel).count()\n    total_jurisdictions = db.query(Jurisdiction).count()\n    total_representatives = db.query(Representative).count()\n    total_bills = db.query(Bill).count()\n    total_votes = db.query(Vote).count()\n    total_offices = db.query(Office).count()\n    total_data_sources = db.query(DataSource).count()\n    \n    return SystemStats(\n        total_government_levels=total_government_levels",
        "import:fastapi.description=\"Filter by government level ID\")",
        "import:fastapi.description=gov_level.description",
        "import:fastapi.Vote",
        "import:fastapi.RepresentativeResponse",
        "import:fastapi.province",
        "import:fastapi.updated_at=jurisdiction.updated_at\n        )\n        \n        representative_responses.append(RepresentativeResponse(\n            id=str(rep.id)",
        "import:fastapi.name=jurisdiction.name",
        "import:fastapi.description=\"Representative ID\")",
        "import:fastapi.total_bills=total_bills",
        "import:fastapi.votes",
        "import:fastapi.GovernmentLevelStats",
        "import:fastapi.IngestionLog\n)\nfrom app.schemas.multi_level_government import (\n    GovernmentLevelResponse",
        "import:fastapi.response_model=RepresentativeResponse)\nasync def get_representative(\n    representative_id: str = Path(...",
        "import:fastapi.OfficeListResponse",
        "import:fastapi.position=representative.position",
        "import:fastapi.JurisdictionListResponse",
        "import:fastapi.total_votes=total_votes",
        "import:fastapi.Dict",
        "import:fastapi.APIRouter",
        "import:fastapi.JurisdictionStats",
        "import:fastapi.RepresentativeSearchParams",
        "import:fastapi.BillListResponse",
        "import:fastapi.has_prev=page > 1\n    )\n    \n    return JurisdictionListResponse(items=jurisdiction_responses",
        "import:fastapi.updated_at=gov_level.updated_at\n    )\n    \n    jurisdiction_response = JurisdictionResponse(\n        id=str(jurisdiction.id)"
      ]
    },
    "GET:/bills/{bill_id}/mentions": {
      "method": "GET",
      "path": "/bills/{bill_id}/mentions",
      "file": "services/api-gateway/app/api/v1/house_mentions.py",
      "line": 18,
      "dependencies": [
        "import:fastapi.Riding\n\nrouter = APIRouter()",
        "import:fastapi.Party",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.Query",
        "import:fastapi.List\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.VoteQuestion",
        "import:fastapi.APIRouter",
        "import:fastapi.Politician",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember"
      ]
    },
    "GET:/debates/mentions": {
      "method": "GET",
      "path": "/debates/mentions",
      "file": "services/api-gateway/app/api/v1/house_mentions.py",
      "line": 119,
      "dependencies": [
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"mention_type\": \"committee\"",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"mention_date\": \"2025-01-10\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.\"context\": \"Second reading debate on the bill\"",
        "import:fastapi.List\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"total\": total",
        "import:fastapi.\"source\": \"House of Commons Votes\"\n        }\n    ]\n    \n    # Apply pagination\n    total = len(mock_mentions)\n    offset = (page - 1) * page_size\n    paginated_mentions = mock_mentions[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_mentions",
        "import:fastapi.\"bill_id\": str(bill_id)",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"mention_type\": \"vote\"",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.create mock house mention data\n    # In a full implementation",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.\"speaker_constituency\": \"Calgary Centre\"",
        "import:fastapi.\"speaker_constituency\": \"N/A\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.\"media_coverage\": []",
        "import:fastapi.\"transcript_excerpt\": f\"The question is on the motion for second reading of {bill.name_en}...\"",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.\"debate_url\": None",
        "import:fastapi.\"context\": \"Vote on second reading\"",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.\"public_response\": None",
        "import:fastapi.\"mention_date\": \"2025-01-05\"",
        "import:fastapi.Politician",
        "import:fastapi.\"speaker_name\": \"Speaker of the House\"",
        "import:fastapi.\"vote_reference\": f\"Vote {bill.number}-2025-01-05\"",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "function:get_bill_house_mentions",
        "import:fastapi.ge=1",
        "import:fastapi.\"speaker_party\": \"Liberal\"",
        "import:fastapi.\"bill_info\": {\n            \"id\": str(bill.id)",
        "import:fastapi.\"short_title\": bill.short_title_en",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get house mentions for a specific bill.\n    Tracks when and how bills are mentioned in parliamentary debates.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"speaker_party\": \"Conservative\"",
        "import:fastapi.\"speaker_name\": \"Committee Chair\"",
        "import:fastapi.\"context\": \"Committee study of the bill\"",
        "import:fastapi.Query",
        "import:fastapi.\"debate_url\": f\"/debates/2025-01-15/bill-{bill.number}\"",
        "import:fastapi.VoteQuestion",
        "import:fastapi.le=100",
        "import:fastapi.\"committee_reference\": \"Standing Committee on Justice\"",
        "import:fastapi.\"introduced_date\": bill.introduced\n        }\n    }",
        "import:fastapi.\"committee_reference\": None",
        "import:fastapi.\"transcript_excerpt\": f\"The honourable member has introduced {bill.name_en} which addresses important concerns...\"",
        "import:fastapi.\"transcript_excerpt\": f\"The committee will now study {bill.name_en} in detail...\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Smith\"",
        "import:fastapi.\"source\": \"Committee Minutes\"\n        }",
        "import:fastapi.Party",
        "import:fastapi.\"vote_reference\": None",
        "import:fastapi.\"mention_date\": \"2025-01-15\"",
        "import:fastapi.\"source\": \"House of Commons Hansard\"\n        }",
        "import:fastapi.\"mention_type\": \"debate\"",
        "import:fastapi.\"speaker_constituency\": \"Toronto Centre\"",
        "import:fastapi.\"speaker_party\": \"Independent\"",
        "import:fastapi.APIRouter",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/bills/{bill_id}/mentions\")\nasync def get_bill_house_mentions(\n    bill_id: int",
        "import:fastapi.this would come from debate transcripts and committee records\n    mock_mentions = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.HTTPException",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/committees/mentions": {
      "method": "GET",
      "path": "/committees/mentions",
      "file": "services/api-gateway/app/api/v1/house_mentions.py",
      "line": 242,
      "dependencies": [
        "import:fastapi.\"introduced_date\": bill.introduced\n        }\n    }\n\n\n@router.get(\"/debates/mentions\")\nasync def get_debate_mentions(\n    q: Optional[str] = Query(None",
        "import:fastapi.\"speaker_constituency\": \"Ottawa Centre\"",
        "import:fastapi.\"context\": \"Second reading debate on the bill\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Wilson\"",
        "import:fastapi.List\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"Global News\"]",
        "function:get_debate_mentions",
        "import:fastapi.\"transcript_excerpt\": f\"The question is on the motion for second reading of {bill.name_en}...\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Johnson\"",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.\"speaker_constituency\": \"Calgary Centre\"",
        "import:fastapi.\"speaker_constituency\": \"N/A\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Politician filter\")",
        "import:fastapi.\"context\": \"Vote on second reading\"",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"debate_date\": \"2025-01-14\"",
        "import:fastapi.\"related_question\": None",
        "import:fastapi.Politician",
        "import:fastapi.ge=1",
        "import:fastapi.\"bill_info\": {\n            \"id\": str(bill.id)",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.\"public_response\": \"Positive social media engagement\"",
        "import:fastapi.\"debate_url\": \"/debates/2025-01-14/government-orders\"",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"context\": \"Committee study of the bill\"",
        "import:fastapi.le=100",
        "import:fastapi.\"speaker_constituency\": \"Calgary Southwest\"",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }\n    }",
        "import:fastapi.HTTPException",
        "import:fastapi.\"related_bill\": \"C-123\"",
        "import:fastapi.\"related_bill\": None",
        "import:fastapi.create mock debate mention data\n    # In a full implementation",
        "import:fastapi.\"debate_type\": \"Question Period\"",
        "import:fastapi.description=\"Type of mention (bill",
        "import:fastapi.\"media_coverage\": [\"CBC News\"",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.\"debate_url\": \"/debates/2025-01-15/question-period\"",
        "import:fastapi.\"media_coverage\": []",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.\"public_response\": None",
        "import:fastapi.\"speaker_party\": \"Liberal\"",
        "import:fastapi.\"mention_type\": \"motion\"",
        "import:fastapi.\"related_question\": \"Q-123\"",
        "import:fastapi.\"filters_applied\": {\n            \"search_query\": q",
        "import:fastapi.\"mention_type\": \"constituency\"",
        "import:fastapi.\"speaker_name\": \"Committee Chair\"",
        "import:fastapi.\"debate_url\": f\"/debates/2025-01-15/bill-{bill.number}\"",
        "import:fastapi.\"mention_content\": \"Bill C-123 on environmental protection\"",
        "import:fastapi.\"mention_type\": mention_type",
        "import:fastapi.\"committee_reference\": None",
        "import:fastapi.\"transcript_excerpt\": f\"The honourable member has introduced {bill.name_en} which addresses important concerns...\"",
        "import:fastapi.\"transcript_excerpt\": \"I rise today to highlight an important infrastructure project in my riding...\"",
        "import:fastapi.Party",
        "import:fastapi.\"vote_reference\": None",
        "import:fastapi.\"public_response\": \"Local media coverage\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/bills/{bill_id}/mentions\")\nasync def get_bill_house_mentions(\n    bill_id: int",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"mention_type\": \"committee\"",
        "import:fastapi.\"debate_session\": \"44-1\"",
        "import:fastapi.\"source\": \"House of Commons Votes\"\n        }\n    ]\n    \n    # Apply pagination\n    total = len(mock_mentions)\n    offset = (page - 1) * page_size\n    paginated_mentions = mock_mentions[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_mentions",
        "import:fastapi.\"public_response\": \"Mixed parliamentary response\"",
        "import:fastapi.\"bill_id\": str(bill_id)",
        "import:fastapi.politician: Optional[str] = Query(None",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"debate_date\": \"2025-01-15\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.create mock house mention data\n    # In a full implementation",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.\"debate_url\": None",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.\"mention_date\": \"2025-01-05\"",
        "import:fastapi.\"speaker_name\": \"Speaker of the House\"",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"vote_reference\": f\"Vote {bill.number}-2025-01-05\"",
        "import:fastapi.\"debate_url\": \"/debates/2025-01-13/statements\"",
        "import:fastapi.\"mention_type\": \"bill\"",
        "import:fastapi.\"short_title\": bill.short_title_en",
        "import:fastapi.\"mention_content\": \"Motion to extend sitting hours\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get house mentions for a specific bill.\n    Tracks when and how bills are mentioned in parliamentary debates.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"speaker_party\": \"Conservative\"",
        "import:fastapi.\"politician\": politician",
        "import:fastapi.Query",
        "import:fastapi.\"transcript_excerpt\": \"The honourable member asks about the government's commitment to Bill C-123...\"",
        "import:fastapi.\"transcript_excerpt\": f\"The committee will now study {bill.name_en} in detail...\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Smith\"",
        "import:fastapi.\"source\": \"Committee Minutes\"\n        }",
        "import:fastapi.motion",
        "import:fastapi.\"debate_type\": \"Statements by Members\"",
        "import:fastapi.\"debate_date\": \"2025-01-13\"",
        "import:fastapi.\"speaker_constituency\": \"Toronto Centre\"",
        "import:fastapi.\"speaker_party\": \"Independent\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get debate mentions with advanced filtering.\n    Searches through parliamentary debate transcripts for specific content.\n    \"\"\"\n    # For now",
        "import:fastapi.this would come from debate transcripts and committee records\n    mock_mentions = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.description=\"Search query for debate content\")",
        "import:fastapi.\"speaker_party\": \"Green\"",
        "import:fastapi.\"media_coverage\": [\"CTV News\"]",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"debate_type\": \"Government Orders\"",
        "import:fastapi.\"mention_date\": \"2025-01-10\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.question)\")",
        "import:fastapi.\"total\": total",
        "import:fastapi.this would search through actual debate transcripts\n    mock_debate_mentions = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"speaker_constituency\": \"Vancouver Island\"",
        "import:fastapi.\"mention_type\": \"vote\"",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.\"mention_content\": \"Local infrastructure project\"",
        "import:fastapi.\"related_motion\": \"M-456\"",
        "import:fastapi.\"source\": \"House of Commons Hansard\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_mentions = mock_debate_mentions\n    \n    if q:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if q.lower() in mention[\"mention_content\"].lower() or \n               q.lower() in mention[\"transcript_excerpt\"].lower()\n        ]\n    \n    if politician:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if politician.lower() in mention[\"speaker_name\"].lower()\n        ]\n    \n    if mention_type:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if mention[\"mention_type\"] == mention_type\n        ]\n    \n    # Apply pagination\n    total = len(filtered_mentions)\n    offset = (page - 1) * page_size\n    paginated_mentions = filtered_mentions[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_mentions",
        "import:fastapi.mention_type: Optional[str] = Query(None",
        "import:fastapi.\"media_coverage\": [\"Calgary Herald\"]",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"committee_reference\": \"Standing Committee on Justice\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Davis\"",
        "import:fastapi.\"related_motion\": None",
        "import:fastapi.\"mention_date\": \"2025-01-15\"",
        "import:fastapi.\"source\": \"House of Commons Hansard\"\n        }",
        "import:fastapi.\"mention_type\": \"debate\"",
        "import:fastapi.\"transcript_excerpt\": \"I move that the House extend its sitting hours to complete consideration of...\"",
        "import:fastapi.APIRouter",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/votes/detailed": {
      "method": "GET",
      "path": "/votes/detailed",
      "file": "services/api-gateway/app/api/v1/house_mentions.py",
      "line": 365,
      "dependencies": [
        "import:fastapi.\"organization\": \"Parliamentary Budget Office\"}\n            ]",
        "import:fastapi.\"introduced_date\": bill.introduced\n        }\n    }\n\n\n@router.get(\"/debates/mentions\")\nasync def get_debate_mentions(\n    q: Optional[str] = Query(None",
        "import:fastapi.\"speaker_constituency\": \"Ottawa Centre\"",
        "import:fastapi.\"organization\": \"Bank of Canada\"}",
        "import:fastapi.\"context\": \"Second reading debate on the bill\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Wilson\"",
        "import:fastapi.List\nfrom app.database import get_db\nfrom app.models.openparliament import Bill",
        "import:fastapi.\"description\": \"Study on mental health service delivery across Canada\"",
        "import:fastapi.\"Global News\"]",
        "import:fastapi.and recommendations.\n    \"\"\"\n    # For now",
        "import:fastapi.\"transcript_excerpt\": f\"The question is on the motion for second reading of {bill.name_en}...\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Johnson\"",
        "import:fastapi.{\"name\": \"Hon. Member Johnson\"",
        "import:fastapi.detail=\"Bill not found\")\n    \n    # For now",
        "import:fastapi.\"speaker_constituency\": \"Calgary Centre\"",
        "import:fastapi.\"speaker_constituency\": \"N/A\"",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.description=\"Politician filter\")",
        "import:fastapi.\"activity_type\": \"study\"",
        "import:fastapi.\"witnesses\": [\n                {\"name\": \"Dr. Jane Wilson\"",
        "import:fastapi.\"topic\": \"Mental Health Services\"",
        "import:fastapi.{\"name\": \"Hon. Member Brown\"",
        "import:fastapi.\"committee_name\": committee_name",
        "import:fastapi.\"context\": \"Vote on second reading\"",
        "import:fastapi.\"title\": bill.name_en",
        "import:fastapi.\"debate_date\": \"2025-01-14\"",
        "import:fastapi.\"related_question\": None",
        "import:fastapi.Politician",
        "import:fastapi.ge=1",
        "import:fastapi.\"bill_info\": {\n            \"id\": str(bill.id)",
        "import:fastapi.\"has_prev\": page > 1\n        }",
        "import:fastapi.this would come from committee minutes and reports\n    mock_committee_mentions = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"activity_date\": \"2025-01-15\"",
        "import:fastapi.\"public_response\": \"Positive social media engagement\"",
        "import:fastapi.\"debate_url\": \"/debates/2025-01-14/government-orders\"",
        "import:fastapi.description=\"Start date (YYYY-MM-DD)\")",
        "import:fastapi.\"context\": \"Committee study of the bill\"",
        "import:fastapi.studies",
        "import:fastapi.le=100",
        "import:fastapi.\"role\": \"Member\"",
        "import:fastapi.\"speaker_constituency\": \"Calgary Southwest\"",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }\n    }",
        "import:fastapi.\"activity_type\": \"meeting\"",
        "import:fastapi.committee_name: Optional[str] = Query(None",
        "import:fastapi.description=\"Committee name search\")",
        "import:fastapi.\"recommendations\": [\n                \"Increase funding for green infrastructure\"",
        "import:fastapi.\"date_range\": f\"{date_from} to {date_to}\" if date_from and date_to else None\n        }\n    }\n\n\n@router.get(\"/committees/mentions\")\nasync def get_committee_mentions(\n    committee_id: Optional[str] = Query(None",
        "import:fastapi.\"committee_id\": \"HESA\"",
        "import:fastapi.\"topic\": topic",
        "import:fastapi.HTTPException",
        "import:fastapi.description=\"Committee identifier\")",
        "import:fastapi.\"filters_applied\": {\n            \"committee_id\": committee_id",
        "import:fastapi.\"related_bill\": \"C-123\"",
        "import:fastapi.\"related_bill\": None",
        "import:fastapi.create mock debate mention data\n    # In a full implementation",
        "import:fastapi.\"committee_name\": \"Standing Committee on Finance\"",
        "import:fastapi.\"debate_type\": \"Question Period\"",
        "import:fastapi.description=\"Type of mention (bill",
        "import:fastapi.\"report_url\": \"/committees/fina/reports/budget-2025\"",
        "import:fastapi.\"role\": \"Chair\"",
        "import:fastapi.\"media_coverage\": [\"CBC News\"",
        "import:fastapi.\"minutes_url\": \"/committees/hesa/minutes/2025-01-14\"",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional",
        "import:fastapi.\"bill_number\": bill.number",
        "import:fastapi.\"debate_url\": \"/debates/2025-01-15/question-period\"",
        "import:fastapi.\"media_coverage\": []",
        "import:fastapi.\"related_bills\": [\"C-123\"",
        "import:fastapi.\"bill_title\": bill.name_en",
        "import:fastapi.\"public_response\": None",
        "import:fastapi.\"C-124\"]",
        "import:fastapi.\"Health News\"]",
        "import:fastapi.\"speaker_party\": \"Liberal\"",
        "import:fastapi.\"mention_type\": \"motion\"",
        "import:fastapi.\"related_question\": \"Q-123\"",
        "import:fastapi.\"filters_applied\": {\n            \"search_query\": q",
        "import:fastapi.\"party\": \"Liberal\"}\n            ]",
        "import:fastapi.\"related_bills\": [\"C-125\"]",
        "import:fastapi.\"mention_type\": \"constituency\"",
        "import:fastapi.\"speaker_name\": \"Committee Chair\"",
        "import:fastapi.\"debate_url\": f\"/debates/2025-01-15/bill-{bill.number}\"",
        "import:fastapi.\"mention_content\": \"Bill C-123 on environmental protection\"",
        "import:fastapi.\"mention_type\": mention_type",
        "import:fastapi.\"committee_reference\": None",
        "import:fastapi.\"report_url\": \"/committees/hesa/reports/mental-health-2025\"",
        "import:fastapi.\"transcript_excerpt\": f\"The honourable member has introduced {bill.name_en} which addresses important concerns...\"",
        "import:fastapi.\"transcript_excerpt\": \"I rise today to highlight an important infrastructure project in my riding...\"",
        "import:fastapi.Party",
        "import:fastapi.\"vote_reference\": None",
        "import:fastapi.\"title\": \"Director\"",
        "import:fastapi.\"public_response\": \"Positive stakeholder feedback\"",
        "import:fastapi.\"public_response\": \"Local media coverage\"",
        "import:fastapi.{\"name\": \"Mr. Robert Brown\"",
        "import:fastapi.Riding\n\nrouter = APIRouter()\n\n\n@router.get(\"/bills/{bill_id}/mentions\")\nasync def get_bill_house_mentions(\n    bill_id: int",
        "import:fastapi.\"activity_date\": \"2025-01-14\"",
        "import:fastapi.\"participants\": [\n                {\"name\": \"Hon. Member Smith\"",
        "import:fastapi.\"has_next\": page * page_size < total",
        "import:fastapi.\"mention_type\": \"committee\"",
        "import:fastapi.\"debate_session\": \"44-1\"",
        "import:fastapi.\"description\": \"Committee meeting to study the federal budget\"",
        "import:fastapi.\"organization\": \"Canadian Psychiatric Association\"}",
        "import:fastapi.\"minutes_url\": \"/committees/fina/minutes/2025-01-15\"",
        "import:fastapi.\"source\": \"House of Commons Votes\"\n        }\n    ]\n    \n    # Apply pagination\n    total = len(mock_mentions)\n    offset = (page - 1) * page_size\n    paginated_mentions = mock_mentions[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_mentions",
        "import:fastapi.\"related_motions\": [\"M-457\"]",
        "import:fastapi.\"public_response\": \"Mixed parliamentary response\"",
        "import:fastapi.\"bill_id\": str(bill_id)",
        "import:fastapi.politician: Optional[str] = Query(None",
        "import:fastapi.\"page_size\": page_size",
        "import:fastapi.\"debate_date\": \"2025-01-15\"",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.create mock house mention data\n    # In a full implementation",
        "import:fastapi.description=\"End date (YYYY-MM-DD)\")",
        "import:fastapi.\"debate_url\": None",
        "import:fastapi.\"Review tax incentives for small businesses\"\n            ]",
        "import:fastapi.\"total_pages\": (total + page_size - 1) // page_size",
        "import:fastapi.\"mention_date\": \"2025-01-05\"",
        "import:fastapi.\"speaker_name\": \"Speaker of the House\"",
        "import:fastapi.\"committee_name\": \"Standing Committee on Health\"",
        "import:fastapi.date_to: Optional[str] = Query(None",
        "import:fastapi.\"vote_reference\": f\"Vote {bill.number}-2025-01-05\"",
        "import:fastapi.\"topic\": \"Federal Budget 2025\"",
        "import:fastapi.\"debate_url\": \"/debates/2025-01-13/statements\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get committee mentions and activity.\n    Tracks committee work",
        "import:fastapi.\"mention_type\": \"bill\"",
        "import:fastapi.\"short_title\": bill.short_title_en",
        "import:fastapi.\"mention_content\": \"Motion to extend sitting hours\"",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get house mentions for a specific bill.\n    Tracks when and how bills are mentioned in parliamentary debates.\n    \"\"\"\n    # Verify bill exists\n    bill = db.query(Bill).filter(Bill.id == bill_id).first()\n    if not bill:\n        raise HTTPException(status_code=404",
        "import:fastapi.\"witnesses\": [\n                {\"name\": \"Dr. Sarah Chen\"",
        "import:fastapi.\"speaker_party\": \"Conservative\"",
        "import:fastapi.\"politician\": politician",
        "import:fastapi.Query",
        "import:fastapi.topic: Optional[str] = Query(None",
        "import:fastapi.\"transcript_excerpt\": \"The honourable member asks about the government's commitment to Bill C-123...\"",
        "import:fastapi.\"transcript_excerpt\": f\"The committee will now study {bill.name_en} in detail...\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Smith\"",
        "import:fastapi.\"source\": \"Committee Minutes\"\n        }",
        "import:fastapi.motion",
        "import:fastapi.{\"name\": \"Hon. Member Davis\"",
        "import:fastapi.create mock committee mention data\n    # In a full implementation",
        "import:fastapi.\"title\": \"Executive Director\"",
        "import:fastapi.\"debate_type\": \"Statements by Members\"",
        "import:fastapi.\"debate_date\": \"2025-01-13\"",
        "import:fastapi.\"speaker_constituency\": \"Toronto Centre\"",
        "import:fastapi.\"speaker_party\": \"Independent\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get debate mentions with advanced filtering.\n    Searches through parliamentary debate transcripts for specific content.\n    \"\"\"\n    # For now",
        "import:fastapi.this would come from debate transcripts and committee records\n    mock_mentions = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.description=\"Search query for debate content\")",
        "import:fastapi.\"title\": \"Chief Economist\"",
        "import:fastapi.\"speaker_party\": \"Green\"",
        "import:fastapi.\"Financial Post\"]",
        "import:fastapi.\"role\": \"Vice-Chair\"",
        "import:fastapi.\"media_coverage\": [\"CTV News\"]",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.\"debate_type\": \"Government Orders\"",
        "import:fastapi.\"mention_date\": \"2025-01-10\"",
        "import:fastapi.{\n            \"id\": \"2\"",
        "import:fastapi.question)\")",
        "import:fastapi.\"total\": total",
        "import:fastapi.this would search through actual debate transcripts\n    mock_debate_mentions = [\n        {\n            \"id\": \"1\"",
        "import:fastapi.\"Improve access to services in rural areas\"\n            ]",
        "import:fastapi.\"public_response\": \"Strong public support\"",
        "import:fastapi.\"speaker_constituency\": \"Vancouver Island\"",
        "import:fastapi.\"mention_type\": \"vote\"",
        "import:fastapi.{\n            \"id\": \"3\"",
        "import:fastapi.date_from: Optional[str] = Query(None",
        "import:fastapi.\"party\": \"Liberal\"}",
        "import:fastapi.\"party\": \"Conservative\"}",
        "import:fastapi.\"mention_content\": \"Local infrastructure project\"",
        "import:fastapi.\"related_motion\": \"M-456\"",
        "import:fastapi.\"source\": \"House of Commons Hansard\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_mentions = mock_debate_mentions\n    \n    if q:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if q.lower() in mention[\"mention_content\"].lower() or \n               q.lower() in mention[\"transcript_excerpt\"].lower()\n        ]\n    \n    if politician:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if politician.lower() in mention[\"speaker_name\"].lower()\n        ]\n    \n    if mention_type:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if mention[\"mention_type\"] == mention_type\n        ]\n    \n    # Apply pagination\n    total = len(filtered_mentions)\n    offset = (page - 1) * page_size\n    paginated_mentions = filtered_mentions[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_mentions",
        "function:get_committee_mentions",
        "import:fastapi.mention_type: Optional[str] = Query(None",
        "import:fastapi.\"media_coverage\": [\"Calgary Herald\"]",
        "import:fastapi.\"related_motions\": [\"M-456\"]",
        "import:fastapi.\"participants\": [\n                {\"name\": \"Hon. Member Wilson\"",
        "import:fastapi.\"committee_id\": \"FINA\"",
        "import:fastapi.\"source\": \"Committee Minutes\"\n        }\n    ]\n    \n    # Apply filters\n    filtered_mentions = mock_committee_mentions\n    \n    if committee_id:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if mention[\"committee_id\"] == committee_id\n        ]\n    \n    if committee_name:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if committee_name.lower() in mention[\"committee_name\"].lower()\n        ]\n    \n    if topic:\n        filtered_mentions = [\n            mention for mention in filtered_mentions\n            if topic.lower() in mention[\"topic\"].lower() or \n               topic.lower() in mention[\"description\"].lower()\n        ]\n    \n    # Apply pagination\n    total = len(filtered_mentions)\n    offset = (page - 1) * page_size\n    paginated_mentions = filtered_mentions[offset:offset + page_size]\n    \n    return {\n        \"results\": paginated_mentions",
        "import:fastapi.VoteQuestion",
        "import:fastapi.\"committee_reference\": \"Standing Committee on Justice\"",
        "import:fastapi.\"speaker_name\": \"Hon. Member Davis\"",
        "import:fastapi.\"related_motion\": None",
        "import:fastapi.\"recommendations\": [\n                \"Increase mental health funding\"",
        "import:fastapi.description=\"Topic or subject matter\")",
        "import:fastapi.\"mention_date\": \"2025-01-15\"",
        "import:fastapi.\"party\": \"NDP\"}\n            ]",
        "import:fastapi.\"source\": \"House of Commons Hansard\"\n        }",
        "import:fastapi.\"mention_type\": \"debate\"",
        "import:fastapi.\"title\": \"Psychiatrist\"",
        "import:fastapi.\"transcript_excerpt\": \"I move that the House extend its sitting hours to complete consideration of...\"",
        "import:fastapi.APIRouter",
        "import:fastapi.{\"name\": \"Ms. Lisa Thompson\"",
        "import:fastapi.\"media_coverage\": [\"Global News\"",
        "import:fastapi.\"organization\": \"Mental Health Commission of Canada\"}\n            ]",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.ElectedMember",
        "import:fastapi.\"pagination\": {\n            \"page\": page"
      ]
    },
    "GET:/{user_id}": {
      "method": "GET",
      "path": "/{user_id}",
      "file": "services/api-gateway/app/api/v1/endpoints/users.py",
      "line": 75,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )\n    ]\n    \n    if is_active is not None:\n        mock_users = [u for u in mock_users if u.is_active == is_active]\n    \n    return UserListResponse(\n        users=mock_users",
        "import:fastapi.full_name=\"Jane Smith\"",
        "import:fastapi.full_name=\"John Doe\"",
        "import:fastapi.description=\"Filter by active status\")\n):\n    \"\"\"List users with pagination and filtering.\"\"\"\n    # Mock data for now\n    mock_users = [\n        UserResponse(\n            id=\"1\"",
        "import:fastapi.UserResponse(\n            id=\"2\"",
        "import:fastapi.size: int = Query(10",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.EmailStr\n\nclass UserResponse(BaseModel):\n    id: str\n    username: str\n    email: str\n    full_name: str\n    is_active: bool\n    created_at: str\n    updated_at: str\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str\n    password: str\n\nclass UserUpdate(BaseModel):\n    full_name: Optional[str] = None\n    email: Optional[EmailStr] = None\n    is_active: Optional[bool] = None\nclass UserListResponse(BaseModel):\n    users: List[UserResponse]\n    total: int\n    page: int\n    size: int\n\nrouter = APIRouter()\n\n@router.get(\"/\"",
        "import:fastapi.created_at=\"2024-01-01T00:00:00Z\"",
        "import:fastapi.Optional\nfrom pydantic import BaseModel",
        "import:fastapi.total=len(mock_users)",
        "import:fastapi.description=\"Page size\")",
        "import:fastapi.ge=1",
        "import:fastapi.username=\"jane_smith\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )",
        "import:fastapi.le=100",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.username=\"john_doe\"",
        "import:fastapi.email=\"jane@example.com\"",
        "import:fastapi.size=size\n    )",
        "import:fastapi.page=page",
        "import:fastapi.is_active=True",
        "function:list_users",
        "import:fastapi.email=\"john@example.com\"",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "PUT:/{user_id}": {
      "method": "PUT",
      "path": "/{user_id}",
      "file": "services/api-gateway/app/api/v1/endpoints/users.py",
      "line": 116,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )\n    ]\n    \n    if is_active is not None:\n        mock_users = [u for u in mock_users if u.is_active == is_active]\n    \n    return UserListResponse(\n        users=mock_users",
        "import:fastapi.full_name=\"Jane Smith\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )\n    elif user_id == \"2\":\n        return UserResponse(\n            id=\"2\"",
        "import:fastapi.full_name=\"John Doe\"",
        "import:fastapi.size=size\n    )\n\n@router.get(\"/{user_id}\"",
        "import:fastapi.description=\"Filter by active status\")\n):\n    \"\"\"List users with pagination and filtering.\"\"\"\n    # Mock data for now\n    mock_users = [\n        UserResponse(\n            id=\"1\"",
        "import:fastapi.UserResponse(\n            id=\"2\"",
        "import:fastapi.size: int = Query(10",
        "import:fastapi.email=user.email",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.EmailStr\n\nclass UserResponse(BaseModel):\n    id: str\n    username: str\n    email: str\n    full_name: str\n    is_active: bool\n    created_at: str\n    updated_at: str\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str\n    password: str\n\nclass UserUpdate(BaseModel):\n    full_name: Optional[str] = None\n    email: Optional[EmailStr] = None\n    is_active: Optional[bool] = None\nclass UserListResponse(BaseModel):\n    users: List[UserResponse]\n    total: int\n    page: int\n    size: int\n\nrouter = APIRouter()\n\n@router.get(\"/\"",
        "import:fastapi.created_at=\"2024-01-01T00:00:00Z\"",
        "import:fastapi.Optional\nfrom pydantic import BaseModel",
        "import:fastapi.detail=\"User not found\")\n\n@router.post(\"/\"",
        "import:fastapi.total=len(mock_users)",
        "import:fastapi.description=\"Page size\")",
        "function:create_user",
        "import:fastapi.ge=1",
        "import:fastapi.username=user.username",
        "import:fastapi.username=\"jane_smith\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n    )",
        "import:fastapi.le=100",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.username=\"john_doe\"",
        "import:fastapi.email=\"jane@example.com\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )\n    \n    raise HTTPException(status_code=404",
        "import:fastapi.page=page",
        "import:fastapi.response_model=UserResponse)\nasync def create_user(user: UserCreate):\n    \"\"\"Create a new user.\"\"\"\n    # Mock creation for now\n    return UserResponse(\n        id=\"3\"",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.is_active=True",
        "import:fastapi.email=\"john@example.com\"",
        "import:fastapi.response_model=UserResponse)\nasync def get_user(user_id: str):\n    \"\"\"Get a specific user by ID.\"\"\"\n    # Mock data for now\n    if user_id == \"1\":\n        return UserResponse(\n            id=\"1\"",
        "import:fastapi.APIRouter",
        "import:fastapi.HTTPException"
      ]
    },
    "DELETE:/{user_id}": {
      "method": "DELETE",
      "path": "/{user_id}",
      "file": "services/api-gateway/app/api/v1/endpoints/users.py",
      "line": 132,
      "dependencies": [
        "import:fastapi.response_model=UserListResponse)\nasync def list_users(\n    page: int = Query(1",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )\n    ]\n    \n    if is_active is not None:\n        mock_users = [u for u in mock_users if u.is_active == is_active]\n    \n    return UserListResponse(\n        users=mock_users",
        "function:update_user",
        "import:fastapi.full_name=\"Jane Smith\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )\n    elif user_id == \"2\":\n        return UserResponse(\n            id=\"2\"",
        "import:fastapi.full_name=\"John Doe\"",
        "import:fastapi.size=size\n    )\n\n@router.get(\"/{user_id}\"",
        "import:fastapi.description=\"Filter by active status\")\n):\n    \"\"\"List users with pagination and filtering.\"\"\"\n    # Mock data for now\n    mock_users = [\n        UserResponse(\n            id=\"1\"",
        "import:fastapi.UserResponse(\n            id=\"2\"",
        "import:fastapi.size: int = Query(10",
        "import:fastapi.email=user.email",
        "import:fastapi.is_active: Optional[bool] = Query(None",
        "import:fastapi.EmailStr\n\nclass UserResponse(BaseModel):\n    id: str\n    username: str\n    email: str\n    full_name: str\n    is_active: bool\n    created_at: str\n    updated_at: str\n\nclass UserCreate(BaseModel):\n    username: str\n    email: EmailStr\n    full_name: str\n    password: str\n\nclass UserUpdate(BaseModel):\n    full_name: Optional[str] = None\n    email: Optional[EmailStr] = None\n    is_active: Optional[bool] = None\nclass UserListResponse(BaseModel):\n    users: List[UserResponse]\n    total: int\n    page: int\n    size: int\n\nrouter = APIRouter()\n\n@router.get(\"/\"",
        "import:fastapi.created_at=\"2024-01-01T00:00:00Z\"",
        "import:fastapi.username=\"existing_user\"",
        "import:fastapi.Optional\nfrom pydantic import BaseModel",
        "import:fastapi.detail=\"User not found\")\n\n@router.post(\"/\"",
        "import:fastapi.total=len(mock_users)",
        "import:fastapi.description=\"Page size\")",
        "import:fastapi.ge=1",
        "import:fastapi.email=\"existing@example.com\"",
        "import:fastapi.username=user.username",
        "import:fastapi.username=\"jane_smith\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )",
        "import:fastapi.response_model=UserResponse)\nasync def update_user(user_id: str",
        "import:fastapi.le=100",
        "import:fastapi.Query\nfrom typing import List",
        "import:fastapi.username=\"john_doe\"",
        "import:fastapi.full_name=user_update.full_name or \"Existing User\"",
        "import:fastapi.email=\"jane@example.com\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n        )\n    \n    raise HTTPException(status_code=404",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n    )\n    \n    return existing_user",
        "import:fastapi.page=page",
        "import:fastapi.user_update: UserUpdate):\n    \"\"\"Update an existing user.\"\"\"\n    # Mock update for now\n    existing_user = UserResponse(\n        id=user_id",
        "import:fastapi.response_model=UserResponse)\nasync def create_user(user: UserCreate):\n    \"\"\"Create a new user.\"\"\"\n    # Mock creation for now\n    return UserResponse(\n        id=\"3\"",
        "import:fastapi.full_name=user.full_name",
        "import:fastapi.is_active=True",
        "import:fastapi.email=\"john@example.com\"",
        "import:fastapi.response_model=UserResponse)\nasync def get_user(user_id: str):\n    \"\"\"Get a specific user by ID.\"\"\"\n    # Mock data for now\n    if user_id == \"1\":\n        return UserResponse(\n            id=\"1\"",
        "import:fastapi.APIRouter",
        "import:fastapi.is_active=user_update.is_active if user_update.is_active is not None else True",
        "import:fastapi.HTTPException",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n    )\n\n@router.put(\"/{user_id}\""
      ]
    },
    "GET:/{entity_id}": {
      "method": "GET",
      "path": "/{entity_id}",
      "file": "services/api-gateway/app/api/v1/endpoints/entities.py",
      "line": 101,
      "dependencies": [
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.data={\"title\": \"C-123\"",
        "import:fastapi.created_at=entity.created_at.isoformat() if entity.created_at else None",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"List parliamentary entities with pagination and filtering.\"\"\"\n    try:\n        # Build query\n        query = db.query(ParliamentaryEntity)\n        \n        if type:\n            query = query.filter(ParliamentaryEntity.type == type)\n        \n        # Get total count\n        total = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * size\n        entities = query.offset(offset).limit(size).all()\n        \n        # Convert to response format\n        entity_responses = [\n            EntityResponse(\n                id=str(entity.id)",
        "import:fastapi.data=entity.data",
        "import:fastapi.size: int = Query(10",
        "import:fastapi.description=\"Filter by entity type\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.EntityResponse(\n                id=\"2\"",
        "import:fastapi.created_at=\"2024-01-01T00:00:00Z\"",
        "import:fastapi.type=\"mp\"",
        "import:fastapi.\"sponsor\": \"Jane Smith\"}",
        "import:fastapi.Depends\nfrom typing import List",
        "import:fastapi.type=entity.type",
        "import:fastapi.size=size\n        )\n        \n    except Exception as e:\n        # Fallback to mock data if database fails\n        mock_entities = [\n            EntityResponse(\n                id=\"1\"",
        "import:fastapi.response_model=EntityListResponse)\nasync def list_entities(\n    type: Optional[str] = Query(None",
        "import:fastapi.description=\"Page size\")",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\nfrom app.database import get_db\nfrom app.models.parliamentary_entities import ParliamentaryEntity\n\nclass EntityResponse(BaseModel):\n    id: str\n    type: str\n    data: dict\n    created_at: str\n    updated_at: str\n\nclass EntityCreate(BaseModel):\n    type: str\n    data: dict\n\nclass EntityListResponse(BaseModel):\n    entities: List[EntityResponse]\n    total: int\n    page: int\n    size: int\n\nrouter = APIRouter()\n\n@router.get(\"/\"",
        "import:fastapi.ge=1",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )",
        "import:fastapi.type=\"bill\"",
        "import:fastapi.\"status\": \"introduced\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )\n        ]\n        \n        if type:\n            mock_entities = [e for e in mock_entities if e.type == type]\n        \n        return EntityListResponse(\n            entities=mock_entities",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "function:list_entities",
        "import:fastapi.total=total",
        "import:fastapi.updated_at=entity.updated_at.isoformat() if entity.updated_at else None\n            )\n            for entity in entities\n        ]\n        \n        return EntityListResponse(\n            entities=entity_responses",
        "import:fastapi.page=page",
        "import:fastapi.\"party\": \"Liberal\"",
        "import:fastapi.total=len(mock_entities)",
        "import:fastapi.\"riding\": \"Toronto Centre\"}",
        "import:fastapi.APIRouter",
        "import:fastapi.data={\"name\": \"John Doe\"",
        "import:fastapi.HTTPException",
        "import:fastapi.size=size\n        )"
      ]
    },
    "GET:/types/list": {
      "method": "GET",
      "path": "/types/list",
      "file": "services/api-gateway/app/api/v1/endpoints/entities.py",
      "line": 155,
      "dependencies": [
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.response_model=EntityResponse)\nasync def create_entity(entity: EntityCreate):\n    \"\"\"Create a new parliamentary entity.\"\"\"\n    # Mock creation for now\n    return EntityResponse(\n        id=\"3\"",
        "import:fastapi.data={\"title\": \"C-123\"",
        "import:fastapi.created_at=entity.created_at.isoformat() if entity.created_at else None",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"List parliamentary entities with pagination and filtering.\"\"\"\n    try:\n        # Build query\n        query = db.query(ParliamentaryEntity)\n        \n        if type:\n            query = query.filter(ParliamentaryEntity.type == type)\n        \n        # Get total count\n        total = query.count()\n        \n        # Apply pagination\n        offset = (page - 1) * size\n        entities = query.offset(offset).limit(size).all()\n        \n        # Convert to response format\n        entity_responses = [\n            EntityResponse(\n                id=str(entity.id)",
        "import:fastapi.updated_at=entity.updated_at.isoformat() if entity.updated_at else None\n            )\n        else:\n            raise HTTPException(status_code=404",
        "import:fastapi.data=entity.data",
        "import:fastapi.size: int = Query(10",
        "import:fastapi.description=\"Filter by entity type\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.db: Session = Depends(get_db)):\n    \"\"\"Get a specific parliamentary entity by ID.\"\"\"\n    try:\n        import uuid\n        entity_uuid = uuid.UUID(entity_id)\n        entity = db.query(ParliamentaryEntity).filter(ParliamentaryEntity.id == entity_uuid).first()\n        \n        if entity:\n            return EntityResponse(\n                id=str(entity.id)",
        "import:fastapi.EntityResponse(\n                id=\"2\"",
        "import:fastapi.created_at=\"2024-01-01T00:00:00Z\"",
        "import:fastapi.type=\"mp\"",
        "import:fastapi.detail=\"Entity not found\")\n            \n    except ValueError:\n        raise HTTPException(status_code=400",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )\n        \n        raise HTTPException(status_code=404",
        "import:fastapi.\"sponsor\": \"Jane Smith\"}",
        "import:fastapi.Depends\nfrom typing import List",
        "import:fastapi.type=entity.type",
        "import:fastapi.size=size\n        )\n        \n    except Exception as e:\n        # Fallback to mock data if database fails\n        mock_entities = [\n            EntityResponse(\n                id=\"1\"",
        "import:fastapi.response_model=EntityListResponse)\nasync def list_entities(\n    type: Optional[str] = Query(None",
        "import:fastapi.description=\"Page size\")",
        "import:fastapi.Optional\nfrom pydantic import BaseModel\nfrom sqlalchemy.orm import Session\nfrom app.database import get_db\nfrom app.models.parliamentary_entities import ParliamentaryEntity\n\nclass EntityResponse(BaseModel):\n    id: str\n    type: str\n    data: dict\n    created_at: str\n    updated_at: str\n\nclass EntityCreate(BaseModel):\n    type: str\n    data: dict\n\nclass EntityListResponse(BaseModel):\n    entities: List[EntityResponse]\n    total: int\n    page: int\n    size: int\n\nrouter = APIRouter()\n\n@router.get(\"/\"",
        "import:fastapi.ge=1",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )",
        "import:fastapi.response_model=EntityResponse)\nasync def get_entity(entity_id: str",
        "import:fastapi.type=\"bill\"",
        "import:fastapi.\"status\": \"introduced\"",
        "import:fastapi.detail=\"Entity not found\")\n\n@router.post(\"/\"",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )\n        ]\n        \n        if type:\n            mock_entities = [e for e in mock_entities if e.type == type]\n        \n        return EntityListResponse(\n            entities=mock_entities",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n            )\n        elif entity_id == \"2\":\n            return EntityResponse(\n                id=\"2\"",
        "function:create_entity",
        "import:fastapi.updated_at=\"2024-01-01T00:00:00Z\"\n    )",
        "import:fastapi.Query",
        "import:fastapi.le=100",
        "import:fastapi.total=total",
        "import:fastapi.detail=\"Invalid entity ID format\")\n    except Exception as e:\n        # Fallback to mock data if database fails\n        if entity_id == \"1\":\n            return EntityResponse(\n                id=\"1\"",
        "import:fastapi.size=size\n        )\n\n@router.get(\"/{entity_id}\"",
        "import:fastapi.updated_at=entity.updated_at.isoformat() if entity.updated_at else None\n            )\n            for entity in entities\n        ]\n        \n        return EntityListResponse(\n            entities=entity_responses",
        "import:fastapi.page=page",
        "import:fastapi.\"party\": \"Liberal\"",
        "import:fastapi.total=len(mock_entities)",
        "import:fastapi.\"riding\": \"Toronto Centre\"}",
        "import:fastapi.APIRouter",
        "import:fastapi.data={\"name\": \"John Doe\"",
        "import:fastapi.HTTPException"
      ]
    },
    "GET:/detailed": {
      "method": "GET",
      "path": "/detailed",
      "file": "services/api-gateway/app/api/v1/endpoints/health.py",
      "line": 20,
      "dependencies": [
        "import:fastapi.\"timestamp\": time.time()",
        "import:fastapi.APIRouter\nimport time\nfrom app.database import check_db_connection\n\nrouter = APIRouter()\n\n@router.get(\"/\")\nasync def health_check():\n    \"\"\"Basic health check\"\"\"\n    return {\n        \"status\": \"healthy\"",
        "import:fastapi.\"service\": \"api-gateway\"\n    }",
        "function:health_check"
      ]
    },
    "GET:/api/versions": {
      "method": "GET",
      "path": "/api/versions",
      "file": "services/api-gateway/src/core/versioning.py",
      "line": 162,
      "dependencies": [
        "import:fastapi.version: str",
        "import:fastapi.self.latest_version) > 0:\n            self.latest_version = version\n        \n        return api_version\n    \n    def _compare_versions(self",
        "import:fastapi.str]:\n        \"\"\"Get deprecation headers for a version\"\"\"\n        headers = {}\n        \n        if version in self.versions and self.versions[version].deprecated:\n            api_version = self.versions[version]\n            headers['Deprecation'] = 'true'\n            headers['Link'] = f'</api/{self.latest_version}>",
        "import:fastapi.APIVersion] = {}\n        self.default_version = None\n        self.latest_version = None\n    \n    def register_version(self",
        "import:..api.prefix=f\"/api/{version}\"",
        "import:fastapi.version: str) -> Dict[str",
        "import:fastapi.Request",
        "import:..api.tags=[f\"API {version}\"]\n        )\n    \n    # Add version discovery endpoint",
        "import:fastapi.sunset_date: str):\n        \"\"\"Mark version as deprecated with dates\"\"\"\n        self.deprecated = True\n        self.deprecation_date = deprecation_date\n        self.sunset_date = sunset_date\n\nclass APIVersionManager:\n    \"\"\"\n    Manages multiple API versions\n    Based on legacy URL versioning patterns\n    \"\"\"\n    def __init__(self):\n        self.versions: Dict[str",
        "import:..api.v1_router",
        "import:fastapi.router",
        "import:..api.api_version in version_manager.versions.items():\n        app.include_router(\n            api_version.router",
        "import:fastapi.router: APIRouter",
        "import:fastapi.version: str) -> Optional[APIRouter]:\n        \"\"\"Get router for a specific version\"\"\"\n        if version in self.versions:\n            return self.versions[version].router\n        return None\n    \n    def get_deprecation_headers(self",
        "import:fastapi.len(v2_parts))):\n            v1_part = v1_parts[i] if i < len(v1_parts) else 0\n            v2_part = v2_parts[i] if i < len(v2_parts) else 0\n            \n            if v1_part > v2_part:\n                return 1\n            elif v1_part < v2_part:\n                return -1\n        \n        return 0\n    \n    def get_version_router(self",
        "import:..api.v1\n    \n    # Register v1\n    v1_router = APIRouter()\n    v1_router.include_router(v1.bills.router)\n    v1_router.include_router(v1.members.router)\n    v1_router.include_router(v1.debates.router)\n    v1_router.include_router(v1.committees.router)\n    v1_router.include_router(v1.votes.router)\n    v1_router.include_router(v1.export.router)\n    v1_router.include_router(v1.feeds.router)\n    \n    version_manager.register_version('v1'",
        "import:fastapi.deprecated)\n        self.versions[version] = api_version\n        \n        if is_default:\n            self.default_version = version\n        \n        # Update latest version (assuming semantic versioning)\n        if not self.latest_version or self._compare_versions(version",
        "import:fastapi.v2: str) -> int:\n        \"\"\"Compare semantic versions\"\"\"\n        v1_parts = [int(x) for x in v1.lstrip('v').split('.')]\n        v2_parts = [int(x) for x in v2.lstrip('v').split('.')]\n        \n        for i in range(max(len(v1_parts)",
        "import:fastapi.is_default: bool = False",
        "import:fastapi.deprecated: bool = False) -> APIVersion:\n        \"\"\"Register a new API version\"\"\"\n        api_version = APIVersion(version",
        "import:..api.is_default=True)\n    \n    # Mount versioned routes\n    for version",
        "function:create_versioned_app",
        "import:fastapi.List",
        "import:fastapi.Optional\nimport re\n\nclass APIVersion:\n    \"\"\"Represents an API version with its routes\"\"\"\n    def __init__(self",
        "import:fastapi.HTTPException\nfrom fastapi.responses import JSONResponse\nfrom typing import Dict",
        "import:fastapi.deprecation_date: str",
        "import:fastapi.v1: str",
        "import:fastapi.deprecated: bool = False):\n        self.version = version\n        self.router = router\n        self.deprecated = deprecated\n        self.deprecation_date = None\n        self.sunset_date = None\n    \n    def set_deprecation(self",
        "import:fastapi.APIRouter"
      ]
    },
    "GET:/recent-bills": {
      "method": "GET",
      "path": "/recent-bills",
      "file": "services/api-gateway/src/api/v1/feeds.py",
      "line": 66,
      "dependencies": [
        "import:fastapi.'title').text = self.title\n        ET.SubElement(channel",
        "import:fastapi.Statement\n\nrouter = APIRouter(prefix=\"/feeds\"",
        "import:fastapi.guid: Optional[str] = None):\n        \"\"\"Add an item to the feed\"\"\"\n        self.items.append({\n            'title': title",
        "import:fastapi.Member",
        "import:fastapi.'description').text = item['description']\n            ET.SubElement(item_elem",
        "import:fastapi.Debate",
        "import:fastapi.'pubdate': pubdate",
        "import:fastapi.'language').text = 'en-ca'\n        ET.SubElement(channel",
        "import:fastapi.'guid': guid or link\n        })\n    \n    def generate_rss(self) -> str:\n        \"\"\"Generate RSS 2.0 feed\"\"\"\n        rss = ET.Element('rss'",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n        \n        # Add items\n        for item in self.items:\n            item_elem = ET.SubElement(channel",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n            ET.SubElement(item_elem",
        "import:fastapi.tags=[\"feeds\"])\n\nclass FeedGenerator:\n    \"\"\"\n    RSS feed generator based on legacy feed_wrapper pattern\n    \"\"\"\n    def __init__(self",
        "import:fastapi.encoding='str')\n        reparsed = minidom.parseString(rough_string)\n        return reparsed.toprettyxml(indent=\"  \")",
        "import:fastapi.title: str",
        "import:fastapi.Request",
        "import:fastapi.link: str",
        "import:fastapi.'channel')\n        \n        # Channel metadata\n        ET.SubElement(channel",
        "import:fastapi.description: str):\n        self.title = title\n        self.link = link\n        self.description = description\n        self.items = []\n    \n    def add_item(self",
        "import:fastapi.'link': link",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.'description': description",
        "import:fastapi.Vote",
        "import:fastapi.description: str",
        "import:fastapi.'link').text = self.link\n        ET.SubElement(channel",
        "import:fastapi.Query",
        "import:fastapi.'description').text = self.description\n        ET.SubElement(channel",
        "import:fastapi.Committee",
        "import:fastapi.'title').text = item['title']\n            ET.SubElement(item_elem",
        "import:fastapi.'lastBuildDate').text = datetime.utcnow().strftime('%a",
        "import:fastapi.version='2.0')\n        channel = ET.SubElement(rss",
        "import:fastapi.List\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\nfrom sqlalchemy import desc\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.'pubDate').text = item['pubdate'].strftime('%a",
        "function:generate_rss",
        "import:fastapi.'item')\n            ET.SubElement(item_elem",
        "import:fastapi.'link').text = item['link']\n            ET.SubElement(item_elem",
        "import:fastapi.pubdate: datetime",
        "import:fastapi.APIRouter",
        "import:fastapi.'guid').text = item['guid']\n        \n        # Pretty print\n        rough_string = ET.tostring(rss"
      ]
    },
    "GET:/recent-debates": {
      "method": "GET",
      "path": "/recent-debates",
      "file": "services/api-gateway/src/api/v1/feeds.py",
      "line": 97,
      "dependencies": [
        "import:fastapi.'title').text = self.title\n        ET.SubElement(channel",
        "import:fastapi.Statement\n\nrouter = APIRouter(prefix=\"/feeds\"",
        "import:fastapi.guid: Optional[str] = None):\n        \"\"\"Add an item to the feed\"\"\"\n        self.items.append({\n            'title': title",
        "import:fastapi.Member",
        "import:fastapi.'description').text = item['description']\n            ET.SubElement(item_elem",
        "import:fastapi.Debate",
        "import:fastapi.'pubdate': pubdate",
        "function:recent_bills_feed",
        "import:fastapi.'language').text = 'en-ca'\n        ET.SubElement(channel",
        "import:fastapi.'guid': guid or link\n        })\n    \n    def generate_rss(self) -> str:\n        \"\"\"Generate RSS 2.0 feed\"\"\"\n        rss = ET.Element('rss'",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n        \n        # Add items\n        for item in self.items:\n            item_elem = ET.SubElement(channel",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n            ET.SubElement(item_elem",
        "import:fastapi.tags=[\"feeds\"])\n\nclass FeedGenerator:\n    \"\"\"\n    RSS feed generator based on legacy feed_wrapper pattern\n    \"\"\"\n    def __init__(self",
        "import:fastapi.link=f\"https://openparliament.ca/bills/{bill.session}/{bill.number}/\"",
        "import:fastapi.media_type=\"application/rss+xml\")",
        "import:fastapi.title: str",
        "import:fastapi.Request",
        "import:fastapi.le=100)",
        "import:fastapi.link: str",
        "import:fastapi.description=f\"Introduced on {bill.introduced.strftime('%B %d",
        "import:fastapi.limit: int = Query(20",
        "import:fastapi.encoding='str')\n        reparsed = minidom.parseString(rough_string)\n        return reparsed.toprettyxml(indent=\"  \")\n\n@router.get(\"/recent-bills\")\nasync def recent_bills_feed(\n    request: Request",
        "import:fastapi.'channel')\n        \n        # Channel metadata\n        ET.SubElement(channel",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    RSS feed for recent bills\n    Based on legacy RSS patterns\n    \"\"\"\n    # Get recent bills\n    bills = db.query(Bill).order_by(desc(Bill.introduced)).limit(limit).all()\n    \n    # Create feed\n    feed = FeedGenerator(\n        title=\"Recent Bills - OpenParliament.ca\"",
        "import:fastapi.description: str):\n        self.title = title\n        self.link = link\n        self.description = description\n        self.items = []\n    \n    def add_item(self",
        "import:fastapi.link=str(request.url_for('recent_bills_feed'))",
        "import:fastapi.'link': link",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.'description': description",
        "import:fastapi.Vote",
        "import:fastapi.description: str",
        "import:fastapi.'link').text = self.link\n        ET.SubElement(channel",
        "import:fastapi.description=\"Recently introduced bills in the Canadian Parliament\"\n    )\n    \n    for bill in bills:\n        feed.add_item(\n            title=f\"Bill {bill.number}: {bill.name}\"",
        "import:fastapi.Query",
        "import:fastapi.'description').text = self.description\n        ET.SubElement(channel",
        "import:fastapi.Committee",
        "import:fastapi.'title').text = item['title']\n            ET.SubElement(item_elem",
        "import:fastapi.'lastBuildDate').text = datetime.utcnow().strftime('%a",
        "import:fastapi.version='2.0')\n        channel = ET.SubElement(rss",
        "import:fastapi.List\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\nfrom sqlalchemy import desc\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.'pubDate').text = item['pubdate'].strftime('%a",
        "import:fastapi.pubdate=bill.introduced or datetime.utcnow()\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.'item')\n            ET.SubElement(item_elem",
        "import:fastapi.%Y') if bill.introduced else 'Unknown'}. \"\n                       f\"Sponsor: {bill.sponsor.name if bill.sponsor else 'Unknown'}\"",
        "import:fastapi.'link').text = item['link']\n            ET.SubElement(item_elem",
        "import:fastapi.pubdate: datetime",
        "import:fastapi.APIRouter",
        "import:fastapi.'guid').text = item['guid']\n        \n        # Pretty print\n        rough_string = ET.tostring(rss"
      ]
    },
    "GET:/mp/{mp_slug}/statements": {
      "method": "GET",
      "path": "/mp/{mp_slug}/statements",
      "file": "services/api-gateway/src/api/v1/feeds.py",
      "line": 123,
      "dependencies": [
        "import:fastapi.%Y')}\"",
        "import:fastapi.'title').text = self.title\n        ET.SubElement(channel",
        "import:fastapi.Statement\n\nrouter = APIRouter(prefix=\"/feeds\"",
        "import:fastapi.link=str(request.url_for('recent_debates_feed'))",
        "import:fastapi.guid: Optional[str] = None):\n        \"\"\"Add an item to the feed\"\"\"\n        self.items.append({\n            'title': title",
        "import:fastapi.Member",
        "import:fastapi.'description').text = item['description']\n            ET.SubElement(item_elem",
        "import:fastapi.Debate",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"RSS feed for recent debates\"\"\"\n    debates = db.query(Debate).order_by(desc(Debate.date)).limit(limit).all()\n    \n    feed = FeedGenerator(\n        title=\"Recent Debates - OpenParliament.ca\"",
        "import:fastapi.'pubdate': pubdate",
        "import:fastapi.description=\"Recent debates from the House of Commons\"\n    )\n    \n    for debate in debates:\n        feed.add_item(\n            title=debate.h1_en or f\"Debate on {debate.date.strftime('%B %d",
        "import:fastapi.'language').text = 'en-ca'\n        ET.SubElement(channel",
        "import:fastapi.'guid': guid or link\n        })\n    \n    def generate_rss(self) -> str:\n        \"\"\"Generate RSS 2.0 feed\"\"\"\n        rss = ET.Element('rss'",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n        \n        # Add items\n        for item in self.items:\n            item_elem = ET.SubElement(channel",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n            ET.SubElement(item_elem",
        "import:fastapi.tags=[\"feeds\"])\n\nclass FeedGenerator:\n    \"\"\"\n    RSS feed generator based on legacy feed_wrapper pattern\n    \"\"\"\n    def __init__(self",
        "import:fastapi.link=f\"https://openparliament.ca/bills/{bill.session}/{bill.number}/\"",
        "import:fastapi.media_type=\"application/rss+xml\")",
        "import:fastapi.title: str",
        "import:fastapi.pubdate=datetime.combine(debate.date",
        "import:fastapi.Request",
        "import:fastapi.le=100)",
        "import:fastapi.link: str",
        "import:fastapi.description=f\"Introduced on {bill.introduced.strftime('%B %d",
        "import:fastapi.datetime.min.time())\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.limit: int = Query(20",
        "import:fastapi.link=f\"https://openparliament.ca/debates/{debate.date}/{debate.number}/\"",
        "import:fastapi.encoding='str')\n        reparsed = minidom.parseString(rough_string)\n        return reparsed.toprettyxml(indent=\"  \")\n\n@router.get(\"/recent-bills\")\nasync def recent_bills_feed(\n    request: Request",
        "import:fastapi.'channel')\n        \n        # Channel metadata\n        ET.SubElement(channel",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    RSS feed for recent bills\n    Based on legacy RSS patterns\n    \"\"\"\n    # Get recent bills\n    bills = db.query(Bill).order_by(desc(Bill.introduced)).limit(limit).all()\n    \n    # Create feed\n    feed = FeedGenerator(\n        title=\"Recent Bills - OpenParliament.ca\"",
        "import:fastapi.description: str):\n        self.title = title\n        self.link = link\n        self.description = description\n        self.items = []\n    \n    def add_item(self",
        "import:fastapi.link=str(request.url_for('recent_bills_feed'))",
        "import:fastapi.'link': link",
        "import:fastapi.Session {debate.session}. \"\n                       f\"{debate.statement_count} statements.\"",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.'description': description",
        "import:fastapi.Vote",
        "import:fastapi.description: str",
        "import:fastapi.'link').text = self.link\n        ET.SubElement(channel",
        "import:fastapi.description=\"Recently introduced bills in the Canadian Parliament\"\n    )\n    \n    for bill in bills:\n        feed.add_item(\n            title=f\"Bill {bill.number}: {bill.name}\"",
        "import:fastapi.Query",
        "import:fastapi.'description').text = self.description\n        ET.SubElement(channel",
        "import:fastapi.Committee",
        "import:fastapi.description=f\"Parliament {debate.parliament}",
        "import:fastapi.'title').text = item['title']\n            ET.SubElement(item_elem",
        "import:fastapi.media_type=\"application/rss+xml\")\n\n@router.get(\"/recent-debates\")\nasync def recent_debates_feed(\n    request: Request",
        "import:fastapi.'lastBuildDate').text = datetime.utcnow().strftime('%a",
        "import:fastapi.version='2.0')\n        channel = ET.SubElement(rss",
        "import:fastapi.List\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\nfrom sqlalchemy import desc\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.'pubDate').text = item['pubdate'].strftime('%a",
        "import:fastapi.pubdate=bill.introduced or datetime.utcnow()\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.'item')\n            ET.SubElement(item_elem",
        "function:recent_debates_feed",
        "import:fastapi.'link').text = item['link']\n            ET.SubElement(item_elem",
        "import:fastapi.%Y') if bill.introduced else 'Unknown'}. \"\n                       f\"Sponsor: {bill.sponsor.name if bill.sponsor else 'Unknown'}\"",
        "import:fastapi.pubdate: datetime",
        "import:fastapi.APIRouter",
        "import:fastapi.'guid').text = item['guid']\n        \n        # Pretty print\n        rough_string = ET.tostring(rss"
      ]
    },
    "GET:/mp/{mp_slug}/activity": {
      "method": "GET",
      "path": "/mp/{mp_slug}/activity",
      "file": "services/api-gateway/src/api/v1/feeds.py",
      "line": 160,
      "dependencies": [
        "import:fastapi.link=statement.get_absolute_url()",
        "import:fastapi.pubdate=statement.time\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.%Y')}\"",
        "import:fastapi.'title').text = self.title\n        ET.SubElement(channel",
        "import:fastapi.Statement\n\nrouter = APIRouter(prefix=\"/feeds\"",
        "import:fastapi.link=str(request.url_for('recent_debates_feed'))",
        "import:fastapi.guid: Optional[str] = None):\n        \"\"\"Add an item to the feed\"\"\"\n        self.items.append({\n            'title': title",
        "import:fastapi.Member",
        "import:fastapi.'description').text = item['description']\n            ET.SubElement(item_elem",
        "import:fastapi.Debate",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"RSS feed for recent debates\"\"\"\n    debates = db.query(Debate).order_by(desc(Debate.date)).limit(limit).all()\n    \n    feed = FeedGenerator(\n        title=\"Recent Debates - OpenParliament.ca\"",
        "import:fastapi.'pubdate': pubdate",
        "import:fastapi.description=\"Recent debates from the House of Commons\"\n    )\n    \n    for debate in debates:\n        feed.add_item(\n            title=debate.h1_en or f\"Debate on {debate.date.strftime('%B %d",
        "import:fastapi.'language').text = 'en-ca'\n        ET.SubElement(channel",
        "import:fastapi.'guid': guid or link\n        })\n    \n    def generate_rss(self) -> str:\n        \"\"\"Generate RSS 2.0 feed\"\"\"\n        rss = ET.Element('rss'",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n        \n        # Add items\n        for item in self.items:\n            item_elem = ET.SubElement(channel",
        "import:fastapi.%d %b %Y %H:%M:%S GMT')\n            ET.SubElement(item_elem",
        "import:fastapi.tags=[\"feeds\"])\n\nclass FeedGenerator:\n    \"\"\"\n    RSS feed generator based on legacy feed_wrapper pattern\n    \"\"\"\n    def __init__(self",
        "import:fastapi.link=f\"https://openparliament.ca/bills/{bill.session}/{bill.number}/\"",
        "import:fastapi.media_type=\"application/rss+xml\")",
        "import:fastapi.description=f\"Recent statements in Parliament by {mp.name}\"\n    )\n    \n    for statement in statements:\n        feed.add_item(\n            title=statement.topic or \"House statement\"",
        "import:fastapi.title: str",
        "import:fastapi.pubdate=datetime.combine(debate.date",
        "import:fastapi.description=statement.text_html()",
        "import:fastapi.Request",
        "import:fastapi.le=100)",
        "import:fastapi.link: str",
        "import:fastapi.description=f\"Introduced on {bill.introduced.strftime('%B %d",
        "import:fastapi.datetime.min.time())\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.limit: int = Query(20",
        "import:fastapi.link=f\"https://openparliament.ca/debates/{debate.date}/{debate.number}/\"",
        "import:fastapi.media_type=\"application/rss+xml\")\n\n@router.get(\"/mp/{mp_slug}/statements\")\nasync def mp_statements_feed(\n    request: Request",
        "import:fastapi.encoding='str')\n        reparsed = minidom.parseString(rough_string)\n        return reparsed.toprettyxml(indent=\"  \")\n\n@router.get(\"/recent-bills\")\nasync def recent_bills_feed(\n    request: Request",
        "import:fastapi.'channel')\n        \n        # Channel metadata\n        ET.SubElement(channel",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    RSS feed for recent bills\n    Based on legacy RSS patterns\n    \"\"\"\n    # Get recent bills\n    bills = db.query(Bill).order_by(desc(Bill.introduced)).limit(limit).all()\n    \n    # Create feed\n    feed = FeedGenerator(\n        title=\"Recent Bills - OpenParliament.ca\"",
        "import:fastapi.description: str):\n        self.title = title\n        self.link = link\n        self.description = description\n        self.items = []\n    \n    def add_item(self",
        "import:fastapi.link=str(request.url_for('recent_bills_feed'))",
        "import:fastapi.'link': link",
        "import:fastapi.Session {debate.session}. \"\n                       f\"{debate.statement_count} statements.\"",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.'description': description",
        "import:fastapi.Vote",
        "import:fastapi.description: str",
        "import:fastapi.'link').text = self.link\n        ET.SubElement(channel",
        "import:fastapi.description=\"Recently introduced bills in the Canadian Parliament\"\n    )\n    \n    for bill in bills:\n        feed.add_item(\n            title=f\"Bill {bill.number}: {bill.name}\"",
        "import:fastapi.Query",
        "import:fastapi.'description').text = self.description\n        ET.SubElement(channel",
        "import:fastapi.Committee",
        "import:fastapi.description=f\"Parliament {debate.parliament}",
        "import:fastapi.'title').text = item['title']\n            ET.SubElement(item_elem",
        "import:fastapi.media_type=\"application/rss+xml\")\n\n@router.get(\"/recent-debates\")\nasync def recent_debates_feed(\n    request: Request",
        "import:fastapi.'lastBuildDate').text = datetime.utcnow().strftime('%a",
        "function:mp_statements_feed",
        "import:fastapi.version='2.0')\n        channel = ET.SubElement(rss",
        "import:fastapi.List\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\nfrom sqlalchemy import desc\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.'pubDate').text = item['pubdate'].strftime('%a",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    RSS feed for MP statements\n    Direct adaptation of legacy PoliticianStatementFeed\n    \"\"\"\n    # Get MP\n    mp = db.query(Member).filter(Member.slug == mp_slug).first()\n    if not mp:\n        return Response(status_code=404)\n    \n    # Get recent statements\n    statements = db.query(Statement).filter(\n        Statement.member_id == mp.id\n    ).order_by(desc(Statement.time)).limit(limit).all()\n    \n    feed = FeedGenerator(\n        title=f\"Statements by {mp.name} - OpenParliament.ca\"",
        "import:fastapi.pubdate=bill.introduced or datetime.utcnow()\n        )\n    \n    return Response(content=feed.generate_rss()",
        "import:fastapi.mp_slug: str",
        "import:fastapi.'item')\n            ET.SubElement(item_elem",
        "import:fastapi.%Y') if bill.introduced else 'Unknown'}. \"\n                       f\"Sponsor: {bill.sponsor.name if bill.sponsor else 'Unknown'}\"",
        "import:fastapi.'link').text = item['link']\n            ET.SubElement(item_elem",
        "import:fastapi.link=f\"https://openparliament.ca/politicians/{mp.slug}/\"",
        "import:fastapi.pubdate: datetime",
        "import:fastapi.APIRouter",
        "import:fastapi.'guid').text = item['guid']\n        \n        # Pretty print\n        rough_string = ET.tostring(rss"
      ]
    },
    "ROUTER:/feeds": {
      "method": "ROUTER",
      "path": "/feeds",
      "file": "services/api-gateway/src/api/v1/feeds.py",
      "line": 17,
      "dependencies": [
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.List\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\nfrom sqlalchemy import desc\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.Vote",
        "import:fastapi.Request",
        "import:fastapi.Member",
        "import:fastapi.Query",
        "import:fastapi.Debate",
        "import:fastapi.APIRouter",
        "import:fastapi.Committee",
        "import:fastapi.Statement\n\nrouter ="
      ]
    },
    "GET:/members": {
      "method": "GET",
      "path": "/members",
      "file": "services/api-gateway/src/api/v1/export.py",
      "line": 135,
      "dependencies": [
        "import:fastapi.status: Optional[str] = None",
        "import:fastapi.privatemember=None",
        "import:fastapi.indent=2)",
        "import:fastapi.Any]]",
        "import:fastapi.headers={\"Content-Disposition\": f\"attachment",
        "import:fastapi.\"introduced\": bill.introduced.isoformat() if bill.introduced else None",
        "import:fastapi.Member",
        "import:fastapi.dict) else ''\n                flat_item[field] = value\n            else:\n                flat_item[field] = item.get(field",
        "import:fastapi.session: Optional[str] = None",
        "import:fastapi.'') if isinstance(value",
        "import:fastapi.Debate",
        "import:fastapi.\"csv\"",
        "import:fastapi.limit: int = Query(100",
        "import:fastapi.root_name: str",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    Export bills data in multiple formats\n    Based on legacy JSON export patterns\n    \"\"\"\n    # Get bills data\n    bills_response = await get_bills_list(\n        page=1",
        "import:fastapi.key)\n                for nested_key",
        "import:fastapi.session=session",
        "import:fastapi.tags=[\"export\"])\n\ndef serialize_to_csv(data: List[Dict[str",
        "import:fastapi.key)\n                elem.text = str(value) if value is not None else ''\n    \n    # Pretty print(X)ML\n    rough_string = ET.tostring(root",
        "import:fastapi.search=None",
        "import:fastapi.\"session\": bill.session",
        "import:fastapi.\"privatemember\": bill.privatemember\n        }\n        for bill in bills_response[\"results\"][:limit]\n    ]\n    \n    if format == \"json\":\n        return Response(\n            content=json.dumps(bills_data",
        "import:fastapi.fields: List[str]) -> str:\n    \"\"\"Convert data to CSV format\"\"\"\n    output = io.StringIO()\n    writer = csv.DictWriter(output",
        "import:fastapi.nested_key)\n                    child_elem.text = str(nested_value) if nested_value is not None else ''\n            else:\n                elem = ET.SubElement(item_elem",
        "import:fastapi.le=1000)",
        "import:fastapi.\"law\": bill.law",
        "import:fastapi.item_name)\n        for key",
        "import:fastapi.'')\n        writer.writerow(flat_item)\n    \n    return output.getvalue()\n\ndef serialize_to_xml(data: List[Dict[str",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.Any\nimport csv\nimport json\nimport io\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.Vote\nfrom .bills import get_bills_list\nfrom .members import get_members_list\nfrom .debates import get_debates_list\nfrom .committees import get_committees_list\n\nrouter = APIRouter(prefix=\"/export\"",
        "import:fastapi.sponsor: Optional[str] = None",
        "import:fastapi.\"sponsor\": {\n                \"id\": bill.sponsor_politician_id",
        "import:fastapi.Query",
        "import:fastapi.Committee",
        "import:fastapi.\"name\": bill.name",
        "import:fastapi.item_name: str) -> str:\n    \"\"\"\n    Convert data to XML format\n    Based on legacy XML export patterns\n    \"\"\"\n    root = ET.Element(root_name)\n    \n    for item in data:\n        item_elem = ET.SubElement(root",
        "import:fastapi.nested_value in value.items():\n                    child_elem = ET.SubElement(nested_elem",
        "import:fastapi.\"name\": bill.sponsor.name if bill.sponsor else None\n            } if bill.sponsor_politician_id else None",
        "function:export_bills",
        "import:fastapi.List",
        "import:fastapi.\"xml\"])",
        "import:fastapi.media_type=\"application/json\"",
        "import:fastapi.dict):\n                # Handle nested objects\n                nested_elem = ET.SubElement(item_elem",
        "import:fastapi.enum=[\"json\"",
        "import:fastapi.Dict",
        "import:fastapi.value in item.items():\n            if isinstance(value",
        "import:fastapi.APIRouter",
        "import:fastapi.encoding='str')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent=\"  \")\n\n@router.get(\"/bills\")\nasync def export_bills(\n    format: str = Query(\"json\"",
        "import:fastapi.db=db\n    )\n    \n    bills_data = [\n        {\n            \"id\": bill.id",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.HTTPException",
        "import:fastapi.\"number\": bill.number",
        "import:fastapi.fieldnames=fields)\n    writer.writeheader()\n    \n    for item in data:\n        # Flatten nested objects\n        flat_item = {}\n        for field in fields:\n            if '.' in field:\n                # Handle nested fields like \"party.name\"\n                parts = field.split('.')\n                value = item\n                for part in parts:\n                    value = value.get(part"
      ]
    },
    "GET:/debates": {
      "method": "GET",
      "path": "/debates",
      "file": "services/api-gateway/src/api/v1/export.py",
      "line": 194,
      "dependencies": [
        "import:fastapi.status: Optional[str] = None",
        "import:fastapi.privatemember=None",
        "import:fastapi.indent=2)",
        "import:fastapi.Any]]",
        "import:fastapi.headers={\"Content-Disposition\": f\"attachment",
        "import:fastapi.\"introduced\": bill.introduced.isoformat() if bill.introduced else None",
        "import:fastapi.Member",
        "import:fastapi.dict) else ''\n                flat_item[field] = value\n            else:\n                flat_item[field] = item.get(field",
        "import:fastapi.session: Optional[str] = None",
        "import:fastapi.'') if isinstance(value",
        "import:fastapi.Debate",
        "import:fastapi.\"csv\"",
        "import:fastapi.limit: int = Query(100",
        "import:fastapi.root_name: str",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    Export bills data in multiple formats\n    Based on legacy JSON export patterns\n    \"\"\"\n    # Get bills data\n    bills_response = await get_bills_list(\n        page=1",
        "import:fastapi.key)\n                for nested_key",
        "import:fastapi.session=session",
        "import:fastapi.tags=[\"export\"])\n\ndef serialize_to_csv(data: List[Dict[str",
        "import:fastapi.key)\n                elem.text = str(value) if value is not None else ''\n    \n    # Pretty print(X)ML\n    rough_string = ET.tostring(root",
        "import:fastapi.search=None",
        "import:fastapi.\"session\": bill.session",
        "import:fastapi.\"privatemember\": bill.privatemember\n        }\n        for bill in bills_response[\"results\"][:limit]\n    ]\n    \n    if format == \"json\":\n        return Response(\n            content=json.dumps(bills_data",
        "import:fastapi.fields: List[str]) -> str:\n    \"\"\"Convert data to CSV format\"\"\"\n    output = io.StringIO()\n    writer = csv.DictWriter(output",
        "import:fastapi.nested_key)\n                    child_elem.text = str(nested_value) if nested_value is not None else ''\n            else:\n                elem = ET.SubElement(item_elem",
        "import:fastapi.le=1000)",
        "import:fastapi.\"law\": bill.law",
        "import:fastapi.item_name)\n        for key",
        "import:fastapi.'')\n        writer.writerow(flat_item)\n    \n    return output.getvalue()\n\ndef serialize_to_xml(data: List[Dict[str",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.Any\nimport csv\nimport json\nimport io\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.Vote\nfrom .bills import get_bills_list\nfrom .members import get_members_list\nfrom .debates import get_debates_list\nfrom .committees import get_committees_list\n\nrouter = APIRouter(prefix=\"/export\"",
        "import:fastapi.sponsor: Optional[str] = None",
        "import:fastapi.\"sponsor\": {\n                \"id\": bill.sponsor_politician_id",
        "import:fastapi.Query",
        "import:fastapi.Committee",
        "import:fastapi.\"name\": bill.name",
        "import:fastapi.item_name: str) -> str:\n    \"\"\"\n    Convert data to XML format\n    Based on legacy XML export patterns\n    \"\"\"\n    root = ET.Element(root_name)\n    \n    for item in data:\n        item_elem = ET.SubElement(root",
        "import:fastapi.nested_value in value.items():\n                    child_elem = ET.SubElement(nested_elem",
        "function:export_members",
        "import:fastapi.\"name\": bill.sponsor.name if bill.sponsor else None\n            } if bill.sponsor_politician_id else None",
        "import:fastapi.List",
        "import:fastapi.\"xml\"])",
        "import:fastapi.media_type=\"application/json\"",
        "import:fastapi.dict):\n                # Handle nested objects\n                nested_elem = ET.SubElement(item_elem",
        "import:fastapi.enum=[\"json\"",
        "import:fastapi.Dict",
        "import:fastapi.value in item.items():\n            if isinstance(value",
        "import:fastapi.APIRouter",
        "import:fastapi.encoding='str')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent=\"  \")\n\n@router.get(\"/bills\")\nasync def export_bills(\n    format: str = Query(\"json\"",
        "import:fastapi.db=db\n    )\n    \n    bills_data = [\n        {\n            \"id\": bill.id",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.HTTPException",
        "import:fastapi.\"number\": bill.number",
        "import:fastapi.fieldnames=fields)\n    writer.writeheader()\n    \n    for item in data:\n        # Flatten nested objects\n        flat_item = {}\n        for field in fields:\n            if '.' in field:\n                # Handle nested fields like \"party.name\"\n                parts = field.split('.')\n                value = item\n                for part in parts:\n                    value = value.get(part"
      ]
    },
    "GET:/bulk/{dataset}": {
      "method": "GET",
      "path": "/bulk/{dataset}",
      "file": "services/api-gateway/src/api/v1/export.py",
      "line": 245,
      "dependencies": [
        "import:fastapi.status: Optional[str] = None",
        "import:fastapi.privatemember=None",
        "import:fastapi.indent=2)",
        "import:fastapi.Any]]",
        "import:fastapi.headers={\"Content-Disposition\": f\"attachment",
        "import:fastapi.\"introduced\": bill.introduced.isoformat() if bill.introduced else None",
        "import:fastapi.Member",
        "import:fastapi.dict) else ''\n                flat_item[field] = value\n            else:\n                flat_item[field] = item.get(field",
        "import:fastapi.session: Optional[str] = None",
        "import:fastapi.'') if isinstance(value",
        "import:fastapi.Debate",
        "import:fastapi.\"csv\"",
        "import:fastapi.limit: int = Query(100",
        "import:fastapi.root_name: str",
        "import:fastapi.db: Session = Depends(get_db)\n):\n    \"\"\"\n    Export bills data in multiple formats\n    Based on legacy JSON export patterns\n    \"\"\"\n    # Get bills data\n    bills_response = await get_bills_list(\n        page=1",
        "import:fastapi.key)\n                for nested_key",
        "import:fastapi.session=session",
        "import:fastapi.tags=[\"export\"])\n\ndef serialize_to_csv(data: List[Dict[str",
        "function:export_debates",
        "import:fastapi.key)\n                elem.text = str(value) if value is not None else ''\n    \n    # Pretty print(X)ML\n    rough_string = ET.tostring(root",
        "import:fastapi.search=None",
        "import:fastapi.\"session\": bill.session",
        "import:fastapi.\"privatemember\": bill.privatemember\n        }\n        for bill in bills_response[\"results\"][:limit]\n    ]\n    \n    if format == \"json\":\n        return Response(\n            content=json.dumps(bills_data",
        "import:fastapi.fields: List[str]) -> str:\n    \"\"\"Convert data to CSV format\"\"\"\n    output = io.StringIO()\n    writer = csv.DictWriter(output",
        "import:fastapi.nested_key)\n                    child_elem.text = str(nested_value) if nested_value is not None else ''\n            else:\n                elem = ET.SubElement(item_elem",
        "import:fastapi.le=1000)",
        "import:fastapi.\"law\": bill.law",
        "import:fastapi.item_name)\n        for key",
        "import:fastapi.'')\n        writer.writerow(flat_item)\n    \n    return output.getvalue()\n\ndef serialize_to_xml(data: List[Dict[str",
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.Any\nimport csv\nimport json\nimport io\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.Vote\nfrom .bills import get_bills_list\nfrom .members import get_members_list\nfrom .debates import get_debates_list\nfrom .committees import get_committees_list\n\nrouter = APIRouter(prefix=\"/export\"",
        "import:fastapi.sponsor: Optional[str] = None",
        "import:fastapi.\"sponsor\": {\n                \"id\": bill.sponsor_politician_id",
        "import:fastapi.Query",
        "import:fastapi.Committee",
        "import:fastapi.\"name\": bill.name",
        "import:fastapi.item_name: str) -> str:\n    \"\"\"\n    Convert data to XML format\n    Based on legacy XML export patterns\n    \"\"\"\n    root = ET.Element(root_name)\n    \n    for item in data:\n        item_elem = ET.SubElement(root",
        "import:fastapi.nested_value in value.items():\n                    child_elem = ET.SubElement(nested_elem",
        "import:fastapi.\"name\": bill.sponsor.name if bill.sponsor else None\n            } if bill.sponsor_politician_id else None",
        "import:fastapi.List",
        "import:fastapi.\"xml\"])",
        "import:fastapi.media_type=\"application/json\"",
        "import:fastapi.dict):\n                # Handle nested objects\n                nested_elem = ET.SubElement(item_elem",
        "import:fastapi.enum=[\"json\"",
        "import:fastapi.Dict",
        "import:fastapi.value in item.items():\n            if isinstance(value",
        "import:fastapi.APIRouter",
        "import:fastapi.encoding='str')\n    reparsed = minidom.parseString(rough_string)\n    return reparsed.toprettyxml(indent=\"  \")\n\n@router.get(\"/bills\")\nasync def export_bills(\n    format: str = Query(\"json\"",
        "import:fastapi.db=db\n    )\n    \n    bills_data = [\n        {\n            \"id\": bill.id",
        "import:fastapi.\"status\": bill.status_code",
        "import:fastapi.HTTPException",
        "import:fastapi.\"number\": bill.number",
        "import:fastapi.fieldnames=fields)\n    writer.writeheader()\n    \n    for item in data:\n        # Flatten nested objects\n        flat_item = {}\n        for field in fields:\n            if '.' in field:\n                # Handle nested fields like \"party.name\"\n                parts = field.split('.')\n                value = item\n                for part in parts:\n                    value = value.get(part"
      ]
    },
    "ROUTER:/export": {
      "method": "ROUTER",
      "path": "/export",
      "file": "services/api-gateway/src/api/v1/export.py",
      "line": 23,
      "dependencies": [
        "import:fastapi.Response\nfrom typing import Optional",
        "import:fastapi.List",
        "import:fastapi.Any\nimport csv\nimport json\nimport io\nfrom datetime import datetime\nimport xml.etree.ElementTree as ET\nfrom xml.dom import minidom\nfrom sqlalchemy.orm import Session\nfrom fastapi import Depends\n\nfrom ...database import get_db\nfrom ...models import Bill",
        "import:fastapi.Member",
        "import:fastapi.Query",
        "import:fastapi.Dict",
        "import:fastapi.Debate",
        "import:fastapi.APIRouter",
        "import:fastapi.Committee",
        "import:fastapi.Vote\nfrom .bills import get_bills_list\nfrom .members import get_members_list\nfrom .debates import get_debates_list\nfrom .committees import get_committees_list\n\nrouter =",
        "import:fastapi.HTTPException"
      ]
    }
  },
  "components": {
    "AccessibilitySettings": {
      "file": "services/web-ui/src/components/AccessibilitySettings.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "StatusIndicator": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LiveStatusIndicator": {
      "file": "services/web-ui/src/components/StatusIndicator.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Footer": {
      "file": "services/admin-ui/src/components/footer/index.tsx",
      "type": "component",
      "api_calls": [],
      "routes": [
        "#",
        "#",
        "#",
        "#",
        "#"
      ]
    },
    "SkeletonLoader": {
      "file": "services/web-ui/src/components/SkeletonLoader.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LoadingSpinner": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "HouseStatus": {
      "file": "services/web-ui/src/components/HouseStatus.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "WordCloud": {
      "file": "services/web-ui/src/components/WordCloud.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Navbar": {
      "file": "services/web-ui/src/components/Navbar.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RecentBills": {
      "file": "services/web-ui/src/components/RecentBills.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ResponsiveTable": {
      "file": "services/web-ui/src/components/ResponsiveTable.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Breadcrumbs": {
      "file": "services/web-ui/src/components/Breadcrumbs.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Pagination": {
      "file": "services/web-ui/src/components/ui/Navigation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FeaturedDebate": {
      "file": "services/web-ui/src/components/FeaturedDebate.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AccessibilityProvider": {
      "file": "services/web-ui/src/components/AccessibilityProvider.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SkipToContent": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SearchBar": {
      "file": "services/web-ui/src/components/ui/Navigation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RecentVotes": {
      "file": "services/web-ui/src/components/RecentVotes.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "HomePage": {
      "file": "services/web-ui/src/app/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RootLayout": {
      "file": "services/web-ui/src/app/layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FeedbackPage": {
      "file": "services/web-ui/src/app/feedback/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPsPage": {
      "file": "services/web-ui/src/app/mps/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MobileAppPage": {
      "file": "services/web-ui/src/app/mobile-app/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LabsPage": {
      "file": "services/web-ui/src/app/labs/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "APIPage": {
      "file": "services/web-ui/src/app/api/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillsPage": {
      "file": "services/web-ui/src/app/bills/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VotingRecordsPage": {
      "file": "services/web-ui/src/app/voting-records/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebatesPage": {
      "file": "services/web-ui/src/app/debates/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SavedItemsPage": {
      "file": "services/web-ui/src/app/saved-items/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteesPage": {
      "file": "services/web-ui/src/app/committees/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "GovernmentPage": {
      "file": "services/web-ui/src/app/government/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/government-levels",
          "line": 23
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/stats/system",
          "line": 24
        }
      ],
      "routes": []
    },
    "FormerMPsPage": {
      "file": "services/web-ui/src/app/former-mps/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RepresentPage": {
      "file": "services/web-ui/src/app/represent/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SearchPage": {
      "file": "services/web-ui/src/app/search/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AboutPage": {
      "file": "services/web-ui/src/app/about/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "PostalSearchPage": {
      "file": "services/web-ui/src/app/search/postal/[code]/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RepresentPrivacyPage": {
      "file": "services/web-ui/src/app/represent/privacy/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RepresentDemoPage": {
      "file": "services/web-ui/src/app/represent/demo/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RepresentAPIPage": {
      "file": "services/web-ui/src/app/represent/api/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RepresentGovernmentPage": {
      "file": "services/web-ui/src/app/represent/government/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FederalPage": {
      "file": "services/web-ui/src/app/government/federal/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/government-levels",
          "line": 27
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/stats/government-levels/${federalLevel.id}",
          "line": 36
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/jurisdictions?government_level=${federalLevel.id}&page_size=10",
          "line": 37
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/representatives?government_level=${federalLevel.id}&page_size=10",
          "line": 38
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/bills?government_level=${federalLevel.id}&page_size=10",
          "line": 39
        }
      ],
      "routes": []
    },
    "AllVotesPage": {
      "file": "services/web-ui/src/app/government/votes/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/votes?${params}",
          "line": 30
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/government-levels",
          "line": 46
        }
      ],
      "routes": []
    },
    "AllBillsPage": {
      "file": "services/web-ui/src/app/government/bills/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/bills?${params}",
          "line": 30
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/government-levels",
          "line": 46
        }
      ],
      "routes": []
    },
    "AllRepresentativesPage": {
      "file": "services/web-ui/src/app/government/representatives/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/representatives?${params}",
          "line": 30
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/government-levels",
          "line": 46
        }
      ],
      "routes": []
    },
    "AllJurisdictionsPage": {
      "file": "services/web-ui/src/app/government/jurisdictions/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/jurisdictions?${params}",
          "line": 31
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/government-levels",
          "line": 47
        }
      ],
      "routes": []
    },
    "DataSourcesPage": {
      "file": "services/web-ui/src/app/government/data-sources/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/data-sources?${params}",
          "line": 29
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/government-levels",
          "line": 45
        }
      ],
      "routes": []
    },
    "JurisdictionDetailPage": {
      "file": "services/web-ui/src/app/government/jurisdictions/[id]/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/jurisdictions/${jurisdictionId}",
          "line": 50
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/stats/jurisdictions/${jurisdictionId}",
          "line": 51
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/representatives?jurisdiction_id=${jurisdictionId}&page_size=10",
          "line": 65
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/bills?jurisdiction_id=${jurisdictionId}&page_size=10",
          "line": 66
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/votes?page_size=10",
          "line": 67
        }
      ],
      "routes": []
    },
    "RepresentativeDetailPage": {
      "file": "services/web-ui/src/app/government/representatives/[id]/page.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/representatives/${representativeId}",
          "line": 43
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/bills?sponsor_id=${representativeId}&page_size=10",
          "line": 51
        },
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/votes?representative_id=${representativeId}&page_size=20",
          "line": 52
        }
      ],
      "routes": []
    },
    "BillDetailPage": {
      "file": "services/web-ui/src/app/bills/[id]/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteePage": {
      "file": "services/web-ui/src/app/committees/[slug]/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebatePage": {
      "file": "services/web-ui/src/app/debates/[date]/[number]/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VotingRecordPage": {
      "file": "services/web-ui/src/app/voting-records/[id]/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillDetailLoading": {
      "file": "services/web-ui/src/app/bills/[id]/loading.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Skeleton": {
      "file": "services/web-ui/src/components/ui/Skeleton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillDetailError": {
      "file": "services/web-ui/src/app/bills/[id]/error.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillPage": {
      "file": "services/web-ui/src/app/bills/[session]/[number]/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FastAPIDocsPage": {
      "file": "services/web-ui/src/app/api/docs/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "PoetryPage": {
      "file": "services/web-ui/src/app/labs/poetry/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VisualizationsPage": {
      "file": "services/web-ui/src/app/labs/visualizations/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ParliamentaryHaikuPage": {
      "file": "services/web-ui/src/app/labs/haiku/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPProfilePage": {
      "file": "services/web-ui/src/app/mps/[id]/page.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPProfileLoading": {
      "file": "services/web-ui/src/app/mps/[id]/loading.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPProfileError": {
      "file": "services/web-ui/src/app/mps/[id]/error.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FeedbackPortal": {
      "file": "services/web-ui/src/components/feedback/FeedbackPortal.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "${fiderUrl}/api/v1/health",
          "line": 30
        }
      ],
      "routes": []
    },
    "SearchFilters": {
      "file": "services/web-ui/src/components/Search/SearchFilters.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AdvancedSearch": {
      "file": "services/web-ui/src/components/Search/AdvancedSearch.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SearchResults": {
      "file": "services/web-ui/src/components/Search/SearchResults.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MobileAppDemo": {
      "file": "services/web-ui/src/components/mobile-app/MobileAppDemo.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VotingRecordsList": {
      "file": "services/web-ui/src/components/voting/VotingRecordsList.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VotingRecordDetail": {
      "file": "services/web-ui/src/components/voting/VotingRecordDetail.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ClickOutside": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FocusTrap": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Portal": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LazyLoad": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SuspenseBoundary": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Debounce": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Throttle": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LocalStorage": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SessionStorage": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MediaQuery": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "IntersectionObserver": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ResizeObserver": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "KeyboardShortcut": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CopyToClipboard": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Download": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Print": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ScrollToTop": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ScrollToElement": {
      "file": "services/web-ui/src/components/ui/Utilities.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Alert": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Toast": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ToastContainer": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ProgressBar": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Spinner": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SkeletonText": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SkeletonAvatar": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SkeletonCard": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Badge": {
      "file": "services/web-ui/src/components/ui/Feedback.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ValidationMessage": {
      "file": "services/web-ui/src/components/ui/Validation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ValidationField": {
      "file": "services/web-ui/src/components/ui/Validation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ValidationForm": {
      "file": "services/web-ui/src/components/ui/Validation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ValidationSummary": {
      "file": "services/web-ui/src/components/ui/Validation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RealTimeValidation": {
      "file": "services/web-ui/src/components/ui/Validation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Table": {
      "file": "services/web-ui/src/components/ui/DataDisplay.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DataGrid": {
      "file": "services/web-ui/src/components/ui/DataDisplay.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "List": {
      "file": "services/web-ui/src/components/ui/DataDisplay.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Stats": {
      "file": "services/web-ui/src/components/ui/DataDisplay.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Chart": {
      "file": "services/web-ui/src/components/ui/DataDisplay.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Progress": {
      "file": "services/web-ui/src/components/ui/DataDisplay.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Metric": {
      "file": "services/web-ui/src/components/ui/DataDisplay.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillCardSkeleton": {
      "file": "services/web-ui/src/components/ui/Skeleton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPCardSkeleton": {
      "file": "services/web-ui/src/components/ui/Skeleton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebateCardSkeleton": {
      "file": "services/web-ui/src/components/ui/Skeleton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeCardSkeleton": {
      "file": "services/web-ui/src/components/ui/Skeleton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VoteCardSkeleton": {
      "file": "services/web-ui/src/components/ui/Skeleton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TableSkeleton": {
      "file": "services/web-ui/src/components/ui/Skeleton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ListSkeleton": {
      "file": "services/web-ui/src/components/ui/Skeleton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BarChart": {
      "file": "services/web-ui/src/components/ui/DataVisualization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LineChart": {
      "file": "services/web-ui/src/components/ui/DataVisualization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "PieChart": {
      "file": "services/web-ui/src/components/ui/DataVisualization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DataTable": {
      "file": "services/web-ui/src/components/ui/DataVisualization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "StatsGrid": {
      "file": "services/web-ui/src/components/ui/DataVisualization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Image": {
      "file": "services/web-ui/src/components/ui/Media.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Video": {
      "file": "services/web-ui/src/components/ui/Media.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Audio": {
      "file": "services/web-ui/src/components/ui/Media.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MediaGallery": {
      "file": "services/web-ui/src/components/ui/Media.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TestRunner": {
      "file": "services/web-ui/src/components/ui/Testing.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TestResultItem": {
      "file": "services/web-ui/src/components/ui/Testing.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TestSuite": {
      "file": "services/web-ui/src/components/ui/Testing.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TestDashboard": {
      "file": "services/web-ui/src/components/ui/Testing.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TestDebugger": {
      "file": "services/web-ui/src/components/ui/Testing.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BaseButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Button": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SecondaryButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SuccessButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DangerButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "WarningButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "InfoButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "OutlineButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "GhostButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LinkButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "IconButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ButtonGroup": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ButtonGroupItem": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LoadingButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ToggleButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SocialButton": {
      "file": "services/web-ui/src/components/ui/Buttons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TextInput": {
      "file": "services/web-ui/src/components/ui/Forms.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "PasswordInput": {
      "file": "services/web-ui/src/components/ui/Forms.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Textarea": {
      "file": "services/web-ui/src/components/ui/Forms.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Select": {
      "file": "services/admin-ui/src/components/common/Select/index.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Checkbox": {
      "file": "services/web-ui/src/components/ui/Forms.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RadioGroup": {
      "file": "services/web-ui/src/components/ui/Forms.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormSection": {
      "file": "services/web-ui/src/components/ui/Forms.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Form": {
      "file": "services/web-ui/src/components/ui/Forms.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Container": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Grid": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Flex": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Stack": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Section": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Card": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Header": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Divider": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Spacer": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AspectRatio": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ResponsiveContainer": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SidebarLayout": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TwoColumnLayout": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "PageHeader": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ContentContainer": {
      "file": "services/web-ui/src/components/ui/Layout.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Modal": {
      "file": "services/web-ui/src/components/ui/Overlays.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ModalHeader": {
      "file": "services/web-ui/src/components/ui/Modal.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ModalBody": {
      "file": "services/web-ui/src/components/ui/Modal.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ModalFooter": {
      "file": "services/web-ui/src/components/ui/Modal.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ConfirmationModal": {
      "file": "services/web-ui/src/components/ui/Modal.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AlertModal": {
      "file": "services/web-ui/src/components/ui/Modal.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormModal": {
      "file": "services/web-ui/src/components/ui/Modal.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ThemeProvider": {
      "file": "services/web-ui/src/components/ui/Theme.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ThemeToggle": {
      "file": "services/web-ui/src/components/ui/Theme.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ColorSchemePicker": {
      "file": "services/web-ui/src/components/ui/Theme.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ThemeSwitcher": {
      "file": "services/web-ui/src/components/ui/Theme.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ThemeAware": {
      "file": "services/web-ui/src/components/ui/Theme.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "HighContrastToggle": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FontSizeToggle": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ReducedMotionToggle": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ThemeSettingsPanel": {
      "file": "services/web-ui/src/components/ui/Theme.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BaseCard": {
      "file": "services/web-ui/src/components/ui/Cards.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillCard": {
      "file": "services/web-ui/src/components/ui/Cards.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPCard": {
      "file": "services/web-ui/src/components/MPs/MPList.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebateCard": {
      "file": "services/web-ui/src/components/ui/Cards.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeCard": {
      "file": "services/web-ui/src/components/ui/Cards.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VoteCard": {
      "file": "services/web-ui/src/components/ui/Cards.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "EmptyState": {
      "file": "services/web-ui/src/components/ui/EmptyState.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LoadingState": {
      "file": "services/web-ui/src/components/ui/EmptyState.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ErrorState": {
      "file": "services/web-ui/src/components/ui/EmptyState.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "I18nProvider": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LanguageSelector": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Translation": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DateFormatter": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "TimeFormatter": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CurrencyFormatter": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "NumberFormatter": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RTLAware": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LanguageSwitcher": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "I18nSettingsPanel": {
      "file": "services/web-ui/src/components/ui/Internationalization.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FadeIn": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SlideIn": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ScaleIn": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RotateIn": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "StaggerContainer": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Parallax": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "HoverLift": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Pulse": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Bounce": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Shake": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Flip": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Typewriter": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Counter": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ProgressRing": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AnimatedList": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AnimatedTabs": {
      "file": "services/web-ui/src/components/ui/Animations.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Drawer": {
      "file": "services/web-ui/src/components/ui/Overlays.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Popover": {
      "file": "services/web-ui/src/components/ui/Overlays.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Tooltip": {
      "file": "services/web-ui/src/components/ui/Overlays.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LoadingOverlay": {
      "file": "services/web-ui/src/components/ui/Overlays.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Notification": {
      "file": "services/web-ui/src/components/ui/Overlays.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "NotificationContainer": {
      "file": "services/web-ui/src/components/ui/Overlays.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Breadcrumb": {
      "file": "services/web-ui/src/components/ui/Navigation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Tabs": {
      "file": "services/web-ui/src/components/ui/Navigation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SidebarNav": {
      "file": "services/web-ui/src/components/ui/Navigation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DropdownMenu": {
      "file": "services/web-ui/src/components/ui/Navigation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MobileMenu": {
      "file": "services/web-ui/src/components/ui/Navigation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormInput": {
      "file": "services/web-ui/src/components/ui/Form.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormTextarea": {
      "file": "services/web-ui/src/components/ui/Form.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormSelect": {
      "file": "services/web-ui/src/components/ui/Form.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormCheckbox": {
      "file": "services/web-ui/src/components/ui/Form.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormRadioGroup": {
      "file": "services/web-ui/src/components/ui/Form.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormFieldset": {
      "file": "services/web-ui/src/components/ui/Form.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormActions": {
      "file": "services/web-ui/src/components/ui/Form.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SkipLink": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ScreenReaderOnly": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LiveRegion": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AccessibilityMenu": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AriaLabel": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AriaDescribedBy": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "KeyboardNavigation": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Announcement": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AccessibleLoading": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AccessibleProgress": {
      "file": "services/web-ui/src/components/ui/Accessibility.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillText": {
      "file": "services/web-ui/src/components/Bills/BillText.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RelatedDebates": {
      "file": "services/web-ui/src/components/Bills/RelatedDebates.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillVotesList": {
      "file": "services/web-ui/src/components/Bills/BillVotesList.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillTabs": {
      "file": "services/web-ui/src/components/Bills/BillTabs.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillAmendments": {
      "file": "services/web-ui/src/components/Bills/BillAmendments.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillVotes": {
      "file": "services/web-ui/src/components/Bills/BillVotes.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillVoteCasting": {
      "file": "services/web-ui/src/components/Bills/BillVoteCasting.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillHistory": {
      "file": "services/web-ui/src/components/Bills/BillHistory.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillCommittees": {
      "file": "services/web-ui/src/components/Bills/BillCommittees.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillDetail": {
      "file": "services/web-ui/src/components/Bills/BillDetail.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillStatusTracker": {
      "file": "services/web-ui/src/components/Bills/BillStatusTracker.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillsList": {
      "file": "services/web-ui/src/components/Bills/BillsList.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillsFilters": {
      "file": "services/web-ui/src/components/Bills/BillsFilters.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillAnalysis": {
      "file": "services/web-ui/src/components/Bills/BillAnalysis.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillPublicVoting": {
      "file": "services/web-ui/src/components/Bills/BillPublicVoting.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillChat": {
      "file": "services/web-ui/src/components/chat/BillChat.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebateTranscript": {
      "file": "services/web-ui/src/components/Debates/DebateTranscript.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebatesFilters": {
      "file": "services/web-ui/src/components/Debates/DebatesFilters.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebateTopics": {
      "file": "services/web-ui/src/components/Debates/DebateTopics.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebateWordCloud": {
      "file": "services/web-ui/src/components/Debates/DebateWordCloud.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebatesList": {
      "file": "services/web-ui/src/components/Debates/DebatesList.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebateSummary": {
      "file": "services/web-ui/src/components/Debates/DebateSummary.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SavedItemsManager": {
      "file": "services/web-ui/src/components/saved-items/SavedItemsManager.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "SaveButton": {
      "file": "services/web-ui/src/components/saved-items/SaveButton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillSaveButton": {
      "file": "services/web-ui/src/components/saved-items/SaveButton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPSaveButton": {
      "file": "services/web-ui/src/components/saved-items/SaveButton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "DebateSaveButton": {
      "file": "services/web-ui/src/components/saved-items/SaveButton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeSaveButton": {
      "file": "services/web-ui/src/components/saved-items/SaveButton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VoteSaveButton": {
      "file": "services/web-ui/src/components/saved-items/SaveButton.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeNews": {
      "file": "services/web-ui/src/components/Committees/CommitteeNews.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeMembers": {
      "file": "services/web-ui/src/components/Committees/CommitteeMembers.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeHeader": {
      "file": "services/web-ui/src/components/Committees/CommitteeHeader.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteesList": {
      "file": "services/web-ui/src/components/Committees/CommitteesList.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeHistory": {
      "file": "services/web-ui/src/components/Committees/CommitteeHistory.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteesFilters": {
      "file": "services/web-ui/src/components/Committees/CommitteesFilters.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeReports": {
      "file": "services/web-ui/src/components/Committees/CommitteeReports.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RecentMeetings": {
      "file": "services/web-ui/src/components/Committees/RecentMeetings.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeTabs": {
      "file": "services/web-ui/src/components/Committees/CommitteeTabs.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ActiveStudies": {
      "file": "services/web-ui/src/components/Committees/ActiveStudies.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "IssueForm": {
      "file": "services/web-ui/src/components/issues/IssueForm.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FederalIcon": {
      "file": "services/web-ui/src/components/Government/GovernmentIcons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ProvincialIcon": {
      "file": "services/web-ui/src/components/Government/GovernmentIcons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MunicipalIcon": {
      "file": "services/web-ui/src/components/Government/GovernmentIcons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "RepresentativeIcon": {
      "file": "services/web-ui/src/components/Government/GovernmentIcons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillIcon": {
      "file": "services/web-ui/src/components/Government/GovernmentIcons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "VoteIcon": {
      "file": "services/web-ui/src/components/Government/GovernmentIcons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "JurisdictionIcon": {
      "file": "services/web-ui/src/components/Government/GovernmentIcons.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPProfile": {
      "file": "services/admin-ui/src/pages/mps/[id].tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/politician",
          "line": 42
        }
      ],
      "routes": [
        "/former-mps"
      ]
    },
    "MPSpeeches": {
      "file": "services/web-ui/src/components/MPs/MPSpeeches.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPContactInfo": {
      "file": "services/web-ui/src/components/MPs/MPContactInfo.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPWordAnalysis": {
      "file": "services/web-ui/src/components/MPs/MPWordAnalysis.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPList": {
      "file": "services/web-ui/src/components/MPs/MPList.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPCommittees": {
      "file": "services/web-ui/src/components/MPs/MPCommittees.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPActivity": {
      "file": "services/web-ui/src/components/MPs/MPActivity.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPTabs": {
      "file": "services/web-ui/src/components/MPs/MPTabs.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPVotes": {
      "file": "services/web-ui/src/components/MPs/MPVotes.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPFilters": {
      "file": "services/web-ui/src/components/MPs/MPFilters.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPElectoralHistory": {
      "file": "services/web-ui/src/components/MPs/MPElectoralHistory.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "FormerMPsList": {
      "file": "services/web-ui/src/components/MPs/FormerMPsList.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "MPVotingRecord": {
      "file": "services/web-ui/src/components/MPs/MPVotingRecord.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "App": {
      "file": "services/admin-ui/src/App.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AuthProvider": {
      "file": "services/admin-ui/src/context/AuthContext.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "NotificationSetup": {
      "file": "services/admin-ui/src/pages/NotificationSetup.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "UserManagement": {
      "file": "services/admin-ui/src/pages/UserManagement.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "APIGatewayDashboard": {
      "file": "services/admin-ui/src/pages/APIGatewayDashboard.tsx",
      "type": "component",
      "api_calls": [],
      "routes": [
        "/api/v1/multi-level-government/government-levels",
        "/api/v1/multi-level-government/jurisdictions",
        "/api/v1/multi-level-government/representatives",
        "/api/v1/multi-level-government/bills",
        "/api/v1/multi-level-government/stats",
        "/api/v1/etl/jobs",
        "/api/v1/admin/activity"
      ]
    },
    "Dashboard": {
      "file": "services/admin-ui/src/pages/Dashboard.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/api/v1/multi-level-government/stats",
          "line": 60
        }
      ],
      "routes": [
        "/etl",
        "/monitoring",
        "/data/quality",
        "/etl",
        "/representatives",
        "/bills"
      ]
    },
    "UmamiAnalytics": {
      "file": "services/admin-ui/src/pages/UmamiAnalytics.tsx",
      "type": "component",
      "api_calls": [],
      "routes": [
        "/",
        "/mps",
        "/bills",
        "/debates",
        "/government",
        "/search"
      ]
    },
    "DatabaseDashboard": {
      "file": "services/admin-ui/src/pages/DatabaseDashboard.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ETLManagement": {
      "file": "services/admin-ui/src/pages/ETLManagement.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ScrapersDashboard": {
      "file": "services/admin-ui/src/pages/ScrapersDashboard.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "NotificationStats": {
      "file": "services/admin-ui/src/pages/NotificationStats.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Mps": {
      "file": "services/admin-ui/src/pages/mps/index.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/politician",
          "line": 19
        }
      ],
      "routes": [
        "/former-mps"
      ]
    },
    "LoadingMPCard": {
      "file": "services/admin-ui/src/pages/mps/index.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/politician",
          "line": 19
        }
      ],
      "routes": [
        "/former-mps"
      ]
    },
    "FormerMps": {
      "file": "services/admin-ui/src/pages/mps/former-mp.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/former-politician",
          "line": 24
        }
      ],
      "routes": [
        "/former-mps"
      ]
    },
    "Login": {
      "file": "services/admin-ui/src/pages/auth/Login.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "LoadingCard": {
      "file": "services/admin-ui/src/pages/government-bills/index.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/bills",
          "line": 45
        }
      ],
      "routes": []
    },
    "GovernmentBills": {
      "file": "services/admin-ui/src/pages/government-bills/index.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/bills",
          "line": 45
        }
      ],
      "routes": []
    },
    "DebateSearch": {
      "file": "services/admin-ui/src/pages/other/debtaes.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/get-house-mention",
          "line": 20
        }
      ],
      "routes": []
    },
    "VoteSearch": {
      "file": "services/admin-ui/src/pages/other/votes.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "CommitteeSearch": {
      "file": "services/admin-ui/src/pages/other/commitee.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "BillSearch": {
      "file": "services/admin-ui/src/pages/other/bills.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/get-bill/",
          "line": 13
        }
      ],
      "routes": []
    },
    "Bills": {
      "file": "services/admin-ui/src/pages/bills/index.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/bills/summary/",
          "line": 32
        },
        {
          "method": "GET",
          "endpoint": "/web/bills/house-mention/",
          "line": 43
        }
      ],
      "routes": []
    },
    "Debates": {
      "file": "services/admin-ui/src/pages/debates/index.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/debate/debate-get-year",
          "line": 23
        },
        {
          "method": "GET",
          "endpoint": "/web/debate/debate-mentions/",
          "line": 26
        },
        {
          "method": "GET",
          "endpoint": "/web/debate/debate-get-year-date",
          "line": 37
        },
        {
          "method": "GET",
          "endpoint": "/web/debate/debate-mentions/",
          "line": 52
        }
      ],
      "routes": []
    },
    "HouseCommitte": {
      "file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/committee/committee-topics",
          "line": 25
        },
        {
          "method": "GET",
          "endpoint": "/web/committee/committee-mentions/",
          "line": 29
        },
        {
          "method": "GET",
          "endpoint": "/web/committee/committee-get-year",
          "line": 48
        },
        {
          "method": "GET",
          "endpoint": "/web/committee/committee-get-year-data/",
          "line": 66
        },
        {
          "method": "GET",
          "endpoint": "/web/committee/committee-mentions/",
          "line": 84
        }
      ],
      "routes": []
    },
    "Speech": {
      "file": "services/admin-ui/src/pages/house-committee/speech.tsx",
      "type": "component",
      "api_calls": [
        {
          "method": "GET",
          "endpoint": "/web/committee/committee-mentions/",
          "line": 11
        }
      ],
      "routes": []
    },
    "About": {
      "file": "services/admin-ui/src/pages/about/index.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "Navigation": {
      "file": "services/admin-ui/src/components/navigation/index.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "AdminNavigation": {
      "file": "services/admin-ui/src/components/navigation/AdminNavigation.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "UserProfile": {
      "file": "services/admin-ui/src/components/auth/UserProfile.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "ProtectedRoute": {
      "file": "services/admin-ui/src/components/auth/ProtectedRoute.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    },
    "UserActivity": {
      "file": "services/admin-ui/src/components/users/UserActivity.tsx",
      "type": "component",
      "api_calls": [],
      "routes": []
    }
  },
  "mappings": [
    {
      "api_route": "GET:/{session_id}/{vote_number}",
      "api_path": "/{session_id}/{vote_number}",
      "api_file": "services/api-gateway/app/api/v1/votes.py",
      "component": "MPProfile",
      "component_file": "services/admin-ui/src/pages/mps/[id].tsx",
      "ui_routes": [
        "/former-mps"
      ],
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    {
      "api_route": "GET:/{session_id}/{vote_number}",
      "api_path": "/{session_id}/{vote_number}",
      "api_file": "services/api-gateway/app/api/v1/votes.py",
      "component": "Mps",
      "component_file": "services/admin-ui/src/pages/mps/index.tsx",
      "ui_routes": [
        "/former-mps"
      ],
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    {
      "api_route": "GET:/{session_id}/{vote_number}",
      "api_path": "/{session_id}/{vote_number}",
      "api_file": "services/api-gateway/app/api/v1/votes.py",
      "component": "LoadingMPCard",
      "component_file": "services/admin-ui/src/pages/mps/index.tsx",
      "ui_routes": [
        "/former-mps"
      ],
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    {
      "api_route": "GET:/{session_id}/{vote_number}",
      "api_path": "/{session_id}/{vote_number}",
      "api_file": "services/api-gateway/app/api/v1/votes.py",
      "component": "FormerMps",
      "component_file": "services/admin-ui/src/pages/mps/former-mp.tsx",
      "ui_routes": [
        "/former-mps"
      ],
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    {
      "api_route": "GET:/{session_id}/{vote_number}",
      "api_path": "/{session_id}/{vote_number}",
      "api_file": "services/api-gateway/app/api/v1/votes.py",
      "component": "LoadingCard",
      "component_file": "services/admin-ui/src/pages/government-bills/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    {
      "api_route": "GET:/{session_id}/{vote_number}",
      "api_path": "/{session_id}/{vote_number}",
      "api_file": "services/api-gateway/app/api/v1/votes.py",
      "component": "GovernmentBills",
      "component_file": "services/admin-ui/src/pages/government-bills/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    {
      "api_route": "GET:/{session_id}/{vote_number}",
      "api_path": "/{session_id}/{vote_number}",
      "api_file": "services/api-gateway/app/api/v1/votes.py",
      "component": "DebateSearch",
      "component_file": "services/admin-ui/src/pages/other/debtaes.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    {
      "api_route": "GET:/{session_id}/{vote_number}",
      "api_path": "/{session_id}/{vote_number}",
      "api_file": "services/api-gateway/app/api/v1/votes.py",
      "component": "BillSearch",
      "component_file": "services/admin-ui/src/pages/other/bills.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.description=\"Bill filter (e.g.",
        "import:fastapi.Bill",
        "import:fastapi.response_model=VoteListResponse)\nasync def list_votes(\n    q: Optional[str] = Query(None",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.:search_term)\n        \"\"\")\n        query = query.filter(search_query.bindparams(search_term=q))\n    \n    # Apply filters\n    if session:\n        query = query.filter(Bill.session_id == session)\n    \n    if bill:\n        # Parse bill filter (e.g.",
        "import:fastapi.description=vote.description",
        "import:fastapi.page_size=page_size",
        "import:fastapi.pages=total_pages\n    )\n    \n    return VoteListResponse(\n        votes=vote_summaries",
        "import:fastapi.Member",
        "import:fastapi.date=vote.date",
        "import:fastapi.UserVoteResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.bill_title=vote.bill.name_en\n        ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.VoteBallotsResponse",
        "import:fastapi.VoteSummaryResponse",
        "import:fastapi.result: Optional[str] = Query(None",
        "import:fastapi.description=\"Vote type filter\")",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'unanimous': 'unanimous'",
        "import:fastapi.VoteBallot",
        "import:fastapi.bills_bill.name_en || ' ' || COALESCE(votes_vote.description",
        "import:fastapi.description=\"Vote number in session\")",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.'')) \n            @@ plainto_tsquery('english'",
        "import:fastapi.bill_number = bill.split('/'",
        "import:fastapi.'45-1/C-5')\")",
        "import:fastapi.Bill.number == bill_number)\n    \n    if result:\n        query = query.filter(Vote.result == result)\n    \n    if type:\n        # For now",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.'recorded': 'recorded'\n        }\n        if type in type_mapping:\n            # This is a placeholder - actual implementation would filter by vote type\n            pass\n    \n    if date__gte:\n        query = query.filter(Vote.date >= date__gte)\n    \n    if date__lte:\n        query = query.filter(Vote.date <= date__lte)\n    \n    if number:\n        query = query.filter(Vote.number == number)\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    votes = query.offset(offset).limit(page_size).all()\n    \n    # Convert to response format\n    vote_summaries = []\n    for vote in votes:\n        # Get vote totals\n        yea_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.VoteAnalysis",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.session=vote.bill.session_id",
        "import:fastapi.type: Optional[str] = Query(None",
        "import:fastapi.ge=1",
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text\nfrom typing import Optional\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.VoteAnalysisResponse",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.UserVoteCast",
        "import:fastapi.description=\"Vote result filter\")",
        "import:fastapi.Query",
        "import:fastapi.yea_total=yea_total",
        "import:fastapi.le=100",
        "import:fastapi.MPVotePosition",
        "import:fastapi.VoteListResponse",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Member.vote == 'Yea'\n        ).count()\n        \n        nay_total = db.query(Member).filter(\n            Member.votequestion_id == vote.id",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.Party\nfrom app.schemas.votes import (\n    VoteSummary",
        "import:fastapi.session: Optional[str] = Query(None",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary votes with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Filtering by bill\n    - Filtering by result\n    - Date range filtering\n    - Filtering by vote number\n    - Pagination\n    \"\"\"\n    \n    # Build base query\n    query = db.query(Vote).join(Bill)\n    \n    # Apply search if query provided\n    if q:\n        # Use PostgreSQL full-text search on bill name and vote description\n        search_query = text(\"\"\"\n            to_tsvector('english'",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.\"45-1/C-5\")\n        if '/' in bill:\n            session_id",
        "import:fastapi.Member.vote == 'Nay'\n        ).count()\n        \n        vote_summaries.append(VoteSummary(\n            vote_id=str(vote.id)",
        "import:fastapi.bill_number=vote.bill.number",
        "import:fastapi.1)\n            query = query.filter(Bill.session_id == session_id",
        "import:fastapi.Pagination",
        "import:fastapi.'voice': 'voice'",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.we'll use a simplified type mapping\n        # In a full implementation",
        "import:fastapi.result=vote.result",
        "import:fastapi.bill: Optional[str] = Query(None",
        "import:fastapi.nay_total=nay_total",
        "import:fastapi.this would come from a vote type field\n        type_mapping = {\n            'division': 'division'",
        "import:fastapi.APIRouter",
        "import:fastapi.VoteDetailResponse",
        "import:fastapi.description=\"Search query for bill title or description\")",
        "import:fastapi.number=vote.number",
        "import:fastapi.VoteDetail",
        "import:fastapi.HTTPException",
        "function:list_votes"
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "Bills",
      "component_file": "services/admin-ui/src/pages/bills/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "Bills",
      "component_file": "services/admin-ui/src/pages/bills/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "Bills",
      "component_file": "services/admin-ui/src/pages/bills/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "Bills",
      "component_file": "services/admin-ui/src/pages/bills/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "Debates",
      "component_file": "services/admin-ui/src/pages/debates/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "Debates",
      "component_file": "services/admin-ui/src/pages/debates/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "Debates",
      "component_file": "services/admin-ui/src/pages/debates/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "Debates",
      "component_file": "services/admin-ui/src/pages/debates/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "Debates",
      "component_file": "services/admin-ui/src/pages/debates/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "Debates",
      "component_file": "services/admin-ui/src/pages/debates/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "Debates",
      "component_file": "services/admin-ui/src/pages/debates/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "Debates",
      "component_file": "services/admin-ui/src/pages/debates/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "HouseCommitte",
      "component_file": "services/admin-ui/src/pages/house-committee/index.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    },
    {
      "api_route": "GET:/{year}/{month}/{day}/",
      "api_path": "/{year}/{month}/{day}/",
      "api_file": "services/api-gateway/app/api/v1/debates.py",
      "component": "Speech",
      "component_file": "services/admin-ui/src/pages/house-committee/speech.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.date=debate_date.date().isoformat()",
        "import:fastapi.page_size=page_size",
        "import:fastapi.datetime.max.time())\n                )\n            ).distinct().count()\n            \n            debate_summaries.append(DebateSummary(\n                id=f\"{debate_date.year}-{debate_date.month:02d}-{debate_date.day:02d}\"",
        "import:fastapi.url=f\"/api/v1/debates/{debate_date.year}/{debate_date.month:02d}/{debate_date.day:02d}/\"\n            ))\n    \n    # Calculate pagination info\n    total_pages = (total + page_size - 1) // page_size\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.DebateDetailResponse",
        "import:fastapi.Member",
        "import:fastapi.DebateListResponse",
        "import:fastapi.SpeechListResponse",
        "import:fastapi.SpeechSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.) in debate_dates:\n        if debate_date:\n            # Count total votes for this date\n            vote_count = db.query(Vote).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.pages=total_pages\n    )\n    \n    return DebateListResponse(\n        debates=debate_summaries",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.Party\nfrom app.schemas.debates import (\n    DebateSummary",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Get total count for pagination\n    total = query.count()\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    debate_dates = query.offset(offset).limit(page_size).all()\n    \n    # Get debate summaries for each date\n    debate_summaries = []\n    for (debate_date",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.SpeechDetail",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.DebateSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "function:list_debates",
        "import:fastapi.and_",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.ge=1",
        "import:fastapi.description=\"Hansard number in session\")",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.description=\"Language (en/fr)\")",
        "import:fastapi.Query",
        "import:fastapi.SpeechDetailResponse",
        "import:fastapi.le=100",
        "import:fastapi.response_model=DebateListResponse)\nasync def list_debates(\n    session: Optional[str] = Query(None",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.'45-1')\")",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.number=debate_date.day",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.lang: Optional[str] = Query(\"en\"",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List House debates with optional filtering.\n    \n    Supports:\n    - Filtering by session\n    - Date range filtering\n    - Filtering by hansard number\n    - Pagination\n    \"\"\"\n    \n    # Build base query for votes/debates\n    # Group by date to get unique debate dates\n    query = db.query(Vote.vote_date).distinct()\n    \n    # Apply filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.DebateDetail",
        "import:fastapi.Pagination",
        "import:fastapi.number: Optional[int] = Query(None",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.# Using day as the number for now\n                statement_count=vote_count",
        "import:fastapi.Vote.vote_date < datetime.combine(debate_date.date()",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(Vote.vote_date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.APIRouter",
        "import:fastapi.datetime.min.time())",
        "import:fastapi.datetime.max.time())\n                )\n            ).count()\n            \n            # Get unique bills for this date\n            bill_count = db.query(Vote.bill_id).filter(\n                and_(\n                    Vote.vote_date >= datetime.combine(debate_date.date()",
        "import:fastapi.HTTPException"
      ]
    },
    {
      "api_route": "GET:/{committee_slug}/{session_id}/{number}/",
      "api_path": "/{committee_slug}/{session_id}/{number}/",
      "api_file": "services/api-gateway/app/api/v1/committees.py",
      "component": "Speech",
      "component_file": "services/admin-ui/src/pages/house-committee/speech.tsx",
      "ui_routes": [],
      "dependencies": [
        "import:fastapi.Depends\nfrom sqlalchemy.orm import Session as DBSession\nfrom sqlalchemy import text",
        "import:fastapi.Bill",
        "import:fastapi.page_size=page_size",
        "import:fastapi.detail=\"Committee not found\")\n    \n    # Build query for committee meetings\n    query = db.query(CommitteeMeeting).filter(CommitteeMeeting.committee_id == committee_id)\n    \n    # Apply date filters\n    if date__gte:\n        try:\n            date_gte = datetime.strptime(date__gte",
        "import:fastapi.description=\"Session ID filter (e.g.",
        "import:fastapi.Optional\nfrom datetime import date",
        "import:fastapi.page_size: int = Query(20",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get meetings for a specific committee.\n    \n    Returns a paginated list of committee meetings with optional filtering\n    by date range and session ID.\n    \n    This endpoint implements the committee meetings functionality required by\n    checklist item 150.14.\n    \"\"\"\n    \n    # Verify committee exists\n    committee = db.query(Committee).filter(Committee.id == committee_id).first()\n    if not committee:\n        raise HTTPException(status_code=404",
        "function:list_committee_meetings",
        "import:fastapi.CommitteeSummary(\n            id=\"2\"",
        "import:fastapi.ge=1",
        "import:fastapi.response_model=MeetingListResponse)\nasync def list_committee_meetings(\n    committee: Optional[str] = Query(None",
        "import:fastapi.le=100",
        "import:fastapi.datetime\nfrom app.database import get_db\nfrom app.models.openparliament import Vote",
        "import:fastapi.description=\"Date greater than or equal (YYYY-MM-DD)\")",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List parliamentary committees with optional filtering.\n    \n    Based on legacy CommitteeListView functionality.\n    Note: This is a simplified version since we don't have a committees table in our current schema.\n    \"\"\"\n    \n    # For now",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    # Apply session filter\n    if session_id:\n        query = query.filter(CommitteeMeeting.session_id == session_id)\n    \n    # Get total count\n    total = query.count()\n    # Defensive check for Mock objects during testing\n    if str(type(total)) == \"<class 'unittest.mock.Mock'>\":\n        total = 0\n    \n    # Apply pagination\n    offset = (page - 1) * page_size\n    meetings = query.order_by(desc(CommitteeMeeting.date)",
        "import:fastapi.detail=\"Committee not found\")\n    \n    committee_detail = CommitteeDetail(\n        id=\"1\" if committee_slug == \"finance\" else \"2\"",
        "import:fastapi.date__lte: Optional[str] = Query(None",
        "import:fastapi.MeetingSummary",
        "import:fastapi.short_name=\"FINA\"",
        "import:fastapi.desc\nfrom typing import List",
        "import:fastapi.total=len(committees)",
        "import:fastapi.pages=1\n    )\n    \n    return CommitteeListResponse(\n        committees=committees",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    Get detailed information about a specific committee.\n    \n    Based on legacy CommitteeView functionality.\n    \"\"\"\n    \n    # Placeholder implementation - in reality would query committee table\n    if committee_slug not in [\"finance\"",
        "import:fastapi.HTTPException",
        "import:fastapi.CommitteeDetail",
        "import:fastapi.MeetingListResponse",
        "import:fastapi.response_model=CommitteeListResponse)\nasync def list_committees(\n    session: Optional[str] = Query(None",
        "import:fastapi.name=f\"Standing Committee on {committee_slug.title()}\"",
        "import:fastapi.Member",
        "import:fastapi.detail=\"Invalid date format. Use YYYY-MM-DD\")\n    \n    if date__lte:\n        try:\n            date_lte = datetime.strptime(date__lte",
        "import:fastapi.session_id=meeting.session_id",
        "import:fastapi.description=\"Date less than or equal (YYYY-MM-DD)\")",
        "import:fastapi.url=f\"/api/v1/committees/{committee.slug}/{meeting.session_id}/{meeting.number}/\"\n        ))\n    \n    # Calculate pagination\n    total_pages = (total + page_size - 1) // page_size if total > 0 else 0\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.recent_meetings=[]",
        "import:fastapi.desc(CommitteeMeeting.number)).offset(offset).limit(page_size).all()\n    \n    # Defensive check for Mock objects during testing\n    if str(type(meetings)) == \"<class 'unittest.mock.Mock'>\":\n        meetings = []\n    \n    # Convert to response format\n    meeting_summaries = []\n    for meeting in meetings:\n        meeting_summaries.append(MeetingSummary(\n            id=str(meeting.id)",
        "import:fastapi.and_",
        "import:fastapi.committee_name=committee.name_en",
        "import:fastapi.active_only: bool = Query(True",
        "import:fastapi.has_evidence=meeting.has_evidence",
        "import:fastapi.'45-1')\")",
        "import:fastapi.Party",
        "import:fastapi.pages=0\n    )\n    \n    return MeetingListResponse(\n        meetings=meetings",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_slug}/\"",
        "import:fastapi.total=0",
        "import:fastapi.short_name=\"FINA\" if committee_slug == \"finance\" else \"HESA\"",
        "import:fastapi.name=\"Standing Committee on Health\"",
        "import:fastapi.Session\nfrom app.schemas.committees import (\n    CommitteeSummary",
        "import:fastapi.name=\"Standing Committee on Finance\"",
        "import:fastapi.CommitteeDetailResponse",
        "import:fastapi.pages=total_pages\n    )\n    \n    return MeetingListResponse(\n        meetings=meeting_summaries",
        "import:fastapi.db: DBSession = Depends(get_db)\n):\n    \"\"\"\n    List committee meetings with optional filtering.\n    \n    Based on legacy CommitteeMeetingListView functionality.\n    Note: Simplified version since we don't have committee meeting models.\n    \"\"\"\n    \n    # Placeholder implementation\n    meetings = []\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.page: int = Query(1",
        "import:fastapi.return a placeholder response since we don't have committee models\n    # In the real implementation",
        "import:fastapi.committee_slug=committee.slug",
        "import:fastapi.short_name=\"HESA\"",
        "import:fastapi.pagination=pagination\n    )",
        "import:fastapi.response_model=MeetingListResponse)\nasync def get_committee_meetings(\n    committee_id: int",
        "import:fastapi.url=f\"/api/v1/committees/{committee_slug}/\"\n    )\n    \n    return CommitteeDetailResponse(committee=committee_detail)\n\n\n@router.get(\"/meetings/\"",
        "import:fastapi.date__gte: Optional[str] = Query(None",
        "import:fastapi.description=\"Items per page\")",
        "import:fastapi.url=\"/api/v1/committees/health/\"\n        )\n    ]\n    \n    pagination = Pagination(\n        page=page",
        "import:fastapi.url=\"/api/v1/committees/finance/\"\n        )",
        "import:fastapi.Query",
        "import:fastapi.total=total",
        "import:fastapi.description=\"Session ID (e.g.",
        "import:fastapi.session_id: Optional[str] = Query(None",
        "import:fastapi.date=meeting.date.isoformat() if meeting.date else None",
        "import:fastapi.member_count=0",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date >= date_gte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.number=meeting.number",
        "import:fastapi.meeting_count=0",
        "import:fastapi.description=\"Page number\")",
        "import:fastapi.MeetingDetailResponse",
        "import:fastapi.MeetingDetail",
        "import:fastapi.\"health\"]:\n        raise HTTPException(status_code=404",
        "import:fastapi.active=True",
        "import:fastapi.response_model=CommitteeDetailResponse)\nasync def get_committee_detail(\n    committee_slug: str",
        "import:fastapi.description=\"Committee slug filter\")",
        "import:fastapi.pagination=pagination\n    )\n\n\n@router.get(\"/{committee_id}/meetings\"",
        "import:fastapi.CommitteeSummaryResponse\n)\n\nrouter = APIRouter()\n\n\n@router.get(\"/\"",
        "import:fastapi.CommitteeListResponse",
        "import:fastapi.\"%Y-%m-%d\").date()\n            query = query.filter(CommitteeMeeting.date <= date_lte)\n        except ValueError:\n            raise HTTPException(status_code=400",
        "import:fastapi.Pagination",
        "import:fastapi.APIRouter",
        "import:fastapi.description=\"Show only active committees\")",
        "import:fastapi.this would query the committees table\n    committees = [\n        CommitteeSummary(\n            id=\"1\""
      ]
    }
  ],
  "realignment_needs": {
    "orphan_routes": [
      {
        "route": "GET:/",
        "path": "/",
        "file": "services/api-gateway/app/api/v1/endpoints/health.py"
      },
      {
        "route": "GET:/healthz",
        "path": "/healthz",
        "file": "services/api-gateway/app/main.py"
      },
      {
        "route": "GET:/version",
        "path": "/version",
        "file": "services/api-gateway/app/main.py"
      },
      {
        "route": "GET:/metrics",
        "path": "/metrics",
        "file": "services/api-gateway/app/api/v1/performance_optimization.py"
      },
      {
        "route": "GET:/suggestions",
        "path": "/suggestions",
        "file": "services/api-gateway/app/api/v1/members.py"
      },
      {
        "route": "GET:/summary/stats",
        "path": "/summary/stats",
        "file": "services/api-gateway/app/api/v1/members.py"
      },
      {
        "route": "GET:/{bill_id}",
        "path": "/{bill_id}",
        "file": "services/api-gateway/app/api/v1/bills.py"
      },
      {
        "route": "GET:/{bill_id}/votes",
        "path": "/{bill_id}/votes",
        "file": "services/api-gateway/app/api/v1/bills.py"
      },
      {
        "route": "GET:/{bill_id}/history",
        "path": "/{bill_id}/history",
        "file": "services/api-gateway/app/api/v1/bills.py"
      },
      {
        "route": "GET:/{bill_id}/amendments",
        "path": "/{bill_id}/amendments",
        "file": "services/api-gateway/app/api/v1/bills.py"
      },
      {
        "route": "GET:/{bill_id}/timeline",
        "path": "/{bill_id}/timeline",
        "file": "services/api-gateway/app/api/v1/bills.py"
      },
      {
        "route": "GET:/{bill_id}/status",
        "path": "/{bill_id}/status",
        "file": "services/api-gateway/app/api/v1/bills.py"
      },
      {
        "route": "POST:/bills/{bill_id}/cast-vote",
        "path": "/bills/{bill_id}/cast-vote",
        "file": "services/api-gateway/app/api/v1/votes.py"
      },
      {
        "route": "GET:/bills/{bill_id}/user-votes",
        "path": "/bills/{bill_id}/user-votes",
        "file": "services/api-gateway/app/api/v1/bill_voting.py"
      },
      {
        "route": "GET:/user/{user_id}/voting-history",
        "path": "/user/{user_id}/voting-history",
        "file": "services/api-gateway/app/api/v1/user-voting.py"
      },
      {
        "route": "GET:/bills/{bill_id}/voting-summary",
        "path": "/bills/{bill_id}/voting-summary",
        "file": "services/api-gateway/app/api/v1/bill_voting.py"
      },
      {
        "route": "GET:/user/{user_id}/voting-recommendations",
        "path": "/user/{user_id}/voting-recommendations",
        "file": "services/api-gateway/app/api/v1/user-voting.py"
      },
      {
        "route": "POST:/cast-vote",
        "path": "/cast-vote",
        "file": "services/api-gateway/app/api/v1/user-voting.py"
      },
      {
        "route": "GET:/bill/{bill_id}/user-votes",
        "path": "/bill/{bill_id}/user-votes",
        "file": "services/api-gateway/app/api/v1/user-voting.py"
      },
      {
        "route": "GET:/bill/{bill_id}/voting-summary",
        "path": "/bill/{bill_id}/voting-summary",
        "file": "services/api-gateway/app/api/v1/user-voting.py"
      },
      {
        "route": "ROUTER:/user-voting",
        "path": "/user-voting",
        "file": "services/api-gateway/app/api/v1/user-voting.py"
      },
      {
        "route": "GET:/profiles",
        "path": "/profiles",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "GET:/profiles/{user_id}",
        "path": "/profiles/{user_id}",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "PUT:/profiles/{user_id}",
        "path": "/profiles/{user_id}",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "POST:/profiles/{user_id}/change-password",
        "path": "/profiles/{user_id}/change-password",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "GET:/profiles/{user_id}/preferences",
        "path": "/profiles/{user_id}/preferences",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "PUT:/profiles/{user_id}/preferences",
        "path": "/profiles/{user_id}/preferences",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "POST:/profiles/{user_id}/activity",
        "path": "/profiles/{user_id}/activity",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "GET:/profiles/{user_id}/activity",
        "path": "/profiles/{user_id}/activity",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "GET:/profiles/{user_id}/stats",
        "path": "/profiles/{user_id}/stats",
        "file": "services/api-gateway/app/api/v1/user_management.py"
      },
      {
        "route": "GET:/search",
        "path": "/search",
        "file": "services/api-gateway/src/api/v1/feeds.py"
      },
      {
        "route": "GET:/status",
        "path": "/status",
        "file": "services/api-gateway/app/api/v1/websocket.py"
      },
      {
        "route": "POST:/heartbeat/{connection_id}",
        "path": "/heartbeat/{connection_id}",
        "file": "services/api-gateway/app/api/v1/websocket.py"
      },
      {
        "route": "GET:/health/{connection_id}",
        "path": "/health/{connection_id}",
        "file": "services/api-gateway/app/api/v1/websocket.py"
      },
      {
        "route": "POST:/cleanup",
        "path": "/cleanup",
        "file": "services/api-gateway/app/api/v1/websocket.py"
      },
      {
        "route": "GET:/connections/{connection_id}",
        "path": "/connections/{connection_id}",
        "file": "services/api-gateway/app/api/v1/websocket.py"
      },
      {
        "route": "GET:/rooms/{room}",
        "path": "/rooms/{room}",
        "file": "services/api-gateway/app/api/v1/websocket.py"
      },
      {
        "route": "POST:/broadcast",
        "path": "/broadcast",
        "file": "services/api-gateway/app/api/v1/websocket.py"
      },
      {
        "route": "POST:/notify/{connection_id}",
        "path": "/notify/{connection_id}",
        "file": "services/api-gateway/app/api/v1/websocket.py"
      },
      {
        "route": "POST:/feeds",
        "path": "/feeds",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "GET:/feeds",
        "path": "/feeds",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "GET:/feeds/{feed_id}",
        "path": "/feeds/{feed_id}",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "PUT:/feeds/{feed_id}",
        "path": "/feeds/{feed_id}",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "DELETE:/feeds/{feed_id}",
        "path": "/feeds/{feed_id}",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "GET:/feeds/{feed_id}/generate",
        "path": "/feeds/{feed_id}/generate",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "GET:/feeds/by-name/{feed_name}",
        "path": "/feeds/by-name/{feed_name}",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "POST:/feeds/{feed_id}/items",
        "path": "/feeds/{feed_id}/items",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "GET:/feeds/{feed_id}/statistics",
        "path": "/feeds/{feed_id}/statistics",
        "file": "services/api-gateway/app/api/v1/rss_feeds.py"
      },
      {
        "route": "GET:/statistics",
        "path": "/statistics",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "GET:/user/{user_id}/saved-items",
        "path": "/user/{user_id}/saved-items",
        "file": "services/api-gateway/app/api/v1/saved_items.py"
      },
      {
        "route": "POST:/user/{user_id}/save-item",
        "path": "/user/{user_id}/save-item",
        "file": "services/api-gateway/app/api/v1/saved_items.py"
      },
      {
        "route": "PUT:/user/{user_id}/saved-items/{item_id}",
        "path": "/user/{user_id}/saved-items/{item_id}",
        "file": "services/api-gateway/app/api/v1/saved_items.py"
      },
      {
        "route": "DELETE:/user/{user_id}/saved-items/{item_id}",
        "path": "/user/{user_id}/saved-items/{item_id}",
        "file": "services/api-gateway/app/api/v1/saved_items.py"
      },
      {
        "route": "GET:/user/{user_id}/saved-items/tags",
        "path": "/user/{user_id}/saved-items/tags",
        "file": "services/api-gateway/app/api/v1/saved_items.py"
      },
      {
        "route": "GET:/user/{user_id}/saved-items/search",
        "path": "/user/{user_id}/saved-items/search",
        "file": "services/api-gateway/app/api/v1/saved_items.py"
      },
      {
        "route": "GET:/speeches/",
        "path": "/speeches/",
        "file": "services/api-gateway/app/api/v1/debates.py"
      },
      {
        "route": "GET:/speeches/{speech_id}/",
        "path": "/speeches/{speech_id}/",
        "file": "services/api-gateway/app/api/v1/debates.py"
      },
      {
        "route": "GET:/{date}/statements",
        "path": "/{date}/statements",
        "file": "services/api-gateway/app/api/v1/debates.py"
      },
      {
        "route": "GET:/ballots/",
        "path": "/ballots/",
        "file": "services/api-gateway/app/api/v1/votes.py"
      },
      {
        "route": "GET:/{session_id}/{vote_number}/analysis",
        "path": "/{session_id}/{vote_number}/analysis",
        "file": "services/api-gateway/app/api/v1/votes.py"
      },
      {
        "route": "POST:/metrics",
        "path": "/metrics",
        "file": "services/api-gateway/app/api/v1/performance_optimization.py"
      },
      {
        "route": "GET:/metrics/{metric_id}",
        "path": "/metrics/{metric_id}",
        "file": "services/api-gateway/app/api/v1/performance_optimization.py"
      },
      {
        "route": "POST:/alerts",
        "path": "/alerts",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "GET:/alerts",
        "path": "/alerts",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "POST:/health/check",
        "path": "/health/check",
        "file": "services/api-gateway/app/api/v1/performance_optimization.py"
      },
      {
        "route": "GET:/health/overview",
        "path": "/health/overview",
        "file": "services/api-gateway/app/api/v1/performance_optimization.py"
      },
      {
        "route": "POST:/analysis",
        "path": "/analysis",
        "file": "services/api-gateway/app/api/v1/performance_optimization.py"
      },
      {
        "route": "GET:/alerts/{alert_id}",
        "path": "/alerts/{alert_id}",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "PUT:/alerts/{alert_id}",
        "path": "/alerts/{alert_id}",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "DELETE:/alerts/{alert_id}",
        "path": "/alerts/{alert_id}",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "GET:/templates",
        "path": "/templates",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "GET:/templates/{template_id}",
        "path": "/templates/{template_id}",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "POST:/campaigns",
        "path": "/campaigns",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "GET:/campaigns",
        "path": "/campaigns",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "GET:/analytics",
        "path": "/analytics",
        "file": "services/api-gateway/app/api/v1/user_profiles.py"
      },
      {
        "route": "GET:/alerts/stats",
        "path": "/alerts/stats",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "POST:/notifications/send",
        "path": "/notifications/send",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "POST:/unsubscribe/generate",
        "path": "/unsubscribe/generate",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "POST:/unsubscribe/{token}",
        "path": "/unsubscribe/{token}",
        "file": "services/api-gateway/app/api/v1/email_alerts.py"
      },
      {
        "route": "POST:/manifests",
        "path": "/manifests",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "GET:/manifests",
        "path": "/manifests",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "GET:/manifests/{manifest_id}",
        "path": "/manifests/{manifest_id}",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "GET:/manifests/{manifest_id}/manifest.json",
        "path": "/manifests/{manifest_id}/manifest.json",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "POST:/manifests/{manifest_id}/service-workers",
        "path": "/manifests/{manifest_id}/service-workers",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "GET:/manifests/{manifest_id}/service-workers",
        "path": "/manifests/{manifest_id}/service-workers",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "POST:/manifests/{manifest_id}/offline-resources",
        "path": "/manifests/{manifest_id}/offline-resources",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "GET:/manifests/{manifest_id}/offline-resources",
        "path": "/manifests/{manifest_id}/offline-resources",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "POST:/installations/track",
        "path": "/installations/track",
        "file": "services/api-gateway/app/api/v1/pwa_system.py"
      },
      {
        "route": "GET:/{committee_id}/meetings",
        "path": "/{committee_id}/meetings",
        "file": "services/api-gateway/app/api/v1/committees.py"
      },
      {
        "route": "GET:/{committee_slug}/",
        "path": "/{committee_slug}/",
        "file": "services/api-gateway/app/api/v1/committees.py"
      },
      {
        "route": "GET:/meetings/",
        "path": "/meetings/",
        "file": "services/api-gateway/app/api/v1/committees.py"
      },
      {
        "route": "GET:/activities/",
        "path": "/activities/",
        "file": "services/api-gateway/app/api/v1/committees.py"
      },
      {
        "route": "GET:/postcode/{postcode}",
        "path": "/postcode/{postcode}",
        "file": "services/api-gateway/app/api/v1/search.py"
      },
      {
        "route": "GET:/boundary-sets",
        "path": "/boundary-sets",
        "file": "services/api-gateway/app/api/v1/represent.py"
      },
      {
        "route": "GET:/boundaries/{boundary_set_slug}",
        "path": "/boundaries/{boundary_set_slug}",
        "file": "services/api-gateway/app/api/v1/represent.py"
      },
      {
        "route": "GET:/representatives/{representative_set_slug}",
        "path": "/representatives/{representative_set_slug}",
        "file": "services/api-gateway/app/api/v1/represent.py"
      },
      {
        "route": "GET:/postal-code/{postal_code}",
        "path": "/postal-code/{postal_code}",
        "file": "services/api-gateway/app/api/v1/represent.py"
      },
      {
        "route": "GET:/geocode",
        "path": "/geocode",
        "file": "services/api-gateway/app/api/v1/represent.py"
      },
      {
        "route": "GET:/health",
        "path": "/health",
        "file": "services/api-gateway/app/api/v1/represent.py"
      },
      {
        "route": "POST:/languages",
        "path": "/languages",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "GET:/languages",
        "path": "/languages",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "GET:/languages/{language_id}",
        "path": "/languages/{language_id}",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "PUT:/languages/{language_id}",
        "path": "/languages/{language_id}",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "POST:/translations",
        "path": "/translations",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "GET:/translations",
        "path": "/translations",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "GET:/translations/{translation_id}",
        "path": "/translations/{translation_id}",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "POST:/users/preferences",
        "path": "/users/preferences",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "GET:/users/preferences",
        "path": "/users/preferences",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "POST:/toggle",
        "path": "/toggle",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "GET:/current",
        "path": "/current",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "GET:/translate/{translation_key}",
        "path": "/translate/{translation_key}",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "POST:/translate/search",
        "path": "/translate/search",
        "file": "services/api-gateway/app/api/v1/language_support.py"
      },
      {
        "route": "POST:/postal-code",
        "path": "/postal-code",
        "file": "services/api-gateway/app/api/v1/user_profiles.py"
      },
      {
        "route": "GET:/constituency/{postal_code}",
        "path": "/constituency/{postal_code}",
        "file": "services/api-gateway/app/api/v1/user_profiles.py"
      },
      {
        "route": "GET:/user/{user_id}/activity",
        "path": "/user/{user_id}/activity",
        "file": "services/api-gateway/app/api/v1/user_profiles.py"
      },
      {
        "route": "GET:/user/{user_id}/preferences",
        "path": "/user/{user_id}/preferences",
        "file": "services/api-gateway/app/api/v1/user_profiles.py"
      },
      {
        "route": "PUT:/user/{user_id}/preferences",
        "path": "/user/{user_id}/preferences",
        "file": "services/api-gateway/app/api/v1/user_profiles.py"
      },
      {
        "route": "GET:/{member_id}",
        "path": "/{member_id}",
        "file": "services/api-gateway/app/api/v1/members.py"
      },
      {
        "route": "GET:/by-postal-code/{postal_code}",
        "path": "/by-postal-code/{postal_code}",
        "file": "services/api-gateway/app/api/v1/members.py"
      },
      {
        "route": "GET:/{member_id}/votes",
        "path": "/{member_id}/votes",
        "file": "services/api-gateway/app/api/v1/members.py"
      },
      {
        "route": "GET:/{member_id}/committees",
        "path": "/{member_id}/committees",
        "file": "services/api-gateway/app/api/v1/members.py"
      },
      {
        "route": "GET:/{member_id}/activity",
        "path": "/{member_id}/activity",
        "file": "services/api-gateway/app/api/v1/members.py"
      },
      {
        "route": "GET:/{member_id}/profile",
        "path": "/{member_id}/profile",
        "file": "services/api-gateway/app/api/v1/members.py"
      },
      {
        "route": "POST:/app-auth/register",
        "path": "/app-auth/register",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app-auth/login",
        "path": "/app-auth/login",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "GET:/app/v1/profile",
        "path": "/app/v1/profile",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "PUT:/app/v1/profile",
        "path": "/app/v1/profile",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app/v1/change-password",
        "path": "/app/v1/change-password",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "DELETE:/app/v1/delete-account",
        "path": "/app/v1/delete-account",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "GET:/app/v1/bills",
        "path": "/app/v1/bills",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "GET:/app/v1/bills/{bill_id}",
        "path": "/app/v1/bills/{bill_id}",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app/v1/bills/{bill_id}/support",
        "path": "/app/v1/bills/{bill_id}/support",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app/v1/bills/{bill_id}/bookmark",
        "path": "/app/v1/bills/{bill_id}/bookmark",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app/v1/issues/create",
        "path": "/app/v1/issues/create",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app/v1/issues/{issue_id}/support",
        "path": "/app/v1/issues/{issue_id}/support",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app/v1/issues/{issue_id}/bookmark",
        "path": "/app/v1/issues/{issue_id}/bookmark",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app/v1/issues/{issue_id}/request-deletion",
        "path": "/app/v1/issues/{issue_id}/request-deletion",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "GET:/app/v1/representatives",
        "path": "/app/v1/representatives",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "GET:/app/v1/representatives/all",
        "path": "/app/v1/representatives/all",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "GET:/app/v1/chat/get-bill",
        "path": "/app/v1/chat/get-bill",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/app/v1/chat/bill-chat",
        "path": "/app/v1/chat/bill-chat",
        "file": "services/api-gateway/app/api/v1/mobile_app.py"
      },
      {
        "route": "POST:/sessions",
        "path": "/sessions",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "GET:/sessions",
        "path": "/sessions",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "GET:/sessions/{session_id}",
        "path": "/sessions/{session_id}",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "PUT:/sessions/{session_id}",
        "path": "/sessions/{session_id}",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "POST:/sessions/{session_id}/sittings",
        "path": "/sessions/{session_id}/sittings",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "GET:/sessions/{session_id}/sittings",
        "path": "/sessions/{session_id}/sittings",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "POST:/sessions/{session_id}/votes",
        "path": "/sessions/{session_id}/votes",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "GET:/sessions/{session_id}/votes",
        "path": "/sessions/{session_id}/votes",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "POST:/votes/{vote_id}/individual-votes",
        "path": "/votes/{vote_id}/individual-votes",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "POST:/sessions/{session_id}/debates",
        "path": "/sessions/{session_id}/debates",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "GET:/status/current",
        "path": "/status/current",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "PUT:/status/current",
        "path": "/status/current",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "POST:/events",
        "path": "/events",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "GET:/events",
        "path": "/events",
        "file": "services/api-gateway/app/api/v1/house_status.py"
      },
      {
        "route": "POST:/",
        "path": "/",
        "file": "services/api-gateway/app/api/v1/endpoints/entities.py"
      },
      {
        "route": "GET:/user/{user_id}",
        "path": "/user/{user_id}",
        "file": "services/api-gateway/app/api/v1/saved-items.py"
      },
      {
        "route": "GET:/{item_id}",
        "path": "/{item_id}",
        "file": "services/api-gateway/app/api/v1/saved-items.py"
      },
      {
        "route": "PUT:/{item_id}",
        "path": "/{item_id}",
        "file": "services/api-gateway/app/api/v1/saved-items.py"
      },
      {
        "route": "DELETE:/{item_id}",
        "path": "/{item_id}",
        "file": "services/api-gateway/app/api/v1/saved-items.py"
      },
      {
        "route": "GET:/user/{user_id}/stats",
        "path": "/user/{user_id}/stats",
        "file": "services/api-gateway/app/api/v1/saved-items.py"
      },
      {
        "route": "POST:/user/{user_id}/bulk-actions",
        "path": "/user/{user_id}/bulk-actions",
        "file": "services/api-gateway/app/api/v1/saved-items.py"
      },
      {
        "route": "ROUTER:/saved-items",
        "path": "/saved-items",
        "file": "services/api-gateway/app/api/v1/saved-items.py"
      },
      {
        "route": "POST:/types",
        "path": "/types",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "GET:/types",
        "path": "/types",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "GET:/types/{type_id}",
        "path": "/types/{type_id}",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "POST:/visualizations",
        "path": "/visualizations",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "GET:/visualizations",
        "path": "/visualizations",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "GET:/visualizations/{visualization_id}",
        "path": "/visualizations/{visualization_id}",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "POST:/dashboards",
        "path": "/dashboards",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "GET:/dashboards",
        "path": "/dashboards",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "GET:/dashboards/{dashboard_id}",
        "path": "/dashboards/{dashboard_id}",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "POST:/visualizations/{visualization_id}/generate",
        "path": "/visualizations/{visualization_id}/generate",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "POST:/dashboards/{dashboard_id}/visualizations",
        "path": "/dashboards/{dashboard_id}/visualizations",
        "file": "services/api-gateway/app/api/v1/data_visualizations.py"
      },
      {
        "route": "POST:/create",
        "path": "/create",
        "file": "services/api-gateway/app/api/v1/issues.py"
      },
      {
        "route": "GET:/user-issues",
        "path": "/user-issues",
        "file": "services/api-gateway/app/api/v1/issues.py"
      },
      {
        "route": "GET:/{issue_id}",
        "path": "/{issue_id}",
        "file": "services/api-gateway/app/api/v1/issues.py"
      },
      {
        "route": "PUT:/{issue_id}/update",
        "path": "/{issue_id}/update",
        "file": "services/api-gateway/app/api/v1/issues.py"
      },
      {
        "route": "DELETE:/{issue_id}",
        "path": "/{issue_id}",
        "file": "services/api-gateway/app/api/v1/issues.py"
      },
      {
        "route": "GET:/community/issues",
        "path": "/community/issues",
        "file": "services/api-gateway/app/api/v1/issues.py"
      },
      {
        "route": "POST:/{issue_id}/support",
        "path": "/{issue_id}/support",
        "file": "services/api-gateway/app/api/v1/issues.py"
      },
      {
        "route": "GET:/{issue_id}/supporters",
        "path": "/{issue_id}/supporters",
        "file": "services/api-gateway/app/api/v1/issues.py"
      },
      {
        "route": "POST:/register",
        "path": "/register",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "POST:/token",
        "path": "/token",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "GET:/me",
        "path": "/me",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "POST:/logout",
        "path": "/logout",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "POST:/reset-password",
        "path": "/reset-password",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "POST:/confirm-reset-password",
        "path": "/confirm-reset-password",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "GET:/reset-password/validate/{token}",
        "path": "/reset-password/validate/{token}",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "GET:/google/authorize",
        "path": "/google/authorize",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "POST:/google/callback",
        "path": "/google/callback",
        "file": "services/api-gateway/app/api/v1/auth.py"
      },
      {
        "route": "GET:/get-bill",
        "path": "/get-bill",
        "file": "services/api-gateway/app/api/v1/chat.py"
      },
      {
        "route": "GET:/get-issue",
        "path": "/get-issue",
        "file": "services/api-gateway/app/api/v1/chat.py"
      },
      {
        "route": "POST:/bill-chat",
        "path": "/bill-chat",
        "file": "services/api-gateway/app/api/v1/chat.py"
      },
      {
        "route": "POST:/issue-chat",
        "path": "/issue-chat",
        "file": "services/api-gateway/app/api/v1/chat.py"
      },
      {
        "route": "GET:/chat-suggestions",
        "path": "/chat-suggestions",
        "file": "services/api-gateway/app/api/v1/chat.py"
      },
      {
        "route": "GET:/chat-history",
        "path": "/chat-history",
        "file": "services/api-gateway/app/api/v1/chat.py"
      },
      {
        "route": "GET:/offices",
        "path": "/offices",
        "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py"
      },
      {
        "route": "GET:/offices/{office_id}",
        "path": "/offices/{office_id}",
        "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py"
      },
      {
        "route": "GET:/bills",
        "path": "/bills",
        "file": "services/api-gateway/src/api/v1/export.py"
      },
      {
        "route": "GET:/bills/{bill_id}",
        "path": "/bills/{bill_id}",
        "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py"
      },
      {
        "route": "GET:/votes",
        "path": "/votes",
        "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py"
      },
      {
        "route": "GET:/data-sources",
        "path": "/data-sources",
        "file": "services/api-gateway/app/api/v1/multi_level_government_extended.py"
      },
      {
        "route": "GET:/government-levels",
        "path": "/government-levels",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/government-levels/{level_id}",
        "path": "/government-levels/{level_id}",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/jurisdictions",
        "path": "/jurisdictions",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/jurisdictions/{jurisdiction_id}",
        "path": "/jurisdictions/{jurisdiction_id}",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/representatives",
        "path": "/representatives",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/representatives/{representative_id}",
        "path": "/representatives/{representative_id}",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/stats/system",
        "path": "/stats/system",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/stats/government-levels/{level_id}",
        "path": "/stats/government-levels/{level_id}",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/stats/jurisdictions/{jurisdiction_id}",
        "path": "/stats/jurisdictions/{jurisdiction_id}",
        "file": "services/api-gateway/app/api/v1/multi_level_government.py"
      },
      {
        "route": "GET:/bills/{bill_id}/mentions",
        "path": "/bills/{bill_id}/mentions",
        "file": "services/api-gateway/app/api/v1/house_mentions.py"
      },
      {
        "route": "GET:/debates/mentions",
        "path": "/debates/mentions",
        "file": "services/api-gateway/app/api/v1/house_mentions.py"
      },
      {
        "route": "GET:/committees/mentions",
        "path": "/committees/mentions",
        "file": "services/api-gateway/app/api/v1/house_mentions.py"
      },
      {
        "route": "GET:/votes/detailed",
        "path": "/votes/detailed",
        "file": "services/api-gateway/app/api/v1/house_mentions.py"
      },
      {
        "route": "GET:/{user_id}",
        "path": "/{user_id}",
        "file": "services/api-gateway/app/api/v1/endpoints/users.py"
      },
      {
        "route": "PUT:/{user_id}",
        "path": "/{user_id}",
        "file": "services/api-gateway/app/api/v1/endpoints/users.py"
      },
      {
        "route": "DELETE:/{user_id}",
        "path": "/{user_id}",
        "file": "services/api-gateway/app/api/v1/endpoints/users.py"
      },
      {
        "route": "GET:/{entity_id}",
        "path": "/{entity_id}",
        "file": "services/api-gateway/app/api/v1/endpoints/entities.py"
      },
      {
        "route": "GET:/types/list",
        "path": "/types/list",
        "file": "services/api-gateway/app/api/v1/endpoints/entities.py"
      },
      {
        "route": "GET:/detailed",
        "path": "/detailed",
        "file": "services/api-gateway/app/api/v1/endpoints/health.py"
      },
      {
        "route": "GET:/api/versions",
        "path": "/api/versions",
        "file": "services/api-gateway/src/core/versioning.py"
      },
      {
        "route": "GET:/recent-bills",
        "path": "/recent-bills",
        "file": "services/api-gateway/src/api/v1/feeds.py"
      },
      {
        "route": "GET:/recent-debates",
        "path": "/recent-debates",
        "file": "services/api-gateway/src/api/v1/feeds.py"
      },
      {
        "route": "GET:/mp/{mp_slug}/statements",
        "path": "/mp/{mp_slug}/statements",
        "file": "services/api-gateway/src/api/v1/feeds.py"
      },
      {
        "route": "GET:/mp/{mp_slug}/activity",
        "path": "/mp/{mp_slug}/activity",
        "file": "services/api-gateway/src/api/v1/feeds.py"
      },
      {
        "route": "ROUTER:/feeds",
        "path": "/feeds",
        "file": "services/api-gateway/src/api/v1/feeds.py"
      },
      {
        "route": "GET:/members",
        "path": "/members",
        "file": "services/api-gateway/src/api/v1/export.py"
      },
      {
        "route": "GET:/debates",
        "path": "/debates",
        "file": "services/api-gateway/src/api/v1/export.py"
      },
      {
        "route": "GET:/bulk/{dataset}",
        "path": "/bulk/{dataset}",
        "file": "services/api-gateway/src/api/v1/export.py"
      },
      {
        "route": "ROUTER:/export",
        "path": "/export",
        "file": "services/api-gateway/src/api/v1/export.py"
      }
    ],
    "orphan_components": [
      {
        "component": "GovernmentPage",
        "file": "services/web-ui/src/app/government/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/government-levels"
      },
      {
        "component": "GovernmentPage",
        "file": "services/web-ui/src/app/government/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/stats/system"
      },
      {
        "component": "FederalPage",
        "file": "services/web-ui/src/app/government/federal/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/government-levels"
      },
      {
        "component": "FederalPage",
        "file": "services/web-ui/src/app/government/federal/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/stats/government-levels/${federalLevel.id}"
      },
      {
        "component": "FederalPage",
        "file": "services/web-ui/src/app/government/federal/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/jurisdictions?government_level=${federalLevel.id}&page_size=10"
      },
      {
        "component": "FederalPage",
        "file": "services/web-ui/src/app/government/federal/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/representatives?government_level=${federalLevel.id}&page_size=10"
      },
      {
        "component": "FederalPage",
        "file": "services/web-ui/src/app/government/federal/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/bills?government_level=${federalLevel.id}&page_size=10"
      },
      {
        "component": "AllVotesPage",
        "file": "services/web-ui/src/app/government/votes/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/votes?${params}"
      },
      {
        "component": "AllVotesPage",
        "file": "services/web-ui/src/app/government/votes/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/government-levels"
      },
      {
        "component": "AllBillsPage",
        "file": "services/web-ui/src/app/government/bills/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/bills?${params}"
      },
      {
        "component": "AllBillsPage",
        "file": "services/web-ui/src/app/government/bills/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/government-levels"
      },
      {
        "component": "AllRepresentativesPage",
        "file": "services/web-ui/src/app/government/representatives/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/representatives?${params}"
      },
      {
        "component": "AllRepresentativesPage",
        "file": "services/web-ui/src/app/government/representatives/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/government-levels"
      },
      {
        "component": "AllJurisdictionsPage",
        "file": "services/web-ui/src/app/government/jurisdictions/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/jurisdictions?${params}"
      },
      {
        "component": "AllJurisdictionsPage",
        "file": "services/web-ui/src/app/government/jurisdictions/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/government-levels"
      },
      {
        "component": "DataSourcesPage",
        "file": "services/web-ui/src/app/government/data-sources/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/data-sources?${params}"
      },
      {
        "component": "DataSourcesPage",
        "file": "services/web-ui/src/app/government/data-sources/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/government-levels"
      },
      {
        "component": "JurisdictionDetailPage",
        "file": "services/web-ui/src/app/government/jurisdictions/[id]/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/jurisdictions/${jurisdictionId}"
      },
      {
        "component": "JurisdictionDetailPage",
        "file": "services/web-ui/src/app/government/jurisdictions/[id]/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/stats/jurisdictions/${jurisdictionId}"
      },
      {
        "component": "JurisdictionDetailPage",
        "file": "services/web-ui/src/app/government/jurisdictions/[id]/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/representatives?jurisdiction_id=${jurisdictionId}&page_size=10"
      },
      {
        "component": "JurisdictionDetailPage",
        "file": "services/web-ui/src/app/government/jurisdictions/[id]/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/bills?jurisdiction_id=${jurisdictionId}&page_size=10"
      },
      {
        "component": "JurisdictionDetailPage",
        "file": "services/web-ui/src/app/government/jurisdictions/[id]/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/votes?page_size=10"
      },
      {
        "component": "RepresentativeDetailPage",
        "file": "services/web-ui/src/app/government/representatives/[id]/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/representatives/${representativeId}"
      },
      {
        "component": "RepresentativeDetailPage",
        "file": "services/web-ui/src/app/government/representatives/[id]/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/bills?sponsor_id=${representativeId}&page_size=10"
      },
      {
        "component": "RepresentativeDetailPage",
        "file": "services/web-ui/src/app/government/representatives/[id]/page.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/votes?representative_id=${representativeId}&page_size=20"
      },
      {
        "component": "FeedbackPortal",
        "file": "services/web-ui/src/components/feedback/FeedbackPortal.tsx",
        "unmapped_endpoint": "${fiderUrl}/api/v1/health"
      },
      {
        "component": "Dashboard",
        "file": "services/admin-ui/src/pages/Dashboard.tsx",
        "unmapped_endpoint": "/api/v1/multi-level-government/stats"
      }
    ],
    "mismatched_patterns": [
      {
        "pattern": "/mp/*/statements",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/get-issue",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/chat/get-bill",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/profiles",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app-auth/register",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/sessions/*/debates",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/notifications/send",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/installations/track",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/boundaries/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/saved-items/search",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/bulk/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/chat/bill-chat",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/confirm-reset-password",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/speeches/*/",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/languages/*",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/suggestions",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/languages",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/voting-recommendations",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app-auth/login",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/google/authorize",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/feeds/*/items",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/update",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/",
        "api_count": 2,
        "ui_count": 1
      },
      {
        "pattern": "/health",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/current",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/bills/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/google/callback",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/activities/",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/dashboards",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/healthz",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/statements",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/postal-code",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/logout",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/stats/system",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/preferences",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/*/activity",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/broadcast",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/unsubscribe/generate",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/status",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/users/preferences",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/templates",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/data/quality",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/version",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/save-item",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/dashboards/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/government-levels/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/templates/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/alerts",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/profiles/*/change-password",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/unsubscribe/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user-voting",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/issues/*/support",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/status/current",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/bills",
        "api_count": 1,
        "ui_count": 2
      },
      {
        "pattern": "/app/v1/issues/*/request-deletion",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/bills/*/voting-summary",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/speeches/",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/alerts/stats",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/bills",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/profile",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/issues/create",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/metrics",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/health/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/manifests",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/representatives/all",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/get-bill",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/votes/detailed",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/voting-history",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/offices/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/reset-password",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/chat-history",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/status",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/toggle",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/jurisdictions/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/support",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/translate/search",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/api/v1/multi-level-government/stats",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/feeds/*/generate",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/visualizations/*/generate",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user-issues",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/etl",
        "api_count": 0,
        "ui_count": 2
      },
      {
        "pattern": "/metrics/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/connections/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/saved-items",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/chat-suggestions",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/boundary-sets",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/debates/mentions",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/profiles/*/preferences",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/visualizations/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/analysis",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/meetings",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/saved-items",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/register",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/government-levels",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/types/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/health/check",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/manifests/*/service-workers",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/statistics",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/create",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/bills/*/support",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/api/v1/multi-level-government/jurisdictions",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/api/v1/multi-level-government/representatives",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/members",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/issue-chat",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/sessions/*/votes",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/*/timeline",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/profiles/*",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/government",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/committees/mentions",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/representatives/*",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/summary/stats",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/events",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/stats/government-levels/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/recent-debates",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/votes",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/bill-chat",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/bills/*/user-votes",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "#",
        "api_count": 0,
        "ui_count": 5
      },
      {
        "pattern": "/postcode/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/sessions",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/votes/*/individual-votes",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/api/v1/multi-level-government/government-levels",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/*/amendments",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/translations/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/api/v1/multi-level-government/bills",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/app/v1/representatives",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/sessions/*/sittings",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/issues/*/bookmark",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/me",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/token",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/saved-items/tags",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/former-mps",
        "api_count": 0,
        "ui_count": 4
      },
      {
        "pattern": "/bills/*/mentions",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/rooms/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/cleanup",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/supporters",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/bill/*/voting-summary",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/saved-items/*",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/detailed",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/monitoring",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/constituency/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/bulk-actions",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/activity",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/export",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/*/*/",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/health/overview",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/analytics",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/visualizations",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/*/history",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/delete-account",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/bills/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/api/versions",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/community/issues",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/jurisdictions",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/api/v1/etl/jobs",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/manifests/*/offline-resources",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/reset-password/validate/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/data-sources",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/meetings/",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/api/v1/admin/activity",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/feeds/*/statistics",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/change-password",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/bills/*/cast-vote",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/by-postal-code/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/types/list",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/mps",
        "api_count": 0,
        "ui_count": 1
      },
      {
        "pattern": "/alerts/*",
        "api_count": 3,
        "ui_count": 0
      },
      {
        "pattern": "/feeds",
        "api_count": 3,
        "ui_count": 0
      },
      {
        "pattern": "/app/v1/bills/*/bookmark",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/manifests/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/dashboards/*/visualizations",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/mp/*/activity",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/recent-bills",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*",
        "api_count": 11,
        "ui_count": 0
      },
      {
        "pattern": "/user/*/stats",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/stats/jurisdictions/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/profile",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/heartbeat/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/translate/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/committees",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/*/analysis",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/feeds/by-name/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/geocode",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/manifests/*/manifest.json",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/translations",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/feeds/*",
        "api_count": 3,
        "ui_count": 0
      },
      {
        "pattern": "/profiles/*/activity",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/types",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/ballots/",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/sessions/*",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/cast-vote",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/bill/*/user-votes",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/notify/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/offices",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/profiles/*/stats",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/campaigns",
        "api_count": 2,
        "ui_count": 0
      },
      {
        "pattern": "/postal-code/*",
        "api_count": 1,
        "ui_count": 0
      },
      {
        "pattern": "/*/votes",
        "api_count": 2,
        "ui_count": 0
      }
    ],
    "optimization_opportunities": []
  }
}